{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"令夕","url":"http://yoursite.com","root":"/"},"pages":[{"title":"这是自我介绍的题目","date":"2019-06-01T08:54:31.000Z","updated":"2019-06-01T08:54:55.313Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这是一段自我介绍"}],"posts":[{"title":"（十）CSS Tree Shaking","slug":"webpack4/（十）CSS Tree Shaking","date":"2019-06-04T15:12:27.000Z","updated":"2019-06-04T14:52:33.507Z","comments":true,"path":"2019/06/04/webpack4/（十）CSS Tree Shaking/","link":"","permalink":"http://yoursite.com/2019/06/04/webpack4/（十）CSS Tree Shaking/","excerpt":"","text":"demo10 源码地址CSS Tree Shaking 并不像 Js Tree Shaking 那样方便理解，首先要模拟一个真实的项目环境，来体现 CSS 的 Tree Shaking 的配置和效果。 此章节源码给予第八节处理 CSS 项目上做修改我们首先编写/src/css/base.css 样式文件，在文件中，我们编写了 3 个样式类。但在代码中，我们只会使用.box 和.box–big 这两个类。代码如下所示： 12345678910111213141516171819202122232425/* base.css */html &#123; background: red;&#125;.box &#123; height: 200px; width: 200px; border-radius: 3px; background: green;&#125;.box--big &#123; height: 300px; width: 300px; border-radius: 5px; background: red;&#125;.box-small &#123; height: 100px; width: 100px; border-radius: 2px; background: yellow;&#125; 按照正常使用习惯，DOM 操作来实现样式的添加和卸载，是一贯技术手段。所以，入口文件/src/app.js 中创建一个标签，并且将它的类设为.box 12345678// index.jsimport base from \"./css/base.css\";// 给 app 标签再加一个 div 并且类名为 boxvar app = document.getElementById(\"app\");var div = document.createElement(\"div\");div.className = \"box\";app.appendChild(div); 最后，为了让环境更接近实际环境，我们在 index.html 的一个标签，也引用了定义好的 box-big 样式类。 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;CSS Tree Shaking&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;div class=\"box-big\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; PurifyCSS将帮助我们进行 CSS Tree Shaking 操作。为了能准确指明要进行 Tree Shaking 的 CSS 文件，还有 glob-all （另一个第三方库）。安装依赖： npm i glob-all purify-css perifycss-webpack –save-dev 更改配置文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const path = require(\"path\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); // 将 css 单独打包成文件const PurifyCSS = require(\"purifycss-webpack\");const glob = require(\"glob-all\");module.exports = &#123; entry: &#123; app: \"./src/app.js\" &#125;, output: &#123; publicPath: \"./\", // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"[name].bundle.js\", // 代码打包后的文件名 chunkFilename: \"[name].js\" // 代码拆分后的文件名 &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 针对 .scss 或者 .css 后缀的文件设置 loader use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, \"css-loader\" ] &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; // 打包输出HTML title: \"自动生成 HTML\", minify: &#123; // 压缩 HTML 文件 removeComments: true, // 移除 HTML 中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true // 压缩内联 css &#125;, filename: \"index.html\", // 生成后的文件名 template: \"index.html\", // 根据此模版生成 HTML 文件 chunks: [\"app\"] // entry中的 app 入口才会被打包 &#125;), new MiniCssExtractPlugin(&#123; filename: \"[name].css\", chunkFilename: \"[id].css\" &#125;), // 清除无用 css new PurifyCSS(&#123; paths: glob.sync([ // 要做 CSS Tree Shaking 的路径文件 path.resolve(__dirname, \"./*.html\"), // 请注意，我们同样需要对 html 文件进行 tree shaking path.resolve(__dirname, \"./src/*.js\") ]) &#125;) ]&#125;; 打包完查看 dist/app.css 文件在 index.html 和 src/app.js 中引用的样式都被打包了，而没有被使用的样式类 box-small,没有被打包进去。","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（九）JS Tree Shaking","slug":"webpack4/（九）JS Tree Shaking","date":"2019-06-04T14:47:27.000Z","updated":"2019-06-04T14:48:21.859Z","comments":true,"path":"2019/06/04/webpack4/（九）JS Tree Shaking/","link":"","permalink":"http://yoursite.com/2019/06/04/webpack4/（九）JS Tree Shaking/","excerpt":"","text":"demo9 源码地址什么是 Tree Shaking?字面意思是摇树。项目中没有使用的代码会在打包的时候丢掉。JS 的 Tree Shaking 依赖的是 ES6 的模块系统（比如：import 和 export）项目目录如下：在 util.js 文件中写入测试代码 123456789101112// util.jsexport function a() &#123; return \"this is function a\";&#125;export function b() &#123; return \"this is a function b\";&#125;export function c() &#123; return \"this is a function c\";&#125; 在 app.js 中引用 util.js 的 function a() 函数，按需引入： 123// app.jsimport &#123; a &#125; from \"./vendor/until\";console.log(a); 命令行运行 webpack 打包后，打开打包后生成的/dist/app.bundle.js 文件。查找我们 a()函数输出的字符串，如下图所示：如果将查找内容换成this is function &quot;c&quot; 或者 this is function &quot;b&quot;, 并没有相关查找结果。说明 JS Tree Shaking 成功。1.如何处理第三方 JS 库？对于经常使用第三方库（例如 jQuery，lodash 等等），如何实现 Tree Shaking？下面以 lodash.js 为例，进行介绍 安装 lodash.js：npm install lodash –save 在 app.js 中引入 lodash.js 的一个函数： 123// app.jsimport &#123; chunk &#125; from \"lodash\";console.log(chunk([1, 2, 3], 2)); 命令行打包。如下图所示，打包后大小是 70kb。显然，只是引用了一个函数，不应该这么大。并没有进行 Tree Shaking。开头讲过，js tree shaking 利用的是 ES 的模块系统。而 lodash.js 使用的是CommonJS 而不是ES6的写法。所以，安装对应的模块系统即可。 安装 lodash.js 的 ES 写法的版本：npm install lodash-es –save 修改下 app.js: 123// app.jsimport &#123; chunk &#125; from \"lodash-es\";console.log(chunk([1, 2, 3], 2)); 在次打包，打包结果只有 3.5KB（如下图所示）。显然，tree shaking 成功。 在一些对加载速度敏感的项目中使用第三方库，请注意库的写法是否符合 ES 模块系统规范，一方面 webpack 进行 tree shaking。","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（八）处理CSS/SCSS文件","slug":"webpack4/（八）处理css和scss","date":"2019-06-03T15:22:47.000Z","updated":"2019-06-03T15:46:39.968Z","comments":true,"path":"2019/06/03/webpack4/（八）处理css和scss/","link":"","permalink":"http://yoursite.com/2019/06/03/webpack4/（八）处理css和scss/","excerpt":"","text":"demo8 源码地址 （一）准备工作 CSS 在 HTML 中常引入方法有&lt;link&gt;标签和&lt;style&gt;标签两种，所以就结合 webpack 特点实现以下功能： 将 css 通过 link 标签引入 将 css 放在 style 标签里 下图展示了这次代码的目录结构：这次我们要用到 css-loader，style-loader 等 loader，跟 babel 一样，webpack 不知道将 CSS 提取到文件中。需要使用 loader 来加载对应的文件 css-loader：负责解析 CSS 代码，主要是为了处理 CSS 中的依赖，例如@import 和 url()等引用外部文件的声明 style-loader: 会将 css-loader 解析的结果转变为 JS 代码，运行时动态插入 style 标签来让 CSS 代码生效。 （二）安装依赖 npm i css-loader style-loader –save-dev package.json 如下:更改配置文件 12345678910(module.exports = &#123; \"module\": &#123; \"rules\": [ &#123; \"test\": /\\.css$/, // 针对 .css 后缀的文件设置 loader \"use\": [\"style-loader\", \"css-loader\"] &#125; ] &#125;&#125;) 配置 module 中 rules 属性，和配置 babel 一样，首先在 test 中使用正则来过滤 .css 文件，对 .css 文件使用 loader，&#39;``style-loader``&#39;,``&#39;css-loader&#39; 在 base.css 中写入样式 12345678*,body &#123; margin: 0; padding: 0;&#125;html &#123; background: red;&#125; 并在 index.js 中引入 base.css 1import style from \"./css/base.css\"; 配置文件完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940const path = require(\"path\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); // 引入插件module.exports = &#123; entry: &#123; app: \"./src/app.js\" &#125;, output: &#123; publicPath: \"./\", // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"[name].bundle.js\", // 代码打包后的文件名 chunkFilename: \"[name].js\" // 代码拆分后的文件名 &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 针对 .css 后缀的文件设置 loader use: [\"style-loader\", \"css-loader\"] // 使用 loader &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; // 打包输出HTML title: \"自动生成 HTML\", minify: &#123; // 压缩 HTML 文件 removeComments: true, // 移除 HTML 中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true // 压缩内联 css &#125;, filename: \"index.html\", // 生成后的文件名 template: \"index.html\", // 根据此模版生成 HTML 文件 chunks: [\"app\"] // entry中的 app 入口才会被打包 &#125;) ]&#125;; 项目打包，查看 dist 文件夹发现并没有生成 CSS 文件，但是打开 index.html 是有样式的 原因是：style-loader，css-loader 两个 loader 处理后，CSS 代码会转变为 JS，会和 index.js 一起打包可以发现 css 是通过&lt;style&gt;标签注入的 如果需要单独吧 CSS 文件分离出来，我们需要使用mini-css-extract-plugin插件。之前是使用extract-text-webpack-plugin 插件，此插件与 webpack4.0不太匹配，现在使用 mini-css-extract-plugins 确保将 webpack 更新到 4.2.2 版及以上。否则 mini-css-extract-plugin 将无效！ 目前还不支持热更新，也就是在开发环境下更改了 css，需要手动的刷新页面才会看到效果，目前这个插件一般在生产环境中使用，开发环境下还是使用‘style-loader’,具体见官网配置 1npm i mini-css-extract-plugin --save-dev 更改配置文件： 1234567891011121314151617181920212223const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, // 针对 .css 后缀的文件设置 loader use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, \"css-loader\" ] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: \"[name].css\", chunkFilename: \"[id].css\" &#125;) ]&#125;; 这样只是生成了单独的 css 文件，但是并没有压缩，引入 optimize-css-assets-webpack-plugin插件来实现 css 压缩 12&gt; npm install optimize-css-assets-webpack-plugin --save-dev&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&gt;完整代码```javascriptconst path = require(&quot;path&quot;);const CleanWebpackPlugin = require(&quot;clean-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const OptimizeCssAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;);module.exports = &#123; entry: &#123; main: &quot;./src/index.js&quot; &#125;, output: &#123; publicPath: &quot;./&quot;, // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, &quot;dist&quot;), // 打包文件的输出目录 filename: &quot;[name].bundle.js&quot;, // 代码打包后的文件名 chunkFilename: &quot;[name].js&quot; // 代码拆分后的文件名 &#125;, // optimization: &#123; // splitChunks: &#123; // chunks: &apos;all&apos;, // minSize: 30000, // maxSize: 0, // minChunks: 1, // maxAsyncRequests: 5, // maxInitialRequests: 3, // automaticNameDelimiter: &apos;~&apos;, // name: true, // cacheGroups: &#123; // lodash: &#123; // name: &apos;lodash&apos;, // test: /[\\\\/]node_modules[\\\\/]lodash[\\\\/]/, // priority: 10 // &#125;, // commons: &#123; // name: &apos;commons&apos;, // minSize: 0, //表示在压缩前的最小模块大小,默认值是 30kb // minChunks: 2, // 最小公用次数 // priority: 5, // 优先级 // reuseExistingChunk: true // 公共模块必开启 // &#125;, // vendors: &#123; // test: /[\\\\/]node_modules[\\\\/]/, // priority: -10 // &#125;, // default: &#123; // minChunks: 2, // priority: -20, // reuseExistingChunk: true // &#125; // &#125; // &#125; // &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 针对.css后缀文件设置loader // use: [&quot;style-loader&quot;, &quot;css-loader&quot;] use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, &quot;css-loader&quot; ] &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: &quot;处理CSS文件&quot;, // 打包输出HTMl minify: &#123; removeComments: true, // 一出HTML中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true // 压缩内联css &#125;, filename: &quot;index.html&quot;, // 生成后的文件名 template: &quot;index.html&quot; // 根据此模板生成HTML文件 &#125;), new MiniCssExtractPlugin(&#123; filename: &quot;[name].css&quot;, chunkFilename: &quot;[id].css&quot; &#125;), new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: /\\.css$/g, cssProcessor: require(&quot;cssnano&quot;), //用于优化\\最小化 CSS 的 CSS处理器，默认为 cssnano cssProcessorOptions: &#123; safe: true, discardComments: &#123; removeAll: true &#125; &#125;, //传递给 cssProcessor 的选项，默认为&#123;&#125; canPrint: true //布尔值，指示插件是否可以将消息打印到控制台，默认为 true &#125;) ]&#125;; 再打开 css 文件可以发现已经被压缩了，并且打开 index.html 也是有样式的 （三）处理 scss 文件 安装 sass 依赖： npm i node-sass sass-loader –save-dev 在 src 文件夹下新增 scss 文件夹及 main.scss 文件 main.scss 引入样式 123456789$bgColor: black !default;*,body &#123; margin: 0; padding: 0;&#125;html &#123; background: $bgColor;&#125; 在 index.js 中引入 main.scss 文件 12import \"./css/base.css\";import \"./scss/main.scss\"; 修改配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const path = require(\"path\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); // 将 css 单独打包成文件const OptimizeCssAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\"); // 压缩 cssmodule.exports = &#123; entry: &#123; app: \"./src/index.js\" &#125;, output: &#123; publicPath: \"./\", // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"[name].bundle.js\", // 代码打包后的文件名 chunkFilename: \"[name].js\" // 代码拆分后的文件名 &#125;, module: &#123; rules: [ &#123; test: /\\.(scss|css)$/, // 针对.css后缀文件设置loader // use: [\"style-loader\", \"css-loader\"] use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, \"css-loader\", \"sass-loader\" // 使用 sass-loader 将 scss 转为 css ] &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: \"处理CSS文件\", // 打包输出HTMl minify: &#123; removeComments: true, // 一出HTML中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true // 压缩内联css &#125;, filename: \"index.html\", // 生成后的文件名 template: \"index.html\", // 根据此模板生成HTML文件 chunks: [\"app\"] &#125;), new MiniCssExtractPlugin(&#123; // 从js里面吧css提取成一个css文件，插入到html中 filename: \"[name].css\", chunkFilename: \"[id].css\" &#125;), new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: /\\.css$/g, cssProcessor: require(\"cssnano\"), //用于优化\\最小化 CSS 的 CSS处理器，默认为 cssnano cssProcessorOptions: &#123; safe: true, discardComments: &#123; removeAll: true &#125; &#125;, //传递给 cssProcessor 的选项，默认为&#123;&#125; canPrint: true //布尔值，指示插件是否可以将消息打印到控制台，默认为 true &#125;) ]&#125;; module.rules.use 数组中，loader 的位置。根据 webpack 规则：放在最后的 loader 首先被执行，从上往下写的话是下面先执行，从左往右写的话是右边先执行。 1[\"style-loader\", \"css-loader\", \"sass-loader\"]; 执行顺序为sass-loader,css-loader,style-loader首先利用 sass-loader 将 scss 编译为 css，剩下的配置和处理 css 相同的文件打包后在打开 index.html 文件会发现样式已经被 main.scss 中写的覆盖了，处理 scss 成功 （四）为 css 加上浏览器前缀 安装 postcss-loader 和 autoprefixer 依赖 12&gt; npm install postcss-loader autoprefixer --save-dev&gt; 1234567891011&gt;给src/scss/main.css中添加下面的代码```css.example &#123; display: grid; transition: all 0.5s; user-select: none; background: linear-gradient(to bottom, white, black);&#125; 有两种方式来配置 postcss，第一中是直接写在 webpack.config.js 中 12345678910111213141516171819202122module: &#123; rules: [ &#123; test: /\\.(scss|css)$/, // 针对.css后缀文件设置loader // use: [\"style-loader\", \"css-loader\"] use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, \"css-loader\", &#123; loader: \"postcss-loader\", // 使用 postcss 为 css 加上浏览器前缀 options: &#123; plugins: [require(\"autoprefixer\")] &#125; &#125;, \"sass-loader\" // 使用 sass-loader 将 scss 转为 css ] &#125; ];&#125; 打包完之后,查看 dist/app.css 文件第二种方式，在 webpack.config.js 同级目录下，新建 postcss.config.js 配置文件 123module.exports = &#123; plugins: [require(\"autoprefixer\")]&#125;; 同时在 webpack.config.js 中 12345678910111213141516module: &#123; rules: [ &#123; test: /\\.(scss|css)$/, // 针对.css后缀文件设置loader // use: [\"style-loader\", \"css-loader\"] use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, \"css-loader\", \"postcss-loader\", // 使用 postcss 为 css 加上浏览器前缀 \"sass-loader\" // 使用 sass-loader 将 scss 转为 css ] &#125; ];&#125; 由于 module 中的 rules 是倒着执行的，以上的执行顺序sass-loader -&gt; postcss-loader -&gt; css-loader -&gt; MiniCssExtractPlugin.loader postcss-loader 在 css-loader 和 style-loader 之后使用，但要在其他预处理器加载器之前，例如 sass | less | stylus-loader 补充：在 css-loader 中使用 importantLoaders 属性 123456789101112131415161718192021module: &#123; rules: [ &#123; test: /\\.(scss|css)$/, // 针对.css后缀文件设置loader // use: [\"style-loader\", \"css-loader\"] use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, &#123; loader: css - loader, options: &#123; importLoaders: 2 &#125; &#125;, \"postcss-loader\", // 使用 postcss 为 css 加上浏览器前缀 \"sass-loader\" // 使用 sass-loader 将 scss 转为 css ] &#125; ];&#125; importLoaders: 2 表示：在一个 css 中引入了另一个 css，也会执行之前两个 loader，即 postcss-loader 和 sass-loader参考：webpack 官网指南","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（七）自动生成 HTML 文件","slug":"webpack4/（七）自动生成 HTML 文件","date":"2019-06-03T12:50:28.000Z","updated":"2019-06-03T12:52:21.290Z","comments":true,"path":"2019/06/03/webpack4/（七）自动生成 HTML 文件/","link":"","permalink":"http://yoursite.com/2019/06/03/webpack4/（七）自动生成 HTML 文件/","excerpt":"","text":"demo7 源码经过上面几个小节的操作，有没有觉得每次进去更改 index.html 中引入 js 文件很麻烦，一旦打包的名字变更后，也要对应的去修改 index.html 引入的 js 名称，这个时候就要使用一个插件来帮助我们，打包完之后自动生成 HTML 文件，并自动引入打包后的 js 文件** （一）安装依赖 npm i html-webpack-plugin html-loader –save-dev package.json 如下： （二）更改配置文件 12345678910111213141516module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; // 打包输出HTML title: \"自动生成 HTML\", minify: &#123; // 压缩 HTML 文件 removeComments: true, // 移除 HTML 中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true // 压缩内联 css &#125;, filename: \"index.html\", // 生成后的文件名 template: \"index.html\" // 根据此模版生成 HTML 文件 &#125;) ]&#125;; HtmlWebpackPlugin 是在 plugin 这个选项中配置的。常用参数含义如下： title：打包后生成 html 的 title filename：打包后 html 文件名称 template： 模板文件（例子源码中根目录下的 index.html） chunks：和 entry 配置中相匹配。支持多页面，多入口 minify:压缩选项 由于使用了 title 选项，则需要在 template 选项对应的 html 的 title 中加入&lt;%= htmlWebpackPlugin.options.title %&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const path = require(\"path\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); // 引入插件module.exports = &#123; entry: &#123; page: \"./src/page.js\" &#125;, output: &#123; publicPath: __dirname + \"/dist/\", // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"[name].bundle.js\", // 代码打包后的文件名 chunkFilename: \"[name].js\" // 代码拆分后的文件名 &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; // 打包输出HTML title: \"自动生成 HTML\", minify: &#123; // 压缩 HTML 文件 removeComments: true, // 移除 HTML 中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true // 压缩内联 css &#125;, filename: \"index.html\", // 生成后的文件名 template: \"index.html\" // 根据此模版生成 HTML 文件 &#125;) ], optimization: &#123; splitChunks: &#123; chunks: \"all\", cacheGroups: &#123; lodash: &#123; name: \"chunk-lodash\", // 单独将 lodash 拆包 priority: 10, // 优先级要大于 commons 不然会被打包进 commons test: /[\\\\/]node_modules[\\\\/]lodash[\\\\/]/ &#125;, commons: &#123; name: \"chunk-commons\", minSize: 1, //表示在压缩前的最小模块大小,默认值是 30kb minChunks: 2, // 最小公用次数 priority: 5, // 优先级 reuseExistingChunk: true // 公共模块必开启 &#125; &#125; &#125; &#125;&#125;; （三）打包并测试 运行 npm run build打开 dist 文件夹里自动生成的 index.html在浏览器中打开 index.htm 文件，打开控制天也发现有输出，ok，自动生成 HTML 文件成功细心的朋友可能会发现一个问题，生成后的 HTML 文件引入的 js 为绝对路径，但是真实的项目打包完之后都是部署在服务器上面的，用绝对路径肯定不行，因为你本地电脑的绝对路径放在服务器上面肯定找不到 我们要将引入的 js 文件从绝对路基改为相对路径修改 webpack.config.js 文件找到 output 输出配置，更改 publicPath 公共路径，修改为./绝对路径 123456output:&#123; publicPath:'./', // js引用的路径或者是CDN地址 path: path.resolve(__dirname,'dist'), // 打包文件输出目录 filename: '[name].bundle.js', // 代码打包后的文件名 chunkFileName: '[name].js' // 代码拆分后的文件名&#125; 再次打包，看打包后的 index.html 文件，打开浏览器测试也是没有问题的","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（六）Lazy Loading、Prefetching","slug":"webpack4/（六）Lazy Loading、Prefetching","date":"2019-06-02T13:47:28.000Z","updated":"2019-06-02T13:54:26.252Z","comments":true,"path":"2019/06/02/webpack4/（六）Lazy Loading、Prefetching/","link":"","permalink":"http://yoursite.com/2019/06/02/webpack4/（六）Lazy Loading、Prefetching/","excerpt":"","text":"demo6 源码地址 在 demo5 的基础上修改 index.js 文件，并删除了多余的 js 文件 12345document.addEventListener(\"click\", function() &#123; import(/* webpackChunkName: 'use-lodash'*/ \"lodash\").then(function(_) &#123; console.log(_.join([\"3\", \"4\"])); &#125;);&#125;); 这段代码表示的是，当点击页面的时候，异步加载 lodash 并输出内容。 第一次进入页面的时候，并没有加载 lodash 和 use-lodash，当去点击网页的时候，浏览器在去加载，并且控制台输出内容，这就是代码懒加载，如果有用过vue-router的朋友应该会知道路由懒加载，并且官方也推荐使用懒加载的写法，就是为了结合 webpack，下图是生成的项目 其实懒加载就是通过 import 去异步的加载一个模块，具体什么时候加载，这要根据业务来写，比如弹窗组件，模态框组件等等，都是点击按钮后再出现。 懒加载能加载网页的加载速度，如果把你的详情页，弹窗页面打包到一个 js 文件中，用户如果只是访问首页，只需要首页的代码，不需要其他页面的代码，加入多余的代码只会让加载时间变长，所以我们可以对路由进行懒加载，只有当用户访问到对应路由时，再去加载对应的模块 懒加载并不是 webpack 里的概念，而是 ES6 中的 import 语法，webpack 只能识别 important 语法，能进行代码分割而已。important 后面返回的是一个 then，说明这是一个 promise 类型，一些低端浏览器不支持 promise，比如 IE ，如果要使用这种异步代码，就要使用 babel 以及 babel-polyfill 来做转换，因为我使用的是 73 版本的 chrome 浏览器，对 ES6 语法是支持的，所以我并没有安装 babel 也能使用 更改 index.js 文件 12345document.addEventListener(\"click\", function() &#123; const element = document.createElement(\"div\"); element.innerHTML = \"Hello World\"; document.body.appendChild(element);&#125;); 重新打包，并打开 index.html,打开浏览器控制台，按 ctrl + shift + p ，输入 coverage就能看到当前页面加载的 js 代码未使用率，红色区域表示未被使用的代码段 打开 coverage 如果没出现分析的文件，记得刷新一下 这里一开始红色区域的代码未被使用，当我点击了页面后，变成绿色，页面出现了 Hello World，说明代码被使用了 页面刚加载的时候，异步的代码根本就不会执行，但是我们却把它下载下来，实际上就会浪费页面执行性能，webpack 就希望像这样交互的功能，应该把它放到一个异步加载的模块去写 新建一个 click.js 文件 1234567function handleClick() &#123; const element = document.createElement(\"div\"); element.innerHTML = \"Dell Lee\"; document.body.appendChild(element);&#125;export default handleClick; 并且将 index.js 文件改为异步加载的模块 12345document.addEventListener(\"click\", () =&gt; &#123; import(\"./click.js\").then((&#123; default: func &#125;) =&gt; &#123; func(); &#125;);&#125;); 重新打包，使用 coverage 分析演示当加载页面的时候，没有加载业务逻辑，当点击网页的时候，才会加载 1.js 模块，也就是我们在 index.js 中异步引入的 click.js 这么去写代码，才是使页面加载最快的一种方式，写高性能前端代码的时候，不关是考虑缓存，还要考虑代码使用率** **所以 webpack 在打包过程中，是希望我们多写这种异步的代码，才能提升网站的性能，这也是为什么 webpack 的 splitChunks 中的 chunks 默认是 async，异步的 异步能提高你网页打开的性能，而同步代码是增加一个缓存，对性能的提升是非常有限的，因为缓存一般是第二次打开网页或者刷新页面的时候，缓存很有用，但是网页的性能一般是用户第一次打开网页，看首屏的时候。 当然，这也会出现另一个问题，当用户点击的时候，才去加载业务模块，如果业务模块较大的时候，用户点击后并没有立马看到结果，而是要等待几秒，这样体验上也不好，怎么去解决这个问题 一：如果访问首页的时候，不需要加载详情页的逻辑，等用户首页加载完以后，页面展示出来了，页面的宽带被释放出来了，网络空闲了，再「偷偷」的去加载详情页的内容，而不是等用户去点击的时候再去加载 这个解决方案就是依赖 webpack 的 Prefetching/Preloading 特性修改 index.js 12345document.addEventListener(\"click\", () =&gt; &#123; import(/* webpackPrefetch: true */ \"./click.js\").then((&#123; default: func &#125;) =&gt; &#123; func(); &#125;);&#125;); webpackPrefetch: true 会等你主要的 JS 都加载完了之后，网络带宽空闲的时候，它就会预先帮你加载好 重新打包后刷新页面，注意看 Network当网页打开的时候，main.bundle.js 被加载完了，网络空闲了，就会预先加载 1.js 耗时 14ms，等我去点击页面的时候，Network 又多了一个 1.js，耗时 2ms，这是因为第一次加载完了 1.js，被浏览器给缓存起来了，等我点击的时候，浏览器直接从缓存中取，响应速度非常快这里 这里我们使用的是 webpackPrefetch，还有一种 webpackPreload 与 prefetch 相比，Preload 指令有很多不同之处： Prefetch 会等待核心代码加载完之后，有空闲之后再去加载。Preload 会和核心的代码并行加载，还是不推荐 针对优化，不仅仅是局限于缓存，缓存能带来的代码性能提升是非常有限的，而是如何让代码的使用率最高，有一些交互后才用的代码，可以写到异步组件里面去，通过懒加载的形式，去把代码逻辑加载进来，这样会使得页面访问速度变的更快，如果你觉得懒加载会影响用户体验，可以使用 Prefetch 这种方式来预加载，不过在某些游览器不兼容，会有兼容性的问题，重点不是在 Prefetch 怎么去用，而是在做前端代码性能优化的时候，缓存不是最重要的点，最重要的是代码使用的覆盖率上(coverage)","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（一）成功学的秘密","slug":"墨菲定理/（一）成功学的秘密","date":"2019-06-01T11:54:40.000Z","updated":"2019-06-01T12:11:52.086Z","comments":true,"path":"2019/06/01/墨菲定理/（一）成功学的秘密/","link":"","permalink":"http://yoursite.com/2019/06/01/墨菲定理/（一）成功学的秘密/","excerpt":"","text":"洛克定律：确定目标，专注行动 有目标才会成功 除非你清楚自己要到哪里去，否则你永远也到不了自己想去的地方。 古希腊彼得斯说：“须有人生的目标，否则精力全属浪费。” 古罗马小塞涅卡说：“有些人活着没有任何目标，他们在世间行走，就像河中一颗小草，他们不是行走，而是随波逐流。” 在这个世界上有这样一种现象，那就是“没有目标的人在为有目标的人达到目标”。 博恩崔西说：“成功就是目标的达成，其他都是这句话的注解”。 目标要“跳一跳，够得着” 目标不是越大也好，越高越棒，而是根据自己的实际情况，制定出切实可行的目标才有效。这个目标不能太容易就能达到，也不能高到永远也碰不着，“跳一跳，够得着”最好。 千里之行始于足下，汪洋大海积于滴水。成功都是一步一步走出来的。当然也有人一页暴富，一下成名，但又有谁能看到他们之前的努力与艰辛。在俄国著名生物学家巴普洛夫临终前，有人向他请教成功的秘诀。巴浦洛夫值说了八个字：“要热诚而且慢慢来”。“热诚”，有持久的兴趣才能坚持到成功。“慢慢来”，不要急于求成，做自己力所能及的事情，然后不断提高自己：不要妄想一步登天，要为自己定一个切实可行的目标，有挑战又能达到，不断追求，走向成功。 瓦拉赫效应：成功，要懂得经营自己的长处 经营自己的长处，让人生增值 曾有一个叫奥托，瓦拉赫的人，中学时，服务为他选了文学之路，可一学期下来，老师给他的评语竟为：‘瓦拉赫很用功，但过分拘泥，这样的人即使有着完美的品德也绝不可能在文学上发挥出来。’无奈，他又改学油画，但这次得到的评语更令人难以接受：“你是绘画艺术方面不可造就之才”。面对如此“笨拙”的学生，大多数老师认为他已成才无望，只有化学老师觉得他做事情一丝不苟，这是做好化学实验应有的品格，建议他试学化学。谁料，瓦拉赫的智慧火花一下子被点燃了，并最终成为了诺贝尔化学奖的得主… 这就是人们广为传颂的“瓦拉赫效应”。承认缺憾，弥补缺陷 缺憾应该成为一种促使自己向上的激励机制，为而不恃一种自甘沉沦的理由，它暗示你在它上面应当作一点努力。 重要的并不在于你做的是什么事，而在于你应当采取某种行动。最不可取的态度是一点事情都不会去做，一味的让自己躲藏在困难的后面，动不动就被困难吓倒，这很任意让自己滋生一种自卑感，久而久之，就什么事情都不敢去做了。 木桶定律：抓最“长”的，不如抓最“短”的 克服人性“短板”，避开成事“暗礁”俗话说“人无完人”，确实，人性是存在许多弱点的，如恶习，自卑，犯错，忧虑，嫉妒等等。根据木桶定律，这些短处往往是限制我们能力的关键。就像木桶一样，一个桶能装多少水，并不是用最长的木板来衡量。而是要靠最短的木板来衡量，木桶装水的容量受到短木板的限制，所以，要想让桐木装更多的说，我们必须加长自己最短的木板。恶习我们时时刻刻都在无意间地培养着习惯，这令我们在很多情况下都要臣服于习惯。而然，好的习惯可我们效力，不好的习惯，尤其是恶习（如果拖沓，酗酒等），会在做事时严重拖我们的腿。所以，我们要学会对自己的习惯分类，对不好的习惯进行改正，完善，一面将成功毁在自己的恶习之中。自卑自卑，可以说是一种性格上的缺陷，表现为对自己能力，品质评价过低。它往往会抹杀我们的自信心，本来有足够的能力去完成学业或者是工作任务，却因怀疑自己而失败，显得处处不行，处处不如别人。所以，做事情要相信自己的能力，要告诉自己“我能行”，“我是最棒的”，那样，才能吧事情办好，走向成功。犯错人们通常不吧犯错看成是一种缺陷，甚至吧“失败乃成功之母”当成自理名言。殊不知，有两种情况下犯错就是一种缺陷。一种是不断地在一个问题上犯错误，另一种是犯错误的频率比别人高。这些错误，或许是因为他们态度问题，或许是他们做事不够细心，没有责任心导致的，但无论那种，都是成功的绊脚石。因此，平时要学会控制自己，改掉马虎大意等不良习惯；犯错后不要找托词和借口，懂得正视错误，并加以改正。忧虑有位作家曾写道，给人们造成精神压力的，并不是今天的现实，而是对昨天所发生事情的悔恨，以及对明天将要发生的事情的忧虑。没错，忧虑不仅会影响我们的心情，而且给我们的工作和学习带来更大的压力。更重要的是，无休止的忧虑并不能解决问题。所以，我们要学会控制自己的情绪，客观地去看待问题，在现实中磨炼自己的性格。妒忌妒忌是人类最普遍，最根深蒂固的感情之一。它的存在，总是令我们不能理智地，积极地做事，于是，常导致事半功倍，甚至劳而无功的结果。因此，无论在生活中，还是在工作中，我们都应平和，宽容地对待他人，客观地看待自己。虚荣每个人都有一点虚荣心，但是过强的虚荣心，使人很容易被赞美之词迷惑，甚至不能自持，很容易被对手打败。所以，我们要控制自己的虚荣，摆脱虚荣，正确地认识自己。贪婪由于太看重眼前的利益，改放弃时不能放弃，结果X成大错，甚至是悔恨终生。总所周知，很多人因太贪钱财等身外之物而毁了大好前程，有时明知是圈套，却因为抵御不住诱惑而落入陷阱。说到底，不是人不聪明，而是白给了自己的贪欲。可见，要成事，先要找对心态，知足才能常乐。 艾森豪威尔法则：分清主次，高效成事 做事分等级，先抓牛鼻子 做事要有科学地安排，要事第一，先抓住牛鼻子，然后在依照轻重缓急逐步执行，一串串，一层层地吧所有的事情拎起来，条理清晰，成效才能最显著，不要眉毛胡子一把抓。 确定事情的顺序 A：必须要做的事情； B：应该做的事情； C：量力而为的事情； D：可委托他人去做的事情； E：应该删除的工作； 每天吧要做的事情写在纸上，按以上5个类别将事情归类： A：需要做； B：应该做； C：做了也不会错； D：可以授权别人去做； E：可以省略不做； 然后根据上面归类，在每天大部分的时间里做A类和B类的事情，即使一天不能完成所有事情，只要将最值得做的事情做完就好。同样的道理，吧自己1~5年内想要做的事情列出来，然后分为A,B,C三类： A：最想做的事情； B：愿意做的事情； C：无所谓的事情； 接着，从A类目标中跳出A1,A2,A3代表最重要，次重要和第三重要的事情。在针对A类目标，抄在另外一张纸上，列出你想要达成这些目标需要做的工作，接着将这份清单在分出A,B,C等级： A：最想做的事情； B：愿意做的事情； C：做了也不会错的事情； 把这些工作放回原来的目标底下，重新调整结构，规划步骤，接着执行。 这些又被称为六步走方法，几挑选目标，设定优先次序，挑选工作，设定优先次序，安排行程，执行。把这些培养成每天的习惯，长期坚持下来并贯彻下去，相信，无数个条理性的成功慢慢积累，将会使你拥有非常成功的人生。 相关定律：","categories":[{"name":"墨菲定律","slug":"墨菲定律","permalink":"http://yoursite.com/categories/墨菲定律/"}],"tags":[{"name":"墨菲定律","slug":"墨菲定律","permalink":"http://yoursite.com/tags/墨菲定律/"}]},{"title":"mockjs运用","slug":"模拟数据方案/mockjs运用","date":"2019-06-01T02:18:40.000Z","updated":"2019-06-05T12:34:28.399Z","comments":true,"path":"2019/06/01/模拟数据方案/mockjs运用/","link":"","permalink":"http://yoursite.com/2019/06/01/模拟数据方案/mockjs运用/","excerpt":"","text":"demo 源码地址 （一）了解 mockjs 什么是 mockjs？mockjs 就是一个模拟数据，生成随机数据，拦截 ajax 请求。 为什么要使用 mockjs？ 后端给不了数据 数据太长，将数据放在 js 文件里面，完成后挨个改 url 还原真实数据 特殊格式 ip 随机数 图片 地址 分页显示 mockjs 的功能 生产数据:通过 mockjs 提供的方法,你可以轻松地创造大量随机的文本,数字,布尔值,日期,邮箱,链接,图片,颜色等. 强大的拦截功能:mockjs 可以进行强大的 ajax 拦截.能判断请求类型,获取到 url,请求参数等.然后可以返回 mock 的假数据,或者你自己编好的 json 文件.功能强大易上手. （二）mockjs 语法规则 mockjs 可以模拟那些数据？ string number bool array object guid id title paragraph images address date time url email ip regexp mockjs 语法规范包含的两层规范 数据模板（DTD） 数据占位符（DPD） 数据模板（DTD）规范数据模板中的每个属性由三部分构成：属性名、生产规则、属性值 // 格式‘name| rule:value’name: 属性名rule: 生成规则value: 属性值 属性名和生成规则之间用竖线|分割。生成规则是可选的。生成的规则有一下 7 中方式 1）’name|min-max’: value2）’name|count’: value3）’name|min-max.dmin-dmax’: value4）’name|min-max.dcount’: value5）’name|count.dmin-dmax’: value6）’name|count.dcount’: value7）’name|+step’: value 生成规则的含义 需要依赖 属性值 才能确定属性值 中可以含有占位符属性值 还可以指定最终值 初始值和类型 生成规则和具体案例 属性值是字符串 String 1）’name|min-max’: ‘value’ 通过重复’value’ 生成一个字符串，重复次数大雨等于 min，小于等于 max 123Mock.mock(\"/testString\", \"get\", &#123; \"demo1|1-10\": \"*\"&#125;); 打印结果2）’name|count’: ‘value’ ：通过重复 ‘value’ 生成一个字符串，重复次数等于 count 123Mock.mock(\"/testString\", \"get\", &#123; \"demo1|1-10\": \"*\"&#125;); 打印结果 属性值是数字 number 1）’name|min-max’:value ：生成一个大于等于 min，小于等于 max 的整数，属性值 value 只用来确定类型 123Mock.mock(\"/testNumber\", \"get\", &#123; \"demo1|1-100\": 100&#125;); 打印结果2）’name|+step’:value ：属性值自动加 step，初始值为 value 1234567Mock.mock(\"/testNumber\", \"get\", &#123; \"list|5\": [ &#123; \"id|+1\": 1 &#125; ]&#125;); 打印结果3）’name|min-max.dmin-dmax’:value 生成一个浮点数，整数部分大雨等于 min，大于等于 max，小数部分保留 dmin-dmax 123Mock.mock(\"/testNumber\", \"get\", &#123; \"demo3|1-100.1-10\": 100&#125;); 打印结果4）’name|min-max.dcount’:value 生成一个浮点数，整数部分大于等于 min，小于等于 max，小数部分保留 dcount 123Mock.mock(\"/testNumber\", \"get\", &#123; \"demo6|1-100.1\": 1&#125;); 打印结果5）’name|count.dmin-dmax’:value 生成一个浮点数，整数部分为 count，小数部分保留 dmin-dmax 123Mock.mock(\"/testNumber\", \"get\", &#123; \"demo7|23.1-10\": 100&#125;); 打印结果 属性值是布尔 1）’name|count’:value 随机生成一个布尔值，值为 value 的概率为 count/(1+count)，值不为 value 的概率为 1/(1+count) 123Mock.mock(\"/testBoolean\", \"get\", &#123; \"demo|3\": true&#125;); 打印结果2）’name|min-max’:value ：随机生成一个布尔值，值为 value 的概率是 min/(min+max)，值不为 value 的概率是 max/(min+max) 123Mock.mock(\"/testBoolean\", \"get\", &#123; \"demo10|1-10\": true&#125;); 打印结果 属性值是 object 1）’name|min-max’: {} 从属性值{} 中随机选取 min-max 个属性 12345678910Mock.mock(\"/testObject\", \"get\", &#123; \"demo11|2-4\": &#123; \"110000\": \"北京市\", \"120000\": \"天津市\", \"130000\": \"河北省\", \"140000\": \"山西省\", \"150000\": \"宁夏省\", \"160000\": \"陕西省\" &#125;&#125;); 运行结果2）’name|count” 从属性值{}中随机选取 count 个属性 12345678Mock.mock(\"/testObject\", \"get\", &#123; \"demo12|2\": &#123; 姓名: \"张三\", 性别: \"男\", 年龄: \"32\", 爱好: \"敲代码\" &#125;&#125;); 运行结果 属性值是数组 1）’name|1’:[“”,””]或’’’name|1’:[{}, {} …] 从属性值[]中随机选取 1 个元素，作为最终值 123Mock.mock(\"/testArray\", \"get\", &#123; \"demo13|1\": [\"AMD\", \"CMD\", \"UMD\"]&#125;); 运行结果2）’name|count’: [‘ ‘, ‘ ‘ …] 或 ‘name|count’: [{}, {} …] 通过重复属性值[]生成一个新数组，重复次数为 count 次 123Mock.mock(\"/testArray\", \"get\", &#123; \"demo15|3\": [\"AMD\", \"CMD\", \"UMD\"]&#125;); 运行结果3）’name|min-max’:[‘ ‘, ‘ ‘ …] 或 ‘name|min-max’:[{}, {} …]通过重复属性值[]生成一个新数组，重复次数为 min-max 次 123Mock.mock(\"/testArray\", \"get\", &#123; \"demo16|1-1\": [\"AMD\", \"CMD\", \"UMD\"]&#125;); 运行结果 属性值是函数 Function 1）’name’:function(){} 执行函数 function(){}取其返回值作为最终的属性值，上下文为’name’所在属性 123456Mock.mock(\"/testFunction\", \"get\", &#123; foo: \"Demo\", demo17: function() &#123; return this.foo; &#125;&#125;); 打印结果 属性值是函数(RegExp) 1）根据正则表达式 regexp 反向生成可以匹配他的字符串。用于生成自定义格式的字符串。 12345Mock.mock(\"/testRegExp\", \"get\", &#123; regexp1: /[a-z][A-Z][0-9]/, regexp2: /\\w\\W\\s\\S\\d\\D/, regexp3: /\\d&#123;5,10&#125;/&#125;); 打印结果 属性值是路径(Path) 1）匹配当前元素的上下文所在的绝对路径，返回对应值 1234567891011Mock.mock(\"/testPath\", \"get\", &#123; foo: \"hello\", nested: &#123; a: &#123; b: &#123; c: \"Mock.js\" &#125; &#125; &#125;, demo21: \"@/foo @/nested/a/b/c\"&#125;); 打印结果 数据占位符定义规范 PDPMock.Random 是一个工具类，用于生成各种随机数据Mock.Random 的方法在数据模板中成为[占位符]，书写格式为@占位符（参数[,参数]）注意： 用@来标识其后的字符串是占位符 占位符引用的是 Mock.Random 中的方法 通过 Mock.Random.extend()来拓展自定义占位符 占位符也可以引用数据模板中的属性 占位符会用先引用数据模板中的属性 占位符支持相对路径和绝对路径内置方法列表： Type Method Basic boolean, natural, integer, float, character, string, range, date, time, datetime, now image image,dataImage Color color Text paragraph, sentence, word, title, cparagraph, csentence, cword, ctitle Name first,last,name,cfirst,clast,cname Web url,domain,email,ip,tld Address area,region Helper capitalize, upper, lower, pick, shuffle Miscellaneous guid,id 内置方法的使用： 基本方法 String integer date 打印结果 拓展Mock.Random 中的方法与数据模板的@占位符一一对应，在需要时还可以为 Mock.Random 拓展方法，然后在数据模板中通过@拓展方法引用。 12345678910111213141516171819Random.extend(&#123; weekday: function(date) &#123; var weekdays = [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ]; return this.pick(weekdays); &#125;, sex: function(date) &#123; var sexes = [\"男\", \"女\", \"中性\", \"未知\"]; return this.pick(sexes); &#125;&#125;);console.log(Random.weekday()); 运行结果 （三）Mockjs 在 vue 项目中的运用安装 npm install mockjs –save-devnpm install axios –save 目录结构 src/mock.js mock 文件存放目录src/main.js 引入 mockjs 在 src/mock.js 1234567891011121314151617181920212223242526// 引入mockjsconst Mock = require(\"mockjs\");// 获取 mock.Random 对象const Random = Mock.Random;// mock一组数据const produceNewsData = function() &#123; let articles = []; for (let i = 0; i &lt; 10; i++) &#123; let newArticleObject = &#123; title: Random.csentence(5, 30), // Random.csentence( min, max ) thumbnail_pic_s: Random.dataImage(\"300x250\", \"mock的图片1\"), // Random.dataImage( size, text ) 生成一段随机的 Base64 图片编码 author_name: Random.cname(), // Random.cname() 随机生成一个常见的中文姓名 date: Random.date() + \" \" + Random.time() // Random.date()指示生成的日期字符串的格式,默认为yyyy-MM-dd；Random.time() 返回一个随机的时间字符串 &#125;; articles.push(newArticleObject); &#125; return &#123; code: 0, data: &#123; articles: articles &#125; &#125;;&#125;;// Mock.toJSONSchema(produceNewsData);// Mock.mock( url, post/get , 返回的数据)；Mock.mock(\"/news/index\", \"get\", produceNewsData); 在 src/main.js 1234if (process.env.NODE_ENV !== \"production\") &#123; // 判断只在生产环境下使用 require(\"./mock\");&#125; 在 xxx.vue 中引用 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img alt=\"Vue logo\" src=\"./assets/logo.png\"&gt; &lt;HelloWorld msg=\"Welcome to Your Vue.js App\"/&gt; &lt;ul&gt; &lt;li v-for=\"(item,index) in list\" :key=\"index\"&gt; &lt;img :src=\"item.thumbnail_pic_s\" alt&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from \"./components/HelloWorld.vue\";import axios from \"axios\";// import &#123; constants &#125; from 'crypto';export default &#123; name: \"app\", components: &#123; HelloWorld &#125;, data() &#123; return &#123; list: [] &#125;; &#125;, created() &#123; axios.get(\"/news/index\").then(res =&gt; &#123; console.log(res.data.data.articles); this.list = res.data.data.articles; &#125;)； &#125;&#125;;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: \"Avenir\", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 响应结果： （四）使用总结：优点前后端分离：让前端攻城师独立于后端进行开发。增加单元测试的真实性：通过随机数据，模拟各种场景。开发无侵入：不需要修改既有代码，就可以拦截 Ajax 请求，返回模拟的响应数据。用法简单：符合直觉的接口。数据类型丰富：支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等。方便扩展：支持支持扩展更多数据类型，支持自定义函数和正则。缺点Mock 也不是 silver bullet，所以根据项目实际情况和具体需要来确定是否选用 Mock；测试过程中如果大量使用 Mock，mock 测试的场景失去了真是性，可能会导致在后续的系统性测试时才发现 bug，使得缺陷发现的较晚，可能会造成后续修复成本更大；","categories":[{"name":"mockjs运用","slug":"mockjs运用","permalink":"http://yoursite.com/categories/mockjs运用/"}],"tags":[{"name":"mockjs运用","slug":"mockjs运用","permalink":"http://yoursite.com/tags/mockjs运用/"}]},{"title":"（五）Code  Splitting代码分割","slug":"webpack4/（五）Code Splitting代码分割","date":"2019-05-25T13:01:59.000Z","updated":"2019-06-01T12:39:04.855Z","comments":true,"path":"2019/05/25/webpack4/（五）Code Splitting代码分割/","link":"","permalink":"http://yoursite.com/2019/05/25/webpack4/（五）Code Splitting代码分割/","excerpt":"","text":"demo5 源码地址package.json 文件所用依赖，npm install 安装： 1234567891011121314&#123; \"script\": &#123; \"dev\": \"webpack --mode development\", \"build\": \"webpack --mode production\" &#125;, \"devDependencies\": &#123; \"clean-webpack-plugin\": \"^2.0.0\", \"webpack\": \"^4.29.6\", \"webpack-cli\": \"^3.2.3\" &#125;, \"dependencies\": &#123; \"lodash\": \"^4.17.11\" &#125;&#125; 我们在 src/文件夹下创建 index.js 文件 12import _ from 'lodash'console.log(_.join(['a','b','c'])) 目录结构为：配置 webpack.config.js 文件 123456789101112131415161718let path = require('path');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; entry: &#123; main:'./src/index.js', // 入口文件 &#125;, output: &#123; publicPath: __dirname + '/dist/', // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, 'dist'), // 打包文件的输出目录 filename: '[name].bundle.js', // 代码打包后的文件名 chunkFilename: '[name].js' // 代码拆分后的文件名 &#125;, plugins: [ new CleanWebpackPlugin() // 默认情况下，此插件将删除 webpack output.path中所有的文件，以及每次重建后所有未使用的webpack的产品。 ]&#125; 运行 npm run build 打包在 index.html 中使用打包后的文件 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"./dist/main.bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用浏览器打开 index.html 文件，进入控制台，可以看到如下信息：a,b,c 如果我们再改动业务代码，将 index.js 中的代码改为 123import _ from \"lodash\";console.log(_.join([\"a\", \"b\", \"c\"], \"***\")); 再打包，刷新页面可以看到 a***b*****c** 我们引用的第三方框架和我们的业务代码一起被打包，这样会存在着什么问题假设 lodash 为 11M，业务代码也为 11M，打包后就是 2M 浏览器每次打开页面，都要先加载 2M 的文件，才能显示业务逻辑，这样会使得加载时间变长。 业务代码更新会比较频繁，第三方代码基本不会改变，这样重新打包后，假设为 2M 用户重新打开网页后，又会加载 2M 的文件 浏览器是有缓存的，如果文件没有变动的话，就不用去再发送 http 请求，直接从缓存中取，这样在刷新页面或者是第二次进入的时候可以加快网页加载的速度。 怎么解决呢？可以利用 webpack 中代码分割 在 webpack4.0 之前是使用commonsChunkPlugin来拆分公共代码，4.0 之后废弃，并用 splitChunksPlugins在使用 splitChunksPlugins 之前，首先要知道 splitChunksPlugins 是 webpack 主模块中的一个细分模块，无需 npm 引入** 现在我们来配置 webpack.config.js 文件 1234567891011121314151617181920212223let path = require(\"path\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");module.exports = &#123; entry: &#123; main: \"./src/index.js\" // 入口文件 &#125;, output: &#123; publicPath: __dirname + \"/dist/\", // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"[name].bundle.js\", // 代码打包后的文件名 chunkFilename: \"[name].js\" // 代码拆分后的文件名 &#125;, optimization: &#123; splitChunks: &#123; chunks: \"all\" &#125; &#125;, plugins: [ new CleanWebpackPlugin() // 默认情况下，此插件将删除 webpack output.path中所有的文件，以及每次重建后所有未使用的webpack的产品。 ]&#125;; 上面高亮的代码段就是告诉 webpack，要做代码分割了，这里的 chunk:‘all’是分割所有的代码，包括同步代码和异步代码，webpack 默认是 chunks: ‘async’分割异步代码。 我们使用 npm run dev 来打包开发环境下的代码，这样代码就不会压缩，方便我们来观察，可以看到代码被分割成两个文件了打开dist/main.bundle.js文件，在最底部可以看到 src/index.js，里面放的是业务逻辑代码，但是并没有 lodash 的代码 打开dist/vendors~main.js文件，在最上面可以看到 lodash 模块 再次打开页面，控制台也输出了内容，这样就实现了Code Splitting(代码分割) 其实没有 webpack 的时候，也是有代码分割的，不过是需要我们自己手动的分割，而现在使用了 webpack，通过这种配置项的方式，它会自动帮我们去做代码分割 仔细看分割完的代码名称，vendors~main.js，我们对分割完的名称进行更改 还是在 splitChunks 的配置项中，添加 cacheGroups 对象 12345678910optimization: &#123; splitChunks: &#123; chunks: 'all', cacheGroups: &#123; vendors: &#123; name: 'vendors' &#125; &#125; &#125; &#125; 再次打包就可以看到效果了，*cacheGroups *的默认配置会定义 venders 和 default test: /[\\/]node_modules[\\/]/,使用正则过滤，只有 node_modules 引入第三方库才会被分割为了验证默认配置，我们将 splitChunks 属性设置为空对象，再次打包 打包完发现只有一个文件，这是为什么？因为 chunks 默认为 async，只会分割异步的代码，而我们之前写的都是同步的代码，先 import lodash，再去写业务逻辑，现在使用异步的方式来做，将 index.js 中的代码改为如下： 123456789101112function getComponent() &#123; // 使用 异步的形式导入 lodash，default: _ 表示用 _ 代指 lodash return import(\"lodash\").then((&#123; default: _ &#125;) =&gt; &#123; var element = document.createElement(\"div\"); element.innerHTML = _.join([\"hello\", \"world\"], \"-\"); return element; &#125;);&#125;getComponent().then(element =&gt; &#123; document.body.appendChild(element);&#125;); 这里分割出了 0.js 和 main.bundle.js,0 是以 id 为编号来命名 所以一般我们设置 chunk 是为 all，异步，同步代码都在打包现在我们将 webpack 官网上的默认配置拷贝到我们的 webpack.config.js 中来分析一下 1234567891011121314151617181920212223optimization: &#123; splitChunks: &#123; chunks: 'async', minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125; webpack 代码分割的配置是这样的，比如我们要分割 jQuery 和 lodash 这样的第三方库，它会先经过 chunks、minSize、maxSize、minChunks 等等，满足条件后生成 jQuery 和 lodash 两个文件，然后放入 cacheGroup 中缓存着，再根据你在 cacheGroup 中配置的组来决定是将两个文件整合到一个文件打包，还是单独分开打包，比如上面代码中的 vendors，就是将 node_modules 中所有的第三方库都打包到 vendors.js 文件中，如果你还想继续分割可以这么做 12345678910111213141516cacheGroups: &#123; lodash: &#123; name: 'lodash', test: /[\\\\/]node_modules[\\\\/]lodash[\\\\/]/, priority: 5 // 优先级要大于 vendors 不然会被打包进 vendors &#125;, vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125;&#125; 再次打包，就可以看到 lodash 被分割出来了，以后使用第三方库都可以用这种配置来单独分割成一个 js 文件，比如 element-ui，注意设置 priority 的值很重要，优先级越高的会越先被打包如果 index.js 引入了 A.js 和 B.js，同时 A、B 又引入了 common，common 被引入了两次，可以被称为公共模块目录结构为：代码如下： 12345678910111213141516171819202122232425262728293031// a,jsimport './common'console.log('A')export default 'A'// b.jsimport './common'console.log('B')export default 'B'// common.jsconsole.log('公共模块')export default 'common'// index.jsimport './a.js'import './b.js'// 异步代码function getComponent() &#123; // 使用异步的形式导入 lodash，default: _ 表示用 _ 代指 lodash return import('lodash').then((&#123; default: _ &#125;) =&gt; &#123; var element = document.createElement('div') element.innerHTML = _.join(['hello', 'world'], '-') return element &#125;)&#125;getComponent().then(element =&gt; &#123; document.body.appendChild(element)&#125;) 上面那种异步的写法可能比较绕，现在精简一下，并且 webpack 对异步代码通过注释可以直接修改打包后的名称，以下代码全部以异步的形式引入 123456789101112// 异步代码import(/* webpackChunkName: 'a'*/ \"./a\").then(function(a) &#123; console.log(a);&#125;);import(/* webpackChunkName: 'b'*/ \"./b\").then(function(b) &#123; console.log(b);&#125;);import(/* webpackChunkName: 'use-lodash'*/ \"lodash\").then(function(_) &#123; console.log(_.join([\"1\", \"2\"]));&#125;); 将 minChunks 设置为 2，最小公用 2 次才分割 1234567891011121314151617181920212223242526272829303132333435optimization: &#123; splitChunks: &#123; chunks: 'all', minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; lodash: &#123; name: 'lodash', test: /[\\\\/]node_modules[\\\\/]lodash[\\\\/]/, priority: 10 &#125;, commons: &#123; name: 'commons', minSize: 0, //表示在压缩前的最小模块大小,默认值是 30kb minChunks: 2, // 最小公用次数 priority: 5, // 优先级 reuseExistingChunk: true // 公共模块必开启 &#125;, vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125;&#125; 这里分割出了 lodash 和我们在注释中定义的 use-lodash，前者是第三方库，后者是用第三库写的业务代码，也能被分割出来。 这里之所以会自动引入分割后的依赖，可以查看打包后的 main.bundle.js 文件 常用的配置项在下面的表格中，更多配置详情见官网 参考文章webpack4 系列教程 (三): 多页面解决方案 – 提取公共代码webpack 官网","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（四）用babel编译成 ES6","slug":"webpack4/（四）用babel编译成 ES6","date":"2019-05-24T13:01:59.000Z","updated":"2019-06-01T12:43:33.084Z","comments":true,"path":"2019/05/24/webpack4/（四）用babel编译成 ES6/","link":"","permalink":"http://yoursite.com/2019/05/24/webpack4/（四）用babel编译成 ES6/","excerpt":"","text":"demo4 源码地址 （一）了解 Babel 及生态 现代 javascript 主要是用 ES6 编写的。并非每个浏览器都知道怎么去处理 ES6。我们需要某种转换，这个转换步骤称为 transpiling(转译)。transpiling(转译)是指采用 ES6 的语法，转义为旧的浏览器可以理解的行为。 Webpack不知道如何进行转换但是有loading(加载器)：将他们视为转换器。babel-loader 是一个 webpack 的 loader（加载器），用于将 ES6 及以上的版本编译为 ES5 要开始使用loader，我们需要安装一堆依赖项，建议以 ES7 为主，升级建议 @babel/core webpack 和 babel 之前的一个桥梁 @babel/preset-env: 包含 ES6、7 等版本的语法转化规则 @babel/plugin-transform-runtime:避免 polyfill 污染全局变量，减小打包体积 @babel/polyfill:ES6 内置方法和函数转化垫片 babel-loader: 负责 ES6 的转换 如果是用 babel7 来转义，则需要安装@babel/core,@babel-preset-env 和@babel/plugin-transform-runtime,而不是 babel/core,babel-preset-env 和 babel-transform-runtime，他们是用于 babel6 的。 使用@babel/plugin-transform-runtime 的原因：Babel 使用非常小的功能才完成常见的功能。默认情况下，这将添加到需要他的每个文件中。这种重复有时是不必要的，尤其是当你的应用程序分布在多个文件上的时候。transform-runtime 可以重复使用 Babel 注入的程序代码来节省代码，减小开支。 > 使用@babel/polyfill的原因：Babel默认只转换javascript的句法（syntax），而不转换新的**API,比如Iterator,Generator,Set,Maps,Proxy,Reflect,Symbol,Promise等全局对象,**以及一些定义在全局对象上的方法（比如Object.assgin）都不会转码。必须要使用**@babel/polyfill，**为当前环境提供一个垫片。所谓垫片也就是垫平不同浏览器或者不同环境下的差异。 （二）安装依赖或配置 1.安装依赖 npm i @babel/core babel-loader @babel/preset-env @babel/plugin-transform-runtime –save-devnpm i @babel/polyfill @babel/runtime 2.在项目的根目录中创建名.babelrc 的新文件来配置 Babel; 1234&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; 如果遇到如下错误： 123456WARNING: We noticed you're using the `useBuiltIns` option without declaring a core-js version. Currently, we assume version 2.x when no version is passed. Since this default version will likely change in future versions of Babel, we recommend explicitly setting the core-js version you are using via the `corejs` option.You should also be sure that the version you pass to the `corejs` option matches the version specified in your `package.json`'s `dependencies` section. If it doesn't, you need to run one of the following commands: npm install --save core-js@2 npm install --save core-js@3 yarn add core-js@2 yarn add core-js@3 不仅仅要安装 npm install –save core-js@3 还需要设置 .babelrc 设置 “corejs”: 3 123456789101112&#123; \"preset\": [ [ \"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\", \"corejs\": 3 &#125; ] ], \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; 3.webpack 配置 loader（加载器） 1234567891011module:&#123; rules: [ &#123; test: /\\.js$/, // 使用正则来匹配js文件 exclude: /node_modules/, // 排除依赖包文件 use: &#123; loader: 'babel-loader' //使用babel-loader &#125; &#125; ]&#125; webpack.config.js 配置：4.在 app.js 全局引入@babel/polyfill 并写入 ES6 语法，并执行 npm run build 打包 12345678910111213// 全局引入import '@babel/polyfill'// 测试ES6语法是否通过babel转义const array = [1,2,3]const isES6 = () =&gt; console.log(...array)isES6()const arr = [new Promise(() =&gt; &#123;&#125;),new Promise(() =&gt; &#123;&#125;)]arr.map(item =&gt; &#123; console.log(item)&#125;) 5.打包完之后使用IE 浏览器打开 index.html 文件，看控制台是否有输出，如果是新版的 chrome，是可以使用 es6 语法的，所以要用IE 这个浏览器试试 更改.babelrc，只转译我们使用到的 123456789101112&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\", \"corejs\": 2 &#125; ] ], \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; 同时，将全局引入这段代码注释掉在打包 12// 全局引入js// import '@babel/polyfill' 体积就减小了很多，但是更多的情况是我们并不确切的知道项目中引发兼容性的具体原因，所以还是全局的引入比较好。 （三）了解.browserslistrc 配置文件 browserslistrc 用于在不同前端工具之间共享目标浏览器和 Node.js 版本的配置可以看看 browserslist 兼容浏览器的页面当您将一下内容添加到 package.json 时，所有工具都会自动找到目标浏览器 12345\"browserslist\": [ \"&gt; 1%\", \"last 2 version\", \"not ie &lt;= 8\"] 也可以创建.browserslistrc 文件单独写配置 # 所支持的浏览器版本 1% #全球使用统计选择的浏览器版本样式last 2 version #每个浏览器的最后两个版本not ie &lt;= 8 排除小于 ie8 一下的浏览器 该项目还是使用单独创建配置文件的方式，便于理解，如果觉得配置文件不好，也可以写在 package.json 中 参考文献 webpack4 系列教程 (二): 编译 ES6babel 7 的使用的个人理解babel 7 升级建议browserslist","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（三）覆盖默认entry和output","slug":"webpack4/（三）覆盖默认entry和output","date":"2019-05-23T13:01:59.000Z","updated":"2019-06-01T12:39:16.939Z","comments":true,"path":"2019/05/23/webpack4/（三）覆盖默认entry和output/","link":"","permalink":"http://yoursite.com/2019/05/23/webpack4/（三）覆盖默认entry和output/","excerpt":"","text":"demo3 源码地址 1.检验 webpack 规范支持webpack 支持 ES6，CommonJS，AMD 规范创建 wendor 文件夹，其中 minus.js,multi.js 和 sum.js 分别用 CommonJS，AMD，ES6 规范编写 1234567891011121314151617// CommonJS minus.jsmodule.exports = function(a, b) &#123; return a - b;&#125;;// AMD multi.jsdefine([\"require\", \"dependency\"], function(require, factory) &#123; \"use strict\"; return function(a, b) &#123; return a * b; &#125;;&#125;);// ES6 sum.jsexport default function(a, b) &#123; return a + b;&#125; 在 index.js 中引入以上三个文件 2.编写配置文件覆盖 entry/outputwebpack.config.js 是 webpack 默认配置的文件名，在根目录下创建： 1234567891011let path = require(\"path\");module.exports = &#123; entry: \"./src/index.js\", // 入口文件 output: &#123; path: path.resolve(__dirname, \"dist\"), // __dirname 是指webpack.config.js的绝对路径 dist 是指出口的目录 filename: \"bundle.js\", // 打包输出的文件夹的文件名 publicPath: __dirname + \"/dist/\" // 打包后的文件夹 &#125;, module: &#123;&#125;, plugins: []&#125;; path.resolve() 方法会把一个路径或者是路径片段的序列解析为一个绝对路径__dirname：当前模板的文件夹名称。 可以使用 console.log 输出下就明白了执行 npm run build 打包 js 文件会发现生成了 dist 文件，并且生成了两个打包后的文件 这跟 AMD 的引入方式有关，如果在 app.js 中注释掉 AMD 的写法，则只会打包出一个 bundle.js 文件 在实际写代码的时候，最好使用 ES6 和 CommonJS 的规范来写 当你注释 AMD 后，打包后的 dist 中有多个文件，这是因为打包的时候没有先删除掉 dist 文件，在打包，我们需要使用一个插件来帮助我们实现：github 链接：clear-webpack-plugin1.安装插件npm install clean-webpack-plugin –save-dev2.修改 webpack 配置文件 1234567891011121314let path = require(\"path\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");module.exports = &#123; entry: \"./src/index.js\", // 入口文件 output: &#123; path: path.resolve(__dirname, \"dist\"), // __dirname 是指webpack.config.js的绝对路径 bundle 是指出口的文件名 filename: \"bundle.js\", // 打包输出的文件夹的文件名 publicPath: __dirname + \"/dist/\" // 打包后的文件夹 &#125;, module: &#123;&#125;, plugins: [ new CleanWebpackPlugin() // 默认情况下，此插件将删除 webpack output.path中所有的文件，以及每次重建后所有未使用的webpack的产品。 ]&#125;; 之后在执行 npm run build 就可以了 打包后的 js 文件会按照我们的配置放在 dist 目录下，创建一个 html 文件，引用打包好的 js 文件，打卡 F12 就能看到效果了。 参考文献 webpack4 系列教程 (一): 打包 JSWebpack4 教程：从零配置到生产模式","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（二）生产和开发模式","slug":"webpack4/（二）生产和开发模式","date":"2019-05-22T13:01:59.000Z","updated":"2019-06-01T12:39:20.459Z","comments":true,"path":"2019/05/22/webpack4/（二）生产和开发模式/","link":"","permalink":"http://yoursite.com/2019/05/22/webpack4/（二）生产和开发模式/","excerpt":"","text":"demo2 源码记录拥有 2 个配置文件在 webpack 中是常见的模式。一个典型的项目可能有： 用于开发的配置文件，配置热更新，跨域配置，端口设置等。 用于生产的配置文件，配置 js 压缩，代码拆分等。 虽然在较大的项目可能任然需要 2 个配置文件，但是在 webpack4.0 中，你可以在没有一行配置的情况下完成。 细心的朋友会发现在 npm run build 打包后会有一段报警提示‘mode’选项尚未设置，webpack 将会退到‘production’。将‘mode’选项设置为‘development’或者‘production’以启用每个环境的默认值。你还可以将其设置为‘none’以禁止任何默认行为。 1.打开 package.json 并填充 script 部分，如下所示： 12\"dev\": \"webpack --mode development\",\"build\": \"webpack --mode production\", 2.运行 npm run dev 打开./build/bundle.js，是一个 bundle（包）文件，并没有压缩！ 3.运行 npm run build可以看到./build/bundle.js 文件已经压缩了 其实在终端里面发现，看构建完的大小，dev 模式下文件大小是 3.81KB,build 模式下文件大小仅为 966 字节 production mode（生成模式）可以开箱即用地进行各种优化。包括压缩，作用域提升，tree-shaking 等。另一方面，development mode(开发模式）针对速度进行了优化，仅仅提供了一种不压缩的 bundle。 在 webpack4.0 中,可以在没有一行配置的情况下完成任务！只需定义-mode 的参数即可获得所有内容！","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（四）拆分组件与组件之前的传值","slug":"react/（四）拆分组件与组件之前的传值","date":"2019-05-22T12:01:59.000Z","updated":"2019-06-01T13:53:52.331Z","comments":true,"path":"2019/05/22/react/（四）拆分组件与组件之前的传值/","link":"","permalink":"http://yoursite.com/2019/05/22/react/（四）拆分组件与组件之前的传值/","excerpt":"","text":"1.react组件拆分的重要性模块化，组件化，提高性能，方便维护。 2.父组件给子组件传递数据1234567// 通过属性的方式进行传递//1.父组件定义属性&lt;div&gt; &lt;TodoItem info=&#123;item&#125;/&gt; &lt;/div&gt;//2.子组件通过this.props.属性 的方式接受属性 &lt;div onClick=&#123;this.handClick&#125;&gt;&#123;this.props.info&#125;&lt;/div&gt; 3.子组件调用父组件的方法传递数据1234567891011// 父组件 &lt;div&gt; &lt;TodoItem info=&#123;item&#125; index=&#123;index&#125; deleteItem=&#123;this.handItemDelete.bind(this)&#125;/&gt; // 父组件必须绑定this&lt;/div&gt;// 子组件 handClick()&#123; this.props.deleteItem(this.props.index) &#125; 4.优化方式 代码的优化 123456789101112131415const &#123;info&#125; = this.propsreturn(&lt;div onClick=&#123;this.handClick&#125;&gt;&#123;info&#125;&lt;/div&gt;)// 等价于return(&lt;div onClick=&#123;this.handClick&#125;&gt;&#123;this.props.info&#125;&lt;/div&gt;) const &#123;deleteItem,index&#125; = this.props deleteItem(index) // 等价于 this.props.deleteItem(this.props.index) 一般引入方式的优化 style.css样式是在组件之后引入的 .bind(this)的绑定一般放在顶部 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import React,&#123;Component,Fragment &#125; from 'react';import TodoItem from './TodoItem';import './style.css';class TodoList extends Component&#123; constructor(props) &#123; super(props); //负责存储组件里面的数据 this.state = &#123; inputValue: '', list: ['学习英文', '学习中文'] &#125; this.handleInputChange = this.handleInputChange.bind(this) this.handBtnClick = this.handBtnClick.bind(this) this.handItemDelete = this.handItemDelete.bind(this) &#125; render() &#123; return( &lt;Fragment&gt; &lt;div&gt; &#123; //下面是一个输入框 &#125; &lt;label htmlFor=\"insertArea\"&gt;输入内容&lt;/label&gt; &lt;input id=\"insertArea\" className='input' value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;button onClick=&#123;this.handBtnClick&#125;&gt; 按钮 &lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item,index) =&gt; &#123; return ( &lt;div&gt; &lt;TodoItem info=&#123;item&#125; index=&#123;index&#125; deleteItem=&#123;this.handItemDelete&#125;/&gt; &#123;/* &lt;li key=&#123;index&#125; onClick=&#123;this.handItemDelete.bind(this,index)&#125; // dangerouslySetInnerHTML=&#123;&#123; __html: item &#125;&#125; &gt; &#123;item&#125; &lt;/li&gt;*/&#125; &lt;/div&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; handleInputChange(event) &#123; // event.persist(); // console.log(this);// 打印this指向 this.setState (&#123; // react中修改数据项的值要使用setState inputValue: event.target.value &#125;) &#125; handBtnClick() &#123; this.setState (&#123; list: [...this.state.list,this.state.inputValue], inputValue: '' &#125;) &#125; handItemDelete(index) &#123; // immutable // state不允许我们做任何的改变 const list = [...this.state.list]; list.splice(index, 1); this.setState(&#123; list: list &#125;) &#125;&#125;export default TodoList; setState的最新语法写法 123456789101112handleInputChange(event) &#123; // event.persist(); this.setState (&#123; // react中修改数据项的值要使用setState inputValue: event.target.value &#125;)&#125;// 最新写法this.setState(()=&gt;&#123; return&#123; inputValue: event.target.value &#125;&#125;) 结构赋值的简写形式 123this.setState(() =&gt; (&#123; list //等价于list:list是es6的简写形式&#125;))","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"（一）搭建项目并打包JS文件","slug":"webpack4/（一）搭建项目并打包JS文件","date":"2019-05-21T13:01:59.000Z","updated":"2019-06-01T12:39:12.011Z","comments":true,"path":"2019/05/21/webpack4/（一）搭建项目并打包JS文件/","link":"","permalink":"http://yoursite.com/2019/05/21/webpack4/（一）搭建项目并打包JS文件/","excerpt":"","text":"依赖环境：os:win10node:10.5.0npm:6.1.0webpack:4.29.6webpack-cli:3.2.4每个知识点对应一个 demo，clone 源码后运行 npm install 安装依赖 1.搭建项目并且打包 js 文件demo1 源码地址创建空文件夹，通过运行一下命令进行初始化 package.json:npm init npm int 用来初始化生成一个新的 package.json 文件。他会向用户提一系列问题，如果不觉得不需要修改默认配 置，一路回车就可以了。如果使用了-y（代表 yes），则跳过了提问阶段，直接生成一个新的 package.json 文 件。引入 webpacknpm i webpack –save-dev还需要 webpack-cli，作为一个单独的包引入，如果不装 webpack-cli 是无法在命令行里面使用 webpack 的npm i webpack-cli –save-dev该项目 webpack 的版本如下： 12\"webpack\": \"^4.32.0\",\"webpack-cli\": \"^3.3.2\" 现在打开 package.json 并且添加一个 build（构建）脚本： 尝试运行看看会发生什么：npm run build 在 webpack4.0 版本中，必须在名为 webpack.config.js 的配置文件中，通过 entry 属性定义 entry point（入口点），就行这样： 从 webpack4.0 开始，就不必在在定义 entry point（入口点）：它默认为./src/index.js测试这个功能前，首先创建.src/index.js 文件 在次运行 npm run build 试试： 打包成功，并且在当前的根目录中得到打包后的文件夹，也就是 build 文件夹： 讲查找./src/index.js 作为默认入口点。而且，他会在./build/bundle.js 中输出模块包，目前代码量小，可以格式化看看效果：至此，打包 js 结束参考：webpack 官网入门","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（三）react的jsx语法理解","slug":"react/（三）react的jsx语法理解","date":"2019-05-20T12:01:59.000Z","updated":"2019-06-01T13:54:28.204Z","comments":true,"path":"2019/05/20/react/（三）react的jsx语法理解/","link":"","permalink":"http://yoursite.com/2019/05/20/react/（三）react的jsx语法理解/","excerpt":"","text":"1.jsx语法怎么添加注释1234567// render函数里面的代码就是jsx语法// 大写字母开头的标签就是组件，其他的标签都是元素&lt;Fragment&gt;&lt;/Fragment&gt; // 单行注释的写法&#123;//注释内容&#125;// 多行注释的写法&#123;/*注释内容*/&#125; 2.react的class命名注意点 在react中class是类的概念所以在react中class的写法要改成className。3.dangerouslySetInnerHTML理解dangerouslySetInnerHTMl 是React标签的一个属性，类似于angular的ng-bind3.既可以插入DOM，又可以插入字符串；4.label标签的用法扩大聚焦的一个范围，例如：点击label标签文字会聚焦到input标签 1234567891011121314// input定义一个id名 label的htmlfor属性对应到该id名&lt;div&gt; &#123; //下面是一个输入框 &#125; &lt;label htmlFor=\"insertArea\"&gt;输入内容&lt;/label&gt; &lt;input id=\"insertArea\" className='input' value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; /&gt; &lt;button onClick=&#123;this.handBtnClick.bind(this)&#125;&gt;按钮&lt;/button&gt;&lt;/div&gt;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"（二）响应设计思想与事件绑定","slug":"react/（二）响应设计思想与事件绑定","date":"2019-05-18T12:01:59.000Z","updated":"2019-06-01T13:54:35.731Z","comments":true,"path":"2019/05/18/react/（二）响应设计思想与事件绑定/","link":"","permalink":"http://yoursite.com/2019/05/18/react/（二）响应设计思想与事件绑定/","excerpt":"","text":"1.react的新建组件12345678important React from 'react'class App extends React.Components&#123; //新建一个react组件 render()&#123; return( &lt;div&gt;hello&lt;/div&gt; ) &#125;&#125; 2.react的jsx语法 3.Fragment：在react的最外层包一个div隐藏掉的方法。1234567891011121314151617181920import React,&#123;Component,Fragment &#125; from 'react';class TodoList extends Component&#123; render() &#123; return( &lt;Fragment className=\"TodoList\"&gt; &lt;div&gt; &lt;input/&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;学英语&lt;/li&gt; &lt;li&gt;learn React&lt;/li&gt; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125;&#125;export default TodoList; 4.react的响应设计思想与事件绑定思路;操作的是数据层不是Dom操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React,&#123;Component,Fragment &#125; from 'react';class TodoList extends Component&#123; constructor(props) &#123; super(props); //负责存储组件里面的数据 this.state = &#123; inputValue: '', list: ['学习英文', '学习中文'] &#125; &#125; render() &#123; return( &lt;Fragment&gt; &lt;div&gt; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; /&gt; &lt;button onClick=&#123;this.handBtnClick.bind(this)&#125;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item,index) =&gt; &#123; return ( &lt;li key=&#123;index&#125; onClick=&#123;this.handItemDelete.bind(this,index)&#125; &gt; &#123;item&#125; &lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; handleInputChange(event) &#123; // event.persist(); // console.log(this);// 打印this指向 this.setState (&#123; // react中修改数据项的值要使用setState inputValue: event.target.value &#125;) &#125; handBtnClick() &#123; this.setState (&#123; list: [...this.state.list,this.state.inputValue], inputValue: '' &#125;) &#125; handItemDelete(index) &#123; // immutable // state不允许我们做任何的改变 const list = [...this.state.list]; list.splice(index, 1); this.setState(&#123; list: list &#125;) &#125;&#125;export default TodoList;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"（一）react开发目录介绍","slug":"react/（一）react开发目录介绍","date":"2019-05-17T13:01:59.000Z","updated":"2019-06-01T13:54:23.769Z","comments":true,"path":"2019/05/17/react/（一）react开发目录介绍/","link":"","permalink":"http://yoursite.com/2019/05/17/react/（一）react开发目录介绍/","excerpt":"","text":"demo 源码地址 react 简介React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在 2013 年 5 月开源了。由于 React 的设计思想极其独特，属于革命性创新，性能出众，代码逻辑却非常简单。所以，越来越多的人开始关注和使用，认为它可能是将来 Web 开发的主流工具。ReactJS 官网地址：http://facebook.github.io/react/Github 地址：https://github.com/facebook/react。 React 特点 1.声明式设计 −React 采用声明范式，可以轻松描述应用。 2.高效 −React 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互。 3.灵活 −React 可以与已知的库或框架很好地配合。 4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。 5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。 6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 脚手架工具安装与运行下载 node 安装包查看 npm 安装包react 全局安装的脚手架工具：npm install -g create-react-app初始化一个项目：create-react-app projectName成功后的提示然后 cd 项目目录yarn start 项目启动成功 react 项目目录认识1234567891011121314151617#项目结构├── node_modules 包含了react下的组件 项目启动页面，react比较适合单页开发，所以暂时只包含一个index.html，是react的入口页面│ ├────favicon.ico 图片│ ├────index.html 项目入口│ └────manifest.json 5+移动App的配置 app的快捷方式的图片和网址的定义├─- src 开发目录│ ├───—App.css 组件的css│ ├───—App.js 负责页面显示内容│ ├───—App.test.js 自动化的测试的文件│ ├───—index.js 整个程序的入口文件│ ├───—logo.svg 图片│ └────serviceWorker.js├── .gitignore git那些文件不需要添加到版本管理├── package.json 项目所需要的各种模块，配置信息├── yarn.lock 项目依赖安装包的版本号md 项目的说明文件，使用markdown的语法。 index.js 文件的基本理解123456789import React from \"react\";import ReactDOM from \"react-dom\";import App from \"./App\"; //APP来自APP.js文件// registerServiceWorker 是指将网页打开运行一半时，将网页关闭。可以将网页保存在浏览器内。再次打开可以继续访问。import * as serviceWorker from \"./serviceWorker\"; //借助网页写手机app的效果// PWA progressive web applicationReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\"));serviceWorker.unregister(); App.js 文件的基本理解1234567891011121314import React, &#123; Component &#125; from \"react\";// import './App.css';class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt;hello person&lt;/header&gt; &lt;/div&gt; ); &#125;&#125;export default App;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"JYSHT-跳转同一页面判断","slug":"vue/JYSHT-跳转同一页面判断","date":"2018-07-15T13:50:59.000Z","updated":"2019-06-01T13:34:53.754Z","comments":true,"path":"2018/07/15/vue/JYSHT-跳转同一页面判断/","link":"","permalink":"http://yoursite.com/2018/07/15/vue/JYSHT-跳转同一页面判断/","excerpt":"","text":"例如：交易所后端的法币增值税，跳转到新增和修改页面。但是新增和修改同为一个页面的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445461.可以通过路由的一个type来判断&#123; path: '/exchange/new', component: ExchangeNew, name:'ExchangeNew_f', props: &#123; type: 'new'//type判断是新增还是修改 &#125;, hidden: true,&#125;,&#123; path: '/exchange/edit/:id', component: ExchangeNew, name:'ExchangeEdit_f', props: &#123; type: 'edit' &#125;, hidden: true,&#125;2.在既是新增又是修改的页面定义prop接受router下的propprops: &#123; type: String&#125;,3.页面文字显示不同的定义 &lt;el-breadcrumb-item &gt;&#123;&#123;type === 'edit' ? '修改' : '新增'&#125;&#125;&lt;/el-breadcrumb-item&gt;提交接口根据页面自动调用对应的接口 handleSubmit()&#123; //是新增接口 exchangeNew 修改接口exchangeUpdate let exce = this.type === 'new' ? api.exchangeNew : api.exchangeUpdate exce(this.form).then(res =&gt; &#123; console.log(res); if(res.status.code===0)&#123; this.$message.success(&#123; showClose: true, message: '提交成功', duration: 2000 &#125;); &#125;else&#123; this.$message.error(&#123; showClose: true, message: res.status.msg, duration: 2000 &#125;); &#125; &#125;)&#125;,","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"难点(1)-面向对象","slug":"php基础/难点(1)-面向对象","date":"2018-06-08T15:34:40.000Z","updated":"2019-06-09T07:01:38.303Z","comments":true,"path":"2018/06/08/php基础/难点(1)-面向对象/","link":"","permalink":"http://yoursite.com/2018/06/08/php基础/难点(1)-面向对象/","excerpt":"","text":"1.mysql 补充12345678//1.mysql导出mysqldump --no-defaults -uroot -p789 yzmedu&gt;yzmedu.sql;//2.mysql导入mysqldump --no-defaults -uroot(数据库名) -p123(密码) -B yzmedu --skip-add-locks --compact &gt;yzmedu.sql//2.php客户端软件mysql workbenchphpmyadmin//3.doc下mysql恢复 mysql -uroot -p123 &lt; yzmedu.sql 2.面向对象知识点 概念：OOP(object oriented program)面向对象，代码更加简洁，灵活，易于维护。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113https://blog.csdn.net/wang544831183/article/details/77322569//在程序领域中，先是人类后是人，和现实生活中正好是相反的。1.人类2.人//人的组成部分:1.特征2.行为//类的组成1.属性(特征)(变量)2.方法(行为)(方法)//一.面向对象//1.什么是类类是一个独立的程序单位，是具有相同属性和方法的一组对象的集合。为对象提供了统一的抽象描述，起内部成员包括属性和方法。//2.什么是对象客体时间中，所有的事务都是由对象与对象之间的系统组成。对象是系统中用来描述客观事物的客体，是构成系统的一个基本单位。从类中拿到具体属性值的个体，成为对象//3.类与对象关系：类实例化对象，或类诞生对象，或类生产对象。类实例化结果就是对象，而对象的抽象就是类。类描述了一组具有相同属性与方法的对象。类是对象的抽象化，对象是类的具体化。//4.面向对象概念：都有类的概念，通过类可以任意创建具有相同属性与方法的对象。//二.类声明与实例化：//1.声明一个类class 类名&#123; 访问修饰符 $属性=默认值； [访问修饰符] function 方法()&#123;&#125;&#125;类名必须有class修饰，类名后面不能有()属性必须带访问修饰符，方法可以不用带访问修饰符//2.实例化对象及其属性方法实例化：$对象名= new 类名()类外部获取属性方法:$对象名-&gt;属性名类内部获取属性方法:$this-&gt;属性名 $this作用：永远代表着本对象//三.构造函数与析构函数//1.构造函数作用：_construct实例化对象时自动调用用于给对象的属性赋初始值。构造函数可以接受参数，能够在创建对象时赋值给对象。//2.构造函数写法 构造函数名必须与类名同名[public] function Person($name)&#123;$this-&gt;name=$name;&#125;[public] function _construct($name)&#123;$this-&gt;name=$name;&#125;//4.析构函数：_destruct对象在销毁之前自动调用，用于释放资源关闭资源析构函数不能带有任何参数public function _destruct()&#123; echo \"&lt;p&gt;&#123;$this-&gt;name&#125;销毁啦&lt;/p&gt;\";&#125;//四.访问修饰词类型1.public：公共的(公共修饰符)类的内部与外部都能访问2.private：私有的(私有的修饰符)只能在类的内部访问3.protected：受保护的(受保护的修饰符)子类可以访问，类的外部不能访问//五.创建类例如：//定义一个Person类class Person&#123; //特征 public $name=\"狗蛋\"; //行为 public function say()&#123; echo \"我叫狗蛋\"; &#125;&#125;//从Person类中实例化出人这个对象，这个人有名字会说话$people=new Person();print_r($people);echo \"&lt;br&gt;\";//对象属性的获取以-&gt;的形式echo $people-&gt;name,$people-&gt;say();//面向对象特点：封装，继承，多态//对象方法中去访问当前的属性 public function say()&#123; echo \"&lt;p&gt;my name is &#123;$this-&gt;name&#125;&lt;/p&gt;\";&#125;//六.对象链$obg-&gt;find()-&gt;attr()-&gt;parent()-&gt;css()例子：class Person&#123; public function find()&#123; echo \"&lt;p&gt;我是find方法&lt;/p&gt;\"; return $this; &#125; public function attr()&#123; echo \"&lt;p&gt;我是attr方法&lt;/p&gt;\"; return $this; &#125; public function css()&#123; echo \"&lt;p&gt;我是css方法&lt;/p&gt;\"; return $this; &#125; public function parent()&#123; echo \"&lt;p&gt;我是parent方法&lt;/p&gt;\"; return $this; &#125;&#125;$obj=new Person();echo $obj-&gt;find()-&gt;attr()-&gt;css()-&gt;parent()-&gt;find();//七.属性的作用域1.类外变量不能作用到类内。2.类中属性可以作用到类方法。3.类中变量不能作用到类方法中。 继承：extends 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//1.继承的特性：子承父业 属性和方法都是可以继承的语法:class 子类 extends 父类&#123;//子类的属性方法&#125;//2.parent关键字 注意：对象的属性是-&gt;，类里面的属性是:: parent::__construct($n,$a);//3.继承的作用:提高重用性，拓展性，灵活性。---//例如：class Person&#123; public $name; public function __construct($n) &#123; $this-&gt;name=$n; &#125; public function say()&#123; echo \"my name is &#123;$this-&gt;name&#125;\"; &#125; public function eat()&#123; echo \"&#123;$this-&gt;name&#125;正在吃饭\"; &#125; public function sleep()&#123; echo \"&#123;$this-&gt;name&#125;正在睡觉\"; &#125;&#125;class chengXuYuan extends Person &#123;//extends public $name; public function __construct($n)//此处必须把父类要传的参数写入，否则会报错 &#123; parent::__construct($n);//parent::子类继承父类的方法用parent:: &#125;&#125;$javaPerson=new chengXuYuan('java开发人员');echo $javaPerson-&gt;say();//继承的注意事项：1.子类只能继承父类的非私有属性2.子类继承父类后，相当于将父类的属性和方法copy一份到子类，可以直接使用$this调用属性3.php只能支持单继承，不支持一个类继承多个类。4.parent::__construct()；就是执行父类的构造方法原因：因为子类中的构造方法会覆盖父类中的构造方法导致父类的构造方法不能自动执行，所以在子类中的构造方法中手动执行父类的构造方法//继承的特性:1.灵活性2.重用性3.拓展性 1234567891011121314153. &lt;span data-type=&quot;color&quot; style=&quot;color:#003A8C&quot;&gt;封装&lt;/span&gt; 1. ```php //访问修饰词 1.public:公开 2.p rotected：被保护的 外界不能访问 只能子类继承访问 3.private：私有的 //类的封装级别 子类的修饰词权限&lt;=父类同名方法前的修饰词 //类封装的作用 1.部分方法对外开放 2.部分方法要对外封锁 //类继承的特征 1.灵活性：带有权限控制 2.拓展性 ：带有权限性的拓展 实例：分页类 实例：数据操作类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//数据库增加$conn=mysqli_connct('localhost:3306','root','luoling1996810','test1');//test1是指数据库名$sql=\"insert into user(username,age,class_id) values('user6','34','2')\";$rst=mysqli_query($conn,$sql);if($rst)&#123; echo \"插入数据成功\";&#125;else&#123; echo \"插入数据失败\";&#125;//数据库删除$sql=\"delete from user where username='user6'\";$deleteOk=mysqli_query($conn,$sql);if($deleteOk)&#123; echo \"删除成功\";&#125; else&#123; echo \"删除失败\":&#125;//数据库修改$sql2=\"update user set age=55 where id=5\";$updataOk=mysqli_query($conn,$sql2);if($updataOk)&#123; echo \"数据更新成功\";&#125;else&#123; echo \"数据更新失败\";&#125;//数据库查询 练习 没写出来//(一)查询//mysqli_connect()建立数据库连接 $con=mysqli_connect('localhost:3306','root','luoling1996810'); if(!$con)&#123; die('数据库连接不上'); &#125; //mysqli_select_db()连接数据库$conmysql=mysqli_select_db($con,'test1');//mysqli_query()执行一条数据库查询//$insertsql=\"insert into user(username,age,class_id) values('usernew','34','2')\";$selectsql=\"select * from user\";$result=mysqli_query($con,$selectsql);if($result)&#123; echo \"数据查询成功\";&#125;else&#123; echo \"数据查询失败\";&#125;//mysqli_fetch_array()函数从结果集中取一行作为关联数组while($row=mysqli_fetch_array($result))&#123;echo \"&lt;pre&gt;\";print_r($row);echo \"&lt;/pre&gt;\";&#125;查询所有数据M('user')-&gt;select();M('user')-&gt;find();M('user')-&gt;find(5);//二.数据库操作类//1.查询名叫user的这个数据库M('user')-&gt;select();//首先在function.inc.php中function M($className)&#123; return new Model($className);&#125;//在module.class.php中class Model&#123; public $table; public function __construct($t)&#123; $this-&gt;table=$t; &#125; public function select()&#123; $con=mysqli_connect('localhost:3306','root','luoling1996810'); mysqli_select_db('test1'); $sql='select * from &#123;$this-&gt;table&#125;' $rst=mysqli_query($con,$sql); while($row=mysqli_fetch_array($rst)&#123; $rows[]=$row; &#125; return $rows; &#125;&#125;//在index.php引用include 'common/module.class.php';include 'common/function.inc.php';$rst=M('user')-&gt;select();echo \"&lt;pre&gt;\";var_dump($rst);echo \"&lt;/pre&gt;\";//2.查询指定的一条数据 123456789106. &lt;span data-type=&quot;color&quot; style=&quot;color:#003A8C&quot;&gt;抽象类：含有抽象方法的类就是抽象类，抽象类中必须要有抽象方法，但也可以由非抽象方法。&lt;/span&gt; 1. ```php //abstract修饰符修饰的类表示这是一个抽象类。用abstract修饰的方法表示这个方法是抽象方法。抽象类不能实例化 //声明一个Usb抽象类 abstract class Usb &#123; //unload()抽象方法 抽象方法是指未完成的方法 abstract public function unload(); &#125; 接口 interface 12345678910111213141516171819202122232425262728//接口：是指只含有抽象方法的类interface Jk//凡是接口里面都是抽象方法的，抽象方法不用加abstract否则会报错&#123; public function load(); public function start();&#125;interface Run&#123; public function run();&#125;//接口子类 在子类中是可以继承多个父类class JieNext implements Jk,Run&#123; public function load() &#123; // TODO: Implement load() method. echo \"&lt;p&gt;Jiekou is loading&lt;/p&gt;\"; &#125; public function start() &#123; // TODO: Implement start() method. echo \"&lt;p&gt;Jiekou is start&lt;/p&gt;\"; &#125; public function run() &#123; echo \"&lt;p&gt;I am run&lt;/p&gt;\"; &#125;&#125; 多态 1//多态是指多种形态 魔术方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//常见的魔法方法：1.__construct:构造方法 对象创建的时候调用的方法2.__destruct：析构方法 对象消失的时候创建的方法3.__toString：是指对象说明 public function __toString() &#123; // TODO: Implement __toString() method. echo \"this is a Object\"; &#125;4.__call：访问一个不存在的对象时调用 //call方法 第一个参数：是指对象名 第二个参数：是指对象传入的参数 public function __call($i, $j) &#123; // TODO: Implement __call() method. echo \"你访问的方法不存在\"; echo $i; echo \"&lt;pre&gt;\"; var_dump($j); echo \"&lt;/pre&gt;\"; &#125;//打印一个不存在的对象echo $obj-&gt;end(10,20,30);5.__get：是指访问没有权限的属性时调用 //__get() class Person &#123; private $name='user1'; public function load()&#123; echo \"&lt;p&gt;我是load&lt;/p&gt;\"; &#125; public function __get($i) &#123; // TODO: Implement __get() method. echo \"&lt;p&gt;你无法访问&#123;$i&#125;属性&lt;/p&gt;\"; &#125; &#125; $useGet=new Person(); echo $useGet-&gt;name; 访问的name是一个私有属性无权访问6.__set：是指设置没有权限的属性时调用 class Person &#123; private $name='user1'; public function load()&#123; echo \"&lt;p&gt;我是load&lt;/p&gt;\"; &#125; //__get() public function __get($i) &#123; // TODO: Implement __get() method. echo \"&lt;p&gt;你无法访问&#123;$i&#125;属性&lt;/p&gt;\"; &#125; //__set() public function __set($i, $j) &#123; // TODO: Implement __set() method. echo \"&lt;p&gt;你无权设置&#123;$i&#125;为&#123;$j&#125;&lt;/p&gt;\"; &#125; &#125; $useGet=new Person(); echo $useGet-&gt;age='22';7.__isset：无权访问的时候调用该方法8.__unset：无权删除属性的时候调用该方法 关键字 123456789101112131415161718//1.const :可以修饰属性1.声明const 属性名='属性值2.打印 echo Person::score;&#123; public $name; const score = 50; public function __construct($n) &#123; $this-&gt;name = $n; &#125; public function say() &#123; echo \"&lt;p&gt;my name is &#123;$this-&gt;name&#125;&lt;/p&gt;\"; &#125;&#125;echo Person::score; //2.final :可以修饰类和方法 是指最终版本 不能被继承final class Person{ public $name; const score = 50; public function __construct($n) { $this-&gt;name = $n; } public function say() { echo &quot;&lt;p&gt;my name is {$this-&gt;name}&lt;/p&gt;&quot;; }} //3.static：可以修饰属性和方法 它的意思是方法的体内没有$this你依托与对象可以直接单刀直入使用 static public function sum($i,$j){ return $i+$j; } echo Person::sum(5,30); 123456789101112131415161718192021222324252627282930313211. &lt;span data-type=&quot;color&quot; style=&quot;color:#003A8C&quot;&gt;命名空间&lt;/span&gt; 1. ```php //1.namespace Tink\\admin不是路径只是简单的一个命名 //解决的问题： 1.引入n多个项目文件的时候类名相冲突的问题 2.解决同一个php脚本中同名函数，同名类，同名常量的问题。 //实例： namespace admin; //类 class Model &#123; public function show() &#123; echo &quot;&lt;p&gt;我是命名空间admin的show方法&lt;/p&gt;&quot;; &#125; &#125; //函数 function say() &#123; echo &quot;&lt;p&gt;我是命名空间admin的say函数方法&lt;/p&gt;&quot;; &#125; //常量 define()声明常量但是在5.3之后就可以使用const声明常量 并且可以在类的外部声明常量 const HOST = &apos;admin/host&apos;; include &apos;admin/Model.class.php&apos;; $obj2 = new \\admin\\Model(); echo $obj2-&gt;show(); \\admin\\say(); echo \\admin\\HOST; php 中文件引入：include 123456789101112131415//Person.class.php&lt;?php class Person&#123; public $name; public function say()&#123; echo \"I am say\"; &#125; &#125;?&gt;//index.php&lt;?php include 'Person.class.php'; $obj1=new Person(); echo $obj1-&gt;say(); ?&gt;","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"数据库(2)-优化","slug":"php基础/数据库(2)-优化","date":"2018-06-04T15:30:40.000Z","updated":"2019-06-09T07:01:29.726Z","comments":true,"path":"2018/06/04/php基础/数据库(2)-优化/","link":"","permalink":"http://yoursite.com/2018/06/04/php基础/数据库(2)-优化/","excerpt":"","text":"1.mysql 基础操作 mysql 表复制 1create table （表名） like （表名）; // mysql 复制表内容 1insert into t3 select * from t1;//将t1表里面的内容插入到t3表里面 查看数据库的状态 mysql 索引查看，删除，创建 12345678910//查看索引show index from 表名\\G;//普通索引 创建 删除create index i_age on user(age);//user是指表drop index i_age on user;//唯一索引 创建 删除create unique index u_username on user(username );//user表格中username 创建uniquedrop index u_username on user;//主键索引 创建 删除alter table user modify id int unsigned primary key; mysql 视图 12345678//视图添加create view userclass as select user.username,user.age,class.name from user,class where user.class_id=class.id;//删除视图drop view userclass;//多表查询select user.username,user.age,class.name from user,class where user.class_id=class.id;//查看视图数据select * from userclass 查看 2.数据库函数 字符串函数 12345678910CONCAT(string2,[...]);//连接字符LCASE(string2)；//转换成小写 select lcase('PHP IS VERY MUCH');UCASE（string2）；//转换成大写 select ucase('php is very much');LENGTH(string2)；//string长度 select length('linux');LIRIM（string2);//去除左端空格 select ltrim(' linux');RTRIM(string2);//去除右边空格 select length(rtrim('linux '));REPEAT(string2);//重复count次数 select repeat('-',20);REPLACE(str,search_str,replcae_str);//在str中国用replace_str替换 select replace('linux nad java','linux','php');SUBSTRING(str,position,[length]);//position开始取length个字符 字符串截取 select substring('/user/local/src',5,5);SPACE();//空格 select concat('linux',space(20),'php'); 数学函数 1234567bin();//把某个数字转换成2进制 例：select bin(10);ceiling();//取上一个整数 select ceiling(10.5);floor();//取下一个整数 select floor(10.5);max();//取最大整数 select max(id) from user;必须是一列一面的最大整数min();//取最小值 select min(id) from user;sqrt();//开平方 select sqrt(100);rand();//随机值 日期函数 12345678curdate();//当前的年月日 select curdate();curtime();//当前的时分秒 select curtime();now();//当前日期和时间 selct now();unix_timestamp();//当前时间戳 select unix_timestamp();from_unixtime();//时间戳转时间 select from_unixtime(1528078872);week(date);//一年里面的第几周 select week('201-2-14');year(date);//里面里面的年的部分 select year('201-2-14');datediff();//日期差值 select datediff('2017-4-14'); 123456789104. &lt;span data-type=&quot;color&quot; style=&quot;color:#003A8C&quot;&gt;重排 auto_increment()&lt;/span&gt; 1. ```php delete();//删掉数据 1.delete from user(); 2.alter table user auto_increment=1; truncate(); 1.truncate test； //? sh% //更多以sh开头的方法 3.常见 sql 技巧与问题 巧用 rand()提取随机数 select * from stu order by rand() musql 中 help 使用： ？ show ? sh% 12345678910111213//1.mysql语句优化的一般步骤：//1.定位执行效率较低的sql语句desc select * from table where id=1000;explain select * from table where id=1000;//2.一共操作的次数show status; //show[session|global]status; session:表示当前的连接show global status;// global：表示自数据库启动至今//3.'%Com_delete%' '%Com_insert%' '%Com_select%' '%Com_update%'show status like '%Com_delete%';//检查服务器增，删，改，查的使用频次（本次连接以来）show global status like '%Com_%';//本次服务器启动以来//2.mysql索引优化//3.check和option的使用方法//4.常用mysql优化 3.查看 mysql 的慢查询 1234567891011121314//1.查看慢查询的日志是否开启show variables like \"%quer%\"; //打印: slow_query_log | OFF//2.查看慢查询的次数show status like \"%quer%\";//3.显示表的行数select count(*) from 表名;//4.修改慢查询的时间: long_query_time=6//复制表格create table test like user;//复制一份user表给test//重启mysql服务器net stop mysqlnet start mysql//复制表格内容insert into test select * from user;//复制一份user表给test 4.优化表空间 check 与 optimize 12345//索引是数据库优化中最常见也是最重要的手段之一，通过mysql索引通常可以帮助用户解决大多数sql问题//删除了表格数据大小还存在的 优化空间的方法:1.optimize table 表名;注意：在myisam表是没有问题的，但是在innodb表和ibdata1文件无法回收空间。2.check table 表名;//检查表格 5.索引存储空间的分类 123456789101112131415161718192021221.myisam1)frm 表结构2）myd 表数据3）myi 表索引2.innodb1）frm 表结构2)idb 索引+部分表数据3)ibdata1 所有表共享的空间//简单普通的多表查询select user.username,class.name from user,class where user.class_id=class.id;//创建视图create view v_user as select user.username,class.name from user,class where user.class_id=class.id;//删除视图的莫一项 delete from user where username=\"user9\";//其中company表名ind_company2——name索引名 create index ind_company2_name on company2(name(4));//mysql中使用索引create index i_uername on user(username);//使用like的查询，后面如果是常量并且只有%号不在第一个字符，索引才可能会被使用 %在前可能会导致索引失效explain select * from company2 where name like \"%3\"\\G;//是指名字以3结尾//null 判断desc select * from user where username is null; 3.root 密码丢失1234//1.密码没有忘，但是要改密码set password=password(&quot;123&quot;);//2.密码忘记了需要破解密码//修改密码","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"数据库(1)-终端命令操作","slug":"php基础/数据库(1)-终端命令操作","date":"2018-06-01T14:30:40.000Z","updated":"2019-06-09T07:01:20.951Z","comments":true,"path":"2018/06/01/php基础/数据库(1)-终端命令操作/","link":"","permalink":"http://yoursite.com/2018/06/01/php基础/数据库(1)-终端命令操作/","excerpt":"","text":"1.在 mysql 官网下载 mysql 安装包安装：1.mac 下的 mysql 在MySQL Community Server下下载，主要是数据库环境。 2.查看在：系统偏好设置下面 如果为绿色就是打开 3.下载Navicate Premium：主要是用于管理数据库可视化操作的。 4.下载mamp：php 虚拟服务器环境。5.mysql 在 mac 下的进入：/usr/local/mysql/bin/mysql -u root -p6.MacOs 终端打开 mysql： /usr/local/mysql/bin/mysql -u root -p 输入 root 用户名密码（windows 环境下打开方式：mysql -u root -p） 1.设计（字段管理，索引管理）1.数据表设计： user.frm :表字段 user.myd：表数据 user.myi:表索引 2.字段类型: 数据表概念：】 数据表引擎：myisum innodb 表字段类型： 默认都是有符号的:signed(有符号) unsigned(无符号) 数字类型 tinyint(0 到 255)存储大小为 1 个字节 int (有符号:-2147483648 到 2147483648)（无符号：0-4294967295）存储大小为 4 个字节 mediumint(有符号-8388608 到 8388607) bigint（有符号:-9223372036854775808到9223372036854775807）（无符号：0-18446744073709551615） 字符串类型: 1. char （m）：0-255 字符 2. varchar(m):0-65535 字符 355 以内字节常用 3. text:0-65535 字节 255 字节以外常用 4. tinytext：0-255 字符 5. mediumtext:0-16777215 字符 6. longtext:0-4249967295 字符日期类型:int 3.数据字段属性： 无符号： unsigned 0 填充：zerofill 自增：auto_increment 1234create table 表格名(-&gt;id int unsigned auto_increment primary key,给id自动增加编号-&gt;username varchar(50) not null 长度为50个字符); 空类型:null 1age int null; not null 1age int not null; 默认值:default 1age int not null deafult 18; 4.mysql 服务器默认字符集： \\s：就是查看 mysql 的默认字符集 default-charactor-set=utf8 建议客户端字符集 utf8 charactor-set-server=utf8 mysql 服务器默认字符集是 utf8 collation-server=utf8_general_cli mysql 服务端校验字符集 5.字段管理： 添加表字段: 123456789101112//创建表格create table user( -&gt; id int unsigned auto_increment primary key, -&gt; username varchar(50) not null, -&gt; passworld varchar(50) not null -&gt; );//查看详情desc user//在表的最后一列添加字段alter table 表名 add age tinyint unsigned not null;//add添加字段alter table 表名 add varchar(30) not null after user; 删除表字段 12//drop删除字段alter table 表名 drop passworld; 修改表字段 123//modify和change修改字段alter table 表名 modify username varchar(30);//修改字段的varchar(30)值alter table 表名 change username user varchar(30);//将user那么字段修改为 查看表字段 1desc user;//查看交user的表 6.索引管理:注意一个表只能有一个索引（索引的目的就是标注一下，只删改删的而不是一口气把所有内容都删完） 主键(一个表的主键只能有一个主键，不能有多个主键):一般表的 id 都是自增就是一个主键 添加 12345678910111213 create table user2( -&gt; id int unsigned not null auto_increment, -&gt; username varchar(30) not null, -&gt; primary key(id)//是指添加主键的方法 -&gt; );create table user2( -&gt; id int unsigned not null auto_increment primary key, -&gt; username varchar(30) not null -&gt; );//主键索引相比较其他索引的优点是速度更加的快//添加索引select * from 表名 where class_id in(select id from class); 12alter table user2 modify id int unsigned not null;先删掉自增在删掉主键方法alter table user2 drop primary key; 唯一（例如 username，age 之类的）: 添加 12alter table user2 add unique（唯一索引）u_username(username)//u_username()是指起一个索引名//或者是 删除: 1alter table user2 drop index u_username;//删除唯一 普通: 添加 1alter table user2 add index（唯一索引）u_username(username)//u_username()是指起一个索引名 删除 1alter table user2 drop index i_username;//删除唯一 2.操作（数据库操作，数据库表操作，多表操作）1.数据库操作 创建一个数据库：创建一个名字为 mydatabase 数据库： create database mydatabase ; 123456789101112131415161718192021//数据库操作1.创建一个名字为mydatabase数据库： create database mydatabase ;2.查看创建的数据库是否成功： show databases;3.更改数据库名字 ： alter databases Hdatabase ;更改数据库mydatabase的字符集 ： alter database mydatabase charset GBK ;4.删除数据库:drop database 数据库名;5.进入数据库： use mydatabase ;//表操作1.查看数据库表： show tables ;2.创建表：create table student ( name varchar(10) , gender varchar(10) , sno int primary key(id))charset utf8;3.查看数据库表：show tables;4.删除数据库表：drop table 表名；5.修改数据库名:rename table 原始名 to 修改名;https://blog.csdn.net/ivolcano/article/details/53728161//数据管理1.插入表行：insert into user2 (id,username,age,class) values(11,\"usernew\",\"22\",\"3\");2.查询数据:select * from 表名； 12345678910111213141516171819202. 查看数据库:show databases;(一定要加分号，不然没有效果)3. 关闭 mysql：net stop mysql4. 打开 mysql:net start mysql5. 切换数据库:use 数据库名;6. 退出 mysql:exit;7. 删除数据库:drop databases 数据库名;#### &lt;span data-type=&quot;color&quot; style=&quot;color:#003A8C&quot;&gt;2.数据&lt;/span&gt;&lt;span data-type=&quot;background&quot; style=&quot;background-color:#FAFAFA&quot;&gt;&lt;span data-type=&quot;color&quot; style=&quot;color:#003A8C&quot;&gt;表操作&lt;/span&gt;&lt;/span&gt;1. &lt;span data-type=&quot;background&quot; style=&quot;background-color:#FADB14&quot;&gt;创建一个表格:&lt;/span&gt;create table 表名称; 1. ```php create table student(name varchar(10),gender varchar(10))charset utf8; create table test( -&gt; id int unsigned auto_increment primary key, -&gt; name char(50) not null, -&gt; age char(50) not null, -&gt; ctime int not null -&gt; ); 查看所有表:show tables; 查看表结构：desc 表名称; 给表格插入内容: 1insert into student(name,gender) values(\"jack1\",\"web\"); 查看表数据：select * from 表名; 123456+-------+--------+| name | gender |+-------+--------+| jack1 | web || jack2 | web2 |+-------+--------+ 删除数据表:drop table 表名; 修改表格名:rename table 原始名 to 修改名; 有符号和无符号： 1234有符号数值:create table t1(id int);无符号数值:create table t2(id int unsigned); ss 3.mysql 数据库表增，删，改，查 增加:insert into t11(username,passworld) values(“user1”,”123”); 删除（锁定条件，具体删掉哪一个）:delete from 表名 where id=2; 修改:updata t11 set passwolrd=’123’(将 id 为 502 的密码改为 123) where id =502; 连续修改用逗号隔开：updata t11 set passwolrd=’123’,age=’22’ where id =502 查询:select * from t11; 查询具体范围：select * from 表名 where id&gt;=3 and id&lt;=7; 另外一种写法：delete from 表名 where id bettween 3 and 5; grand：授权新用户 commit: rollback: 1234DCL:数据控制语言DDL:数据定义语言DML:数据操作语言DQL:数据查询语言 4.选择特定字段 select * from 表格;//*是指查看整个表格 select username from 表格;//查看表格的 username,这种茶单列的方式比查多列的方式要快 select username user,age agetwo from user2;//给字段起一个别名,给 username 起一个别名 user distinct 关键字的使用； 使用 where 条件进行查询:select * from 表名 where id&gt;=3 and id&lt;=5; 或者是使用 between 方法:select * from 表名 where id between 3 and 5; 查询空值:select * from 表名 where username is null; or 的使用方法:select * from 表格 where id 3 or id 5 or id 7; in 的用法：select * from 表名 where id in(3,5,7); %类似于筛选的意思:select * from 表名 where username link “%user%”;//筛选 username 中的 user 查找值为 null 的行:select * from user2 where passworld is null; 查询的值不为 null 的行：select * from user2 where passworld is not null; 使用 order by 对查询的结果进行排序，默认的就是升序： 升序(asc):select * from 表名 order by id asc; 降序(desc): select * from 表名 order by id desc； 使用 limit 限定输出条数(分页实现),特点：查询速度快： select * from 表名 order by id limit 0,2; select * from 表名 order by id limit 5;//是指前 5 条数 分页查询前 3 条数据：select * from user2 limit 3; 从 0 开始截取 2 条数据： select * from user2 limit 0,2; delete 与 truncate 的区别： 1. delete：可以清除表数据，不会清除计数器(计数器：代表自增的计数器) 2. truncate：可以清楚表数据与计数器(计数器：代表自增的计数器)mysql 常用函数： concat():连接函数 select concat(“id:”,id),username,age from user2; 5.随机数 rand 函数: select.rand();生成 0-1 之间的一个随机数; select * from user2 order by rand() limit 1;从表里随机取一条数据 select count(*) from user2;打印出表的总行数 select count(*) from user2 where id&gt;2;统计符合条件的行数 select sum(age) from user2;求和 sum()函数 select avg(id) from user2;求平均值 avg()函数 select max(id) from user2;求最大值 max()函数 求最小值 min()函数 6.group by 分组聚合的使用:作用按条件进行分组 然后在分组的基础上有条件的进行聚合 ? import;显示像数据库引入数据的操作 select count(*) from user2 group by class; 网站的搜索:like ，标签，搜索引擎 select class,max(id),min(id),count(*) from user2 group by class; 7.mysql 的多表查询: 普通多表查询: 12345678910111213141516171819202122232425262728293031323334353637383940//班级表create table class( -&gt; id int unsigned auto_increment primary key, -&gt; name char(50) not null, -&gt; ctime int not null -&gt; );//学员表create table user( id int unsigned auto_increment primary key, username char(50) not null, age tinyint not null); //填充class数据 ? functions是指查询函数insert into class(name,ctime) values(&quot;class1&quot;,unix_timestamp());//unix_timestamp是指时间函数//填充user数据insert into user(username,age) values(&quot;user1&quot;,11);//与班级有关的user表create table user( -&gt; id int unsigned auto_increment primary key, -&gt; username char(50) not null, -&gt; age int not null, -&gt;class_id int not null -&gt; );//加了class_id用于区分分别是几班insert into user(username,age,class_id) values(&quot;user1&quot;,19,1);//列出对应班级的对应学员 user是学员表select * from user,class where user.class_id=class.id;//查询班级学员的名称，年龄，班级，idselect user username,age,class.name,class.ctime from user,class where user.class_id;//from_unixtime()将时间戳转换成年月//将class与user筛选的对应起来select user.username,user.age,class.name,class.ctime from user,class where user.class_id=class.id;//筛选 1班的学员 select user.username,user.age,class.name,class.ctime from user,class where user.class_id=class.id and class.id=4;//user学员名对应班级号 select user.username,class.name from user,class where user.class_id=class.id;//多表索引查询 t1为表格desc select t1.* from t1,class where t1.class_id=class.id\\G 链接查询 左链接(left join)获取左表匹配记录 右链接(right join)获取右边匹配记录 内链接(inner join) 获取两个表中字段匹配的记录 123456789///左链接 统计每个班的总人数select * from class left join user on class.id=user.class_id;select class.* from class left join user on class.id=user.class_id;select class.*,count(*) from class left join user on class.id=user.class_id group by class.id;统计每个班的人数:select class.name,count(user.id) tot from class left join user on class.id=user.class_id group by class.id;左链接特点：左边的数据一一相对，右边的对应不上拉到//右链接与做链接是相对于的//内链接 完全等于 普通列表查询select * from class inner join user on class.id=user.class_id; 嵌套查询或者是子查询 123//嵌套查询 一般用的比较少//查询user表中 存在的所有班级的信息select * from class where id in(select distinct class_id from user); 8.知识补充123456789101112131415161718192021222324//1.where：根据mysql中的字段来读取指定的字段值。或者是指设定查询条件select * from 表名 where id&gt;3;//2.update：需要修改或者是更新mysql中的数据 update 表名 set name=\"test6xiu\" where id=6;//将id为6的那么修改为test6xiu//3.delete 删除数据表中的记录delete from 表名 where id=10;//删除id为10的记录//4.like筛选的意思select * from 表名 where name like '%xiu';//5.union//6.order by 对数据进行排序select * from 表名 order by id desc;//倒序排序//7.group by根据一个或者是多个列对结果进行排序 在分组列上可以使用count,sum,AVGselect username,count(*) from test group by username;//8.count()语法 有统计的意思count(*)返回所有的列，相当于统计表的行数，在统计结果的时候不会忽略值为null的记录count(列名)只包含列名为指定的列，返回指定列的记录数//9.sum()函数 是指求和函数 with rollup：在分组的基础上进行统计//10.null 补充//当mysql使用select或者是where命令的时候读取数据中的字段，如果为空就无法继续执行//使用is null 或者是is not null 进行判断//11.auto_increment 实现序列 表中的id无需指定值可自动增长//12.防止重复出现数据主键：primary key 能够唯一识别表中每一行的属性或者是属性组。一个表中只能有一个主键。唯一：unique Oracle 数据库:Oracle SQL(http://www.oracle.com/technetwork/cn/database/database-technologies/sql/overview/index.html)","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"组件生命周期与组件传值","slug":"vue/组件生命周期与组件传值","date":"2018-05-30T15:29:59.000Z","updated":"2019-06-01T13:04:25.234Z","comments":true,"path":"2018/05/30/vue/组件生命周期与组件传值/","link":"","permalink":"http://yoursite.com/2018/05/30/vue/组件生命周期与组件传值/","excerpt":"","text":"组件生命周期与组件传值 1.组件生命周期 https://segmentfault.com/a/1190000008010666 beforeCreate:组件实例刚刚被创建，组件属性刚刚创建，计算属性之前。 Created：组件实例创建完成，属性已经绑定，但是 dom 还未生成，$el 属性还不存在。 beforeMounted:编译挂载之前，完成了 data 和 el 初始化。 Mounted:编译挂载之后。 beforeUpdate:组件更新之前。 Updated:组件更新之后。 actived：keep-alive，组件被激活时调用 deactived：keep-alive 组件被溢出时调用 beforeDestory:组件销毁之前。 Destroyed:组件销毁之后。 activated（）：keep-alive 组件激活时，该钩子在服务器端渲染期间不被调用 deactivated（）：keep-alive 组件停用时调用。该钩子在服务端渲染期间不被调用。 keep-alive:https://www.cnblogs.com/sysuhanyf/p/7454530.html概念：是 vue 的内置组价，能在组件切换过程中将状态保存在内存中，防止重复渲染 Dom ### 2.父子组件之间传值 父组件给子组件传值:props 12345678910111213141516171819202122232425262728//1.在父组件的子组件中定义singerDatas变量名，吧singer赋值给singerDatas&lt;div class=\"singer\"&gt; &lt;v-singerlist :singerDatas=\"singers\"&gt;&lt;/v-singerlist&gt; &lt;/div&gt; data () &#123; return &#123; singers: [] &#125; &#125;,//2.在singerList子组件的props中接受父组件传的值,singerDatas。必须是singerDatasprops: &#123; singerDatas: &#123; type: Array, default: () =&gt; [] &#125; &#125;,//3.在子组件的组件中定义变量名接受传递的数据，使用。&lt;scroll :singerInfos=\"singerDatas\" &lt;ul&gt; &lt;li v-for=\"group in singerDatas\" :key=\"group.id\" ref=\"listGroup\" class=\"list_group\"&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/scroll&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748492. 子组件给父组件传值：$emit 1. ```php//vm.$emit(event,arg);是指子组件可以通过是￥emit触发父组件的自定义事件//子组件&lt;template&gt; &lt;div class=&quot;train-city&quot;&gt; &lt;h3&gt;父组件传给子组件的toCity:&#123;&#123;sendData&#125;&#125;&lt;/h3&gt; &lt;br/&gt;&lt;button @click=&apos;select(`大连`)&apos;&gt;点击此处将‘大连’发射给父组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&apos;trainCity&apos;, props:[&apos;sendData&apos;], // 用来接收父组件传给子组件的数据 methods:&#123; select(val) &#123; let data = &#123; cityname: val &#125;; this.$emit(&apos;showCityName&apos;,data);//select事件触发后，自动触发showCityName事件 &#125; &#125; &#125;&lt;/script&gt;//父组件&lt;template&gt; &lt;div&gt;父组件的toCity&#123;&#123;toCity&#125;&#125;&lt;/div&gt; &lt;train-city @showCityName=&quot;updateCity&quot; :sendData=&quot;toCity&quot;&gt;&lt;/train-city&gt;&lt;template&gt;&lt;script&gt; import TrainCity from &quot;./train-city&quot;; export default &#123; name:&apos;index&apos;, components: &#123;TrainCity&#125;, data () &#123; return &#123; toCity:&quot;北京&quot; &#125; &#125;, methods:&#123; updateCity(data)&#123;//触发子组件城市选择-选择城市的事件 this.toCity = data.cityname;//改变了父组件的值 console.log(&apos;toCity:&apos;+this.toCity) &#125; &#125; &#125;&lt;/script&gt; vuex 的传值方法 12345678910111213141516171819202122//1.src下新建一个store文件夹//2.store文件夹下新建：state.js,mutations.js,mutation-type.js,getter.js,action.js,index.js//3.index.jsimport Vue from 'vue'import Vuex from 'vuex'import state from './state'import mutations from './mutations'import getters from './getters'import actions from './actions'// 此处的变量名命名必须小写，不能大写 大写的渲染不了Vue.use(Vuex)const store = new Vuex.Store(&#123; state, mutations, getters, actions&#125;)export default store//state.js下export default &#123; count: 0, price: 100&#125; export default state//mutation-types.js 下//mutation-type.js 这个文件的目的是声明整个项目用于修改 state 方法有哪些export const COUNT = ‘COUNT’//mutations.js 下import _ as types from ‘./mutation-types’export default{[types.COUNT] (state, count) {state.count = count} }export default mutations//getters.jsexport default{total: state =&gt; {return state.count _ state.price} }//actions.jsimport * as types from ‘./mutation-types’export default{actionCount ({commit}, count) {commit(types.COUNT, count)} } 12","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"router-link与redirect用法","slug":"vue/router-link与redirect用法","date":"2018-05-30T15:29:59.000Z","updated":"2019-06-01T13:35:10.029Z","comments":true,"path":"2018/05/30/vue/router-link与redirect用法/","link":"","permalink":"http://yoursite.com/2018/05/30/vue/router-link与redirect用法/","excerpt":"","text":"https://www.cnblogs.com/SamWeb/p/6610733.html 1.router-link : 简单的定死路由跳转：:路由跳转，将组件映射到路由。 123456789101112131415161718192021&lt;!--route:是指一条路由（Home按钮 =&gt; home内容） --&gt;&lt;!--routes:是指一组路由：把每一条路由组合起来组合成一个数组[&#123;home 按钮 =&gt;home内容 &#125;， &#123; about按钮 =&gt; about 内容&#125;]--&gt;&lt;!--router：是一个记住，相当于管理者，管理路由。--&gt;1.vue写法&lt;!--&lt;router-link&gt; 就是定义页面中点击的部分 to是指点击之后跳转到哪里去指定链接 &lt;router-view&gt; 定义显示部分--&gt;&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;&lt;router-link to=\"/foo\"&gt;Go to Foo&lt;/router-link&gt;&lt;router-link to=\"/bar\"&gt;Go to Bar&lt;/router-link&gt;2.router中的index.js配置路由配置&lt;!--1.单个路由用route多个路由用routes--&gt;&lt;!--2.引入组件：import Reaconmend from '../views/reaconmend/reaconmend.vue' --&gt;&lt;!--3.path是指路径 component是指组件--&gt;Vue.use(VueRouter);// 要告诉 vue 使用 vueRouter const routes = [ &#123; path:'/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125; ]3.最后创建router对路由进行管理，它是有构造函数new vueRouter()创建，接受routes 参数。 const router = new VueRouter(&#123; routes // routes:routes 的简写 &#125;)4.创建完成后，把router实例注入到vue跟实例中，就是main.js文件。就可以使用路由了。const app = new Vue(&#123; router &#125;).$mount('#app')&lt;!--执行过程：当用户点击 router-link 标签时，会去寻找它的 to 属性， 它的 to 属性和 js 中配置的路径&#123; path: '/home', component: Home&#125; path 一一对应，从而找到了匹配的组件， 最后把组件渲染到 &lt;router-view&gt; 标签所在的地方。所有的这些实现才是基于hash 实现的。--&gt;注意：要安装vue-router但是vue-cli有配置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647482. 嵌套路由：是指点击进入一个页面后下面还有分类还有跳转。 1. ```html在路由设计上先进入home页面，在进入下面的phone子页面。所以vue需要childrens属性1.vue&lt;template&gt; &lt;div&gt; &lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt; &lt;p&gt; &lt;router-link to=&quot;/home/phone&quot;&gt;手机&lt;/router-link&gt; &lt;router-link to=&quot;/home/tablet&quot;&gt;平板&lt;/router-link&gt; &lt;router-link to=&quot;/home/computer&quot;&gt;电脑&lt;/router-link&gt; &lt;/p&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;2.index.jsconst routes = [ &#123; path:&quot;/home&quot;, component: home, // 子路由 children: [ &#123; path: &quot;phone&quot;, component: phone &#125;, &#123; path: &quot;tablet&quot;, component: tablet &#125;, &#123; path: &quot;computer&quot;, component: computer &#125;， // 当进入到home时，下面的组件显示 因为当刚刚进入时他children对应的路由为空。 &#123; path: &quot;&quot;, component: phone &#125; ] &#125;, &#123; path: &apos;/&apos;, redirect: &apos;/home&apos; &#125;] 动态路由：就是登陆页面除了名字不同其他是相同的跳转的是同一个组件。假设一个 user 组件，不同用户(用户的 id)会导航到同一个 user 组件中。就是 path 属性不能写死。 1234567891011121314151617181920212223242526272829303132333435363738394041424344在vue-router中，动态部分 以 : 开头，那么路径就变成了 /user/:id,这条路由就可以这么写： &#123; path:\"/user/:id\", component: user &#125;. .vue&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\" /&gt; &lt;header&gt; &lt;router-link to=\"/home\"&gt;Home&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;About&lt;/router-link&gt; &lt;!-- 增加两个到user组件的导航，可以看到这里使用了不同的to属性 --&gt; &lt;router-link to=\"/user/123\"&gt;User123&lt;/router-link&gt; &lt;router-link to=\"/user/456\"&gt;User456&lt;/router-link&gt; &lt;/header&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;index.js const routes = [ &#123; path:\"/home\", component: home &#125;, &#123; path:\"/about\", component: about &#125;, /*新增user路径，配置了动态的id*/ &#123; path:\"/user/:id\", component: user &#125;, &#123; path: '/', redirect: '/home' &#125; ]获取动态内容&lt;template&gt; &lt;div&gt; &lt;h1&gt;User&lt;/h1&gt; &lt;div&gt;我是user组件, 动态部分是&#123;&#123;dynamicSegment&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; dynamicSegment: '' &#125; &#125;, computed: &#123; dynamicSegment () &#123; return this.$route.params.id &#125; &#125;， watch: &#123; $route (to,from)&#123; this.dynamicSegment = to.params.id &#125; &#125; &#125;&lt;/script&gt; 12345678910114. 命名路由：加一个name 属性 1. ```&lt;router-link to=&quot;/user/123&quot;&gt;User123&lt;/router-link&gt; // 和下面等价 &lt;router-link :to=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;&#123; path: &quot;/user/:id&quot;, name: &quot;user&quot;, component: user&#125; 2.redirect 重定向 概念：是指当页面初始化进入事指向的那个路由。 12const routes = [ // 重定向 &#123; path: '/', redirect: '/home' &#125;， &#123;//点击跳转path:\"/home\", component: home &#125; ] 122. ss","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vuex与父子组件通讯","slug":"vue/vuex与父子组件通讯","date":"2018-05-24T12:29:59.000Z","updated":"2019-06-01T13:35:42.915Z","comments":true,"path":"2018/05/24/vue/vuex与父子组件通讯/","link":"","permalink":"http://yoursite.com/2018/05/24/vue/vuex与父子组件通讯/","excerpt":"","text":"1.vuex 理解 概念：是一个公共的状态库，可以在所有组价库里面去使用，修改。 目录： index.js state.js mutations.js getters.js actions.js 2.store 的状态理解 state：最基本定义的状态： 1. 123456789101112export default &#123; count: 0, price: 100&#125;在组件中运用:Import &#123;mapState&#125; from ‘vuex’Computed:&#123; …mapState(&#123; count:’count’ &#125;)&#125;&lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; getter：相当于计算属性。当我们得到 state 的值之后，使用 getter，将这些基本的值，进行加工，得到我们需要的值 123456789101112export default&#123; total: state =&gt; &#123; return state.count * state.price &#125;&#125;//组件中运用：computed:&#123; …mapGetters(&#123; total:’total’ &#125;)&#125;&lt;p&gt;&#123;&#123;total&#125;&#125;&lt;/p&gt; mutations：改变 state 的值，这个是唯一的方法： 123456789101112131415首先在mutation-type.js中声明变量例如:export const COUNT=‘COUNT’在mutation中操作：import *as types from ‘./mutation-types’Export default&#123; [types.COUNT](state,count)&#123; state.count=count//等号后面的count是这个函数传参进来的值，赋值给state.状态中的count。 &#125;&#125;//组件运用methods:&#123; …mapMutations(&#123; ‘setCount’:types.COUNT//此处的setCount是需要传参的。 &#125;) &#125; 123454. actions： 1. ```undefined假如你有好几个mutation需要提交, 一个一个的写就太傻逼了. 可以用 actions 来封装 mutations. index.js 下面操作 1234567891011121314import vue from ‘vue’ import vuex from ‘vuex’ import state from ‘./state’ import mutations from ‘./mutations’ import getters from ‘./getters’ import actions from ‘./actions’ vue.use(vuex) const store=new Vuex.Store(&#123; state, mutations, getters, actions &#125;) export default store 123456789101112131415161718192021222324252627282930313233343536373839404142436. ss&lt;a name=&quot;l7dzpe&quot;&gt;&lt;/a&gt;### [](#l7dzpe)3.父组件给子组件传值1. s 1. ```javascript//1,父组件的子组件上定义要变量名data，接受要传递的singers数据&lt;template&gt; &lt;div class=&quot;singer&quot;&gt; &lt;singerList :data=&quot;singers&quot;&gt;&lt;/singerList&gt; &lt;/div&gt;&lt;/template&gt;data () &#123; return &#123; singers: [] &#125; &#125;,methods: &#123; _singerData () &#123; api.singerData().then((res) =&gt; &#123; if (res.data.code === ERR_OK) &#123; this.singers = res.data.data.list // console.log(this.singers) &#125; &#125;) &#125; &#125;//在子组件的props接受传递的数据 名称必须与父组件定义的:data变量名一致export default &#123; name: &apos;singer_list&apos;, props: &#123; data: &#123; type: Array, default: () =&gt; [] &#125; &#125;&#125;//在子组件中使用&lt;div class=&quot;singer_list&quot; :singerInfos=&quot;data&quot;&gt;&lt;/div&gt; 4.子组件给父组件传值（$emit）12345678910111213141516171819202122232425262728293031323334353637383940vm.$emit(event,args)//触发当前实例上的事件//子&lt;template&gt; &lt;div class=\"train-city\"&gt; &lt;span @click='select(`大连`)'&gt;大连&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:'trainCity', methods:&#123; select(val) &#123; let data = &#123; cityname: val &#125;; this.$emit('showCityName',data);//select事件触发后，自动触发showCityName事件 &#125; &#125;&#125;&lt;/script&gt;//父&lt;template&gt; &lt;trainCity @showCityName=\"updateCity\" :index=\"goOrtoCity\"&gt;&lt;/trainCity&gt; //监听子组件的showCityName事件。&lt;template&gt;&lt;script&gt;export default &#123; name:'index', data () &#123; return &#123; toCity:\"北京\" &#125; &#125; methods:&#123; updateCity(data)&#123;//触发子组件城市选择-选择城市的事件 this.toCity = data.cityname;//改变了父组件的值 console.log('toCity:'+this.toCity) &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-music歌手详情页","slug":"vue/vue-music歌手详情页","date":"2018-05-21T11:20:59.000Z","updated":"2019-06-01T13:35:18.363Z","comments":true,"path":"2018/05/21/vue/vue-music歌手详情页/","link":"","permalink":"http://yoursite.com/2018/05/21/vue/vue-music歌手详情页/","excerpt":"","text":"1.singer 页面引入 singer-detail 二级路由12345678910111213141516171819202122232425262728//1.在singerlist中触发事件 @click=\"selectItem(items)\"//2.在methods中： selectItem (items) &#123; this.$emit('select', items)//将事件传递给父组件，将items给父组件&#125;,//3.在singer组件中 &lt;div class=\"singer\"&gt; &lt;v-singerlist @select=\"selectSinger\" :singerDatas=\"singers\"&gt;&lt;/v-singerlist&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;//4.在父组件的methods中使用 selectSinger (singer) &#123; this.$router.push(&#123; path: `/singer/$&#123;singer.id&#125;` &#125;) this.setSinger(singer)&#125;//5.index.js路由中配置&#123; path: '/singer', component: Singer, children: [ &#123; path: ':id', component: SingerDetail &#125; ] 2.Vuex 传值vuex 的安装与配置： 1234567891011121314151617181920212223242526272829//1.安装npm install vuex --save//2.在main.js中注入vueximport Vuex from \"vuex\"Vue.use(Vuex)//3.在store.js中使用import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state:&#123; count:0 &#125;, mutations:&#123; increment:state =&gt; state.count ++, decrement:state =&gt; state.count --, &#125;&#125;)&lt;br&gt;//简单的计数//4.在main.js中导入import store from './store/store'//实例化 storenew Vue(&#123; el: '#app', store, router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) vuex 的流程一般为: 定义 state，考虑项目的原始数据(最好是底层数据)。 getter，就是对原始数据的一层映射，可以只为底层数据做一个代理访问，也可以根据底层数据映射为新的计算属性。 mutation 是，定义如何修改数据的逻辑 在定义 mutation 之前，要先定义 mutation-types(通常为动词加名词) actions.js 异步操作 对 mutation 的封装，比如一个动作需要触发多个 mutation 的时候，就可以吧 mutation 封装到 action 是里面去，达到调用一个 action 去修改多个 mutation 的目的。 vuex 传值： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//通过vuex将singerlist.vue的数据传值给singerdetail//1.首先singerlist.vue检测点击事件，将具体点击的歌手派发出去，以供父组件监听selectItem(item)&#123; this.$emit(\"select\",item)&#125;//2.父组件监听事件执行selectSinger(singer)selectSinger(singer)&#123;this.$router.push(&#123; path:`/singer/$&#123;singer.id&#125;` &#125;)this.setSinger(singer)&#125;...mapMutations(&#123; setSinger: 'SET_SINGER'&#125;)//3.使用mapMutations语法映射mutations，this.setSinger(singer)相当于执行this.$store.commit('SET_SINGER')//singer为mutation的地呢个参数[types.SET_SINGER](state, singer) &#123; state.singer = singer&#125;//4.SingerDetail取vuex中存好的数据computed: &#123; ...mapGetters([ 'singer' ])&#125;//getters内singer的逻辑为：singer = state =&gt; state.singer//singerdetail获取的数据的name和avatar通过props传值给MusicList//在singerdetail中&lt;transition name=\"slider\"&gt; &lt;v-musiclist :title=\"title\" :bgImage=\"bgImage\"&gt;&lt;/v-musiclist&gt;&lt;/transition&gt;computed: &#123; title () &#123; return this.singer.name &#125;, bgImage () &#123; return this.singer.avatar &#125;, ...mapGetters([ 'singer' ]) &#125;//在musiclist中props: &#123; title: &#123; type: String, default: '' &#125;, bgImage: &#123; type: String, default: '' &#125; &#125;, 3.歌手详情页对应数据的获取","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"loading-图片懒加载","slug":"vue/loading-图片懒加载","date":"2018-05-18T15:20:59.000Z","updated":"2019-06-01T13:35:03.251Z","comments":true,"path":"2018/05/18/vue/loading-图片懒加载/","link":"","permalink":"http://yoursite.com/2018/05/18/vue/loading-图片懒加载/","excerpt":"","text":"https://www.cnblogs.com/xyyt/p/7650539.html 安装插件 npm install vue-lazyload –save-dev main.js 中插入 12345import VueLazyLoad from \"vue-lazyload\";Vue.use(VueLazyLoad, &#123; error: \"./static/error.png\", loading: require(\"./common/images/default.png\")&#125;); 123454. vue文件中将需要懒加载的图片绑定 v-bind:src 修改为 v-lazy 1. ```&lt;img class=&quot;item-pic&quot; v-lazy=&quot;newItem.picUrl&quot;/&gt; ss","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vueMusic歌手-左右链动","slug":"vue/vueMusic歌手-左右链动","date":"2018-05-17T15:20:59.000Z","updated":"2019-06-01T13:35:30.384Z","comments":true,"path":"2018/05/17/vue/vueMusic歌手-左右链动/","link":"","permalink":"http://yoursite.com/2018/05/17/vue/vueMusic歌手-左右链动/","excerpt":"","text":"https://blog.csdn.net/tyrionj/article/details/79145667 1.singer.vue 数据重构与排序 歌手页面的结构是 热门、 A-Z 的顺序排列，但抓取的接口数据只是 100 条常见的歌手，并且是乱序的，但我们可以利用接口的 Findex 进行数据的重构 1234567const HOT_NAME = \"热门\";let map = &#123; hot: &#123; title: HOT_NAME, item: [] &#125;&#125;; 12345678910111213141516171819202122232. 接着遍历得到的数据，将前10条添加到热门 hot 里。然后查看每条的 Findex ，如果 map[Findex] 没有，创建 map[Findex] push 进新条目，如果 map[Findex] 有，则向其 push 进新条目 1. ```javascriptlist.forEach((item, index) =&gt; &#123; if (index &lt; HOT_SINGER_LEN) &#123; map.hot.items.push(new Singer(&#123; name: item.Fsinger_name, id: item.Fsinger_mid &#125;)) &#125; const key = item.Findex if (!map[key]) &#123; map[key] = &#123; title: key, items: [] &#125; &#125; map[key].items.push(new Singer(&#123; id: item.Fsinger_mid, name: item.Fsinger_name &#125;)) &#125;) 所以还要将其进行排序，这里会用到 数组的 sort 方法，所以我们要先把 map 对象 转为 数组 1. 4) ss 2.右侧锚点点击，滚动对应的区块 点击锚点跳转到对应的区块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781.第一次点击触碰 shortcut获取点击具体锚点的 index 值记录触碰位置的 index ，利用 scrollToElement滚动至相应 index 的区块2.右侧滚动锚点思路：利用touchmove事件，将2次触碰的位置计算变成delta差值，变成改变后锚点区块index值再将首次触碰的index值+改变后的delta值，再利用scrollToElement滚动至相应区块//几种事件修饰符&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt; 阻止事件传播&lt;a v-on:click.stop.prevent=\"doThis\"&gt;&lt;/a&gt;事件可以串联&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;提交事件不再重载页面//1.给li增加data-index='index'这个属性，data-index属性的值为当前的索引值。点击右侧锚点//获取对应的index索引。根据scroll的scrollToElement属性滚动至对应的索引值//vue代码&lt;div class=\"list_shortcut\" @touchstart=\"onShortcutTouchStart\" @touchend.stop&gt; &lt;ul&gt; &lt;li v-for=\"(items,index) in shortcutList\" :key=\"items.id\" :data-index=\"index\" :class=\"&#123;shortcut_item_active:currentIndex===index&#125;\" class=\"shortcut_item\" &gt;&#123;&#123;items&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;//js//封装dom方法 是获取data-index的值export function getData (el, name, val) &#123; let prefix = 'data-' name = prefix + name if (val) &#123; // console.log('el.getAttribute(name)', el.setAttribute(name)) return el.setAttribute(name, val) &#125; else &#123; // console.log('el.getAttribute(name)', el.getAttribute(name)) return el.getAttribute(name) &#125;&#125;//methods: &#123; onShortcutTouchStart (e) &#123; let anchorIndex = getData(e.target, 'index') // 获取 点击具体锚点的 index 值 console.log(anchorIndex) //滚动前获取初始位置 let firstTouch = e.touches[0] this.touch.y1 = firstTouch.pageY// 保存第一次触碰的位置 this.touch.anchorIndex = anchorIndex// 保存第一次触碰锚点的位置 _scrollTo (index) &#123; this.$refs.singerList.scrollToElement(this.$refs.listGroup[index], 0) //当点击右侧锚点的时候回有高亮，并且跳转到对应的位置 this.scrollY = this.$refs.singerlist.scroll.y &#125; &#125;, _scrollTo (index) &#123; if (!index &amp;&amp; index !== 0) &#123; return &#125; this.$refs.singerlist.scrollToElement(this.$refs.listGroup[index], 0) &#125;，//滚动处理 onShortcutTouchMove (e) &#123; let firstTouch = e.touches[0] this.touch.y2 = firstTouch.pageY let delta = (this.touch.y2 - this.touch.y1) / ANCHOR_HEIGHT | 0 let anchorIndex = +this.touch.anchorIndex + delta this._scrollTo(anchorIndex) &#125;//注意这样还不会生效，必须引入scroll.vue并且在scroll.vue中封装scrollTo方法和scrollToElement scrollTo () &#123; this.scroll &amp;&amp; this.scroll.scrollTo.apply(this.scroll, arguments) &#125;, scrollToElement () &#123; this.scroll &amp;&amp; this.scroll.scrollToElement.apply(this.scroll, arguments) &#125;////event.clientX:返回事件触发时鼠标指向与浏览器页面的水平坐标clientY相反发纵轴坐标//event.pageX:鼠标在页面上的位置，从页面左上角开始，即以页面为参考点，不随滑动条移动而变化//event.screenX:用事件属性可返回事件发生时鼠标指向相对于屏幕的水平坐标 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465662. s&lt;a name=&quot;36knqr&quot;&gt;&lt;/a&gt;### [](#36knqr)3.左边内容滚动，右侧自动高亮不同的锚点```javascript$emit：监听触发的自定义事件1.首先BScroll组件 监听滚动事件，并且派发事件以供父组件监听，将pos值传出去if(this.listenScroll)&#123; let self=this this.scroll.on(&apos;scroll&apos;,(pos)=&gt;&#123; self.$emit(&apos;scroll&apos;,pos)&#125;)&#125;2.父组件监听到滚动派发的事件@scroll=&quot;scroll&quot;将pos.y存在this.scrollY this.scrollY = pos.y3.每个区块的高度列表是 通过_calculateHeight函数实现的_calculateHeight()&#123; this.listHeight=[] const list=this.$refs.listGroup let height=0 this.listHeight.push(height) for(let i=0;i&lt;list.length;i++)&#123; let item=list[i] height+=item.clientHeight this.listHeight.push(height) &#125;&#125;//4.用watch检测数据的变化，一旦变化，重新计算每个区块的高度列表，在判断当前滚动的y抽值，是否应该落在相应grop高度区间，然后更新currentIndex，使shorcut的锚点高亮watch: &#123; singerDatas() &#123; // 延时，确保DOM渲染之后执行，通常是nextTick，这里用setTimeout是为了兼容更低 setTimeout(() =&gt; &#123; this._calculateHeight() &#125;, 20) &#125;, // 这里的 scrollY 是当前组件上的，和 BScroll 的并不是一个 scrollY(newY) &#123; const listHeight = this.listHeight // 1. 当滚动至顶部以上 if (newY &gt; 0) &#123; this.currentIndex = 0 return &#125; // 2. 当在中间部分滚动，length之所以 -1 是因为 当初高度列表定义必须多一个 for (let i = 0; i &lt; listHeight.length - 1; i++) &#123; let height1 = listHeight[i] let height2 = listHeight[i + 1] if (-newY &gt;= height1 &amp;&amp; -newY &lt; height2) &#123; this.currentIndex = i this.diff = height2 + newY // height 上限 - newY 的值 return &#125; &#125; // 3. 当滚动至底部，且 newY 大于最后一个元素的上限 this.currentIndex = listHeight.length - 2 &#125;&#125;//6.在右侧列表上绑定高亮的class： :class=&quot;&#123;&apos;shortcut_item_active&apos;:currentIndex===index&#125;&quot; //注意：1.watch函数回调函数，第一个参数是变化后的新值，第二个参数是旧值 //2.scrollY是定义在data里面的，所以当列表滚动的时候，scroll事件的糊掉函数有修改this.scrollY，所以watch能够监听到它的变化 4.滚动固定标题 效果实现1234567891011121314151617181920212223//html固定代码 &lt;div class=\"list_fixed\" v-show=\"fixedTitle\" ref=\"fixed\"&gt; &lt;h1 class=\"fixed-title\"&gt;&#123;&#123;fixedTitle&#125;&#125;&lt;/h1&gt; &lt;/div&gt;//头部title固定效果 fixedTitle () &#123; if (this.scrollY &gt; 0) &#123; return '' &#125; return this.singerDatas[this.currentIndex] ? this.singerDatas[this.currentIndex].title : ''&#125;//在中间部分滚动时，会不断设置diff的值。每个区块的高度上限（就是底部）减去y轴偏移量的值this.diff=height2+newY;//watch监听到diff的变化，判断如果diff&gt;0且小于区块的高度，设为差值，否则为0.在将fixed的title块translate偏移diff(newVal) &#123; let fixedTop = (newVal &gt; 0 &amp;&amp; newVal &lt; TITLE_HEIGHT) ? newVal - TITLE_HEIGHT : 0 if (this.fixedTop === fixedTop) return // 判断如果两个title区块没有碰到，是不会触发 DOM 操作的 this.fixedTop = fixedTop this.$refs.fixed.style.transform = `translate3d(0,$&#123;fixedTop&#125;px,0)`&#125; e.target 与 e.currentTarget 的区别 e.target 是 tap 点击事件触发的对象（也就是点击的是谁） e.currentTarget 是事件绑定在哪个元素上（也就是这个事件在哪个组件上）。 js 中 call 和 apply call()和 apply()是指改变 this 的指向 12345obj.call(thisObj, arg1, arg2, ...);obj.apply(thisObj, [arg1, arg2, ...]);apply：接受的是数组参数call：接受的是连续参数两者作用一致，都是把obj(即this)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj『继承』了obj的属性和方法。绑定后会立即执行函数。 122. s","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"banner横向轮播图-组件封装思路","slug":"vue/banner横向轮播图-组件封装思路","date":"2018-05-17T15:20:59.000Z","updated":"2019-06-01T13:34:37.513Z","comments":true,"path":"2018/05/17/vue/banner横向轮播图-组件封装思路/","link":"","permalink":"http://yoursite.com/2018/05/17/vue/banner横向轮播图-组件封装思路/","excerpt":"","text":"https://segmentfault.com/a/1190000013294187 https://github.com/ustbhuangyi/better-scroll/blob/master/example/components/slide/slide.vue v-for 一定要加 key 否则会报错 1&lt;li v-for=&quot;item in discList&quot; class=&quot;list_item&quot; :key=&quot;item.id&quot;&gt;&lt;/li&gt; 123456789101112131415161718192021222324252627282930&lt;a name=&quot;fn9wrw&quot;&gt;&lt;/a&gt;### [](#fn9wrw)banner1. 初始化图片的宽度个数，并且监听屏幕变化时刷新图片宽度2. 初始化better-scroll滚动条。better-scroll不同的版本对应的内容不一样，此处是v1.11.13. 初始化dots小圆点，注意初始化的dots要放在放过克隆图片的前面。4. 图片链动小圆点，监听scrollEnd事件，在滚动图片的时候对应的获取图片当前的索引值，并赋值给小圆点的active。5. 设置图片自动loop，计时器定义之前必须清除计数器，否则会叠加计时器时间，造成时间混乱6. 自动loop时，如果要操作手动轮播，就要在scrollEnd结束事件中调用_play()，否则滚动完毕不会执行自动轮播。7. 隐形Bug：点击图片拖动至一半，不松手的情况下，会自动轮播下一页。所以：在滚动之前清理计时器，就不会自动轮播，在触摸滚动结束开启计时器。 1. ```javascriptthis.slider.on(&apos;touchEnd&apos;, () =&gt; &#123; // 手指松开 if (this.autoplay) &#123; this._play() &#125; &#125;) this.slider.on(&apos;beforeScrollStart&apos;, () =&gt; &#123; // 滚动之前 if (this.autoplay) &#123; clearTimeout(this.timer) &#125; &#125;) 隐形 Bug：在切换 tab 相当于 切换了 keep-alive 的组件，轮播会出问题，需要手动帮助执行，利用了 activated , deactivated 钩子函数 1234567891011121314151617181920212223activated () &#123; // 这个是keep-alive if (!this.slide) &#123; return &#125; this.scroll.enabled() let pageIndex = this.scroll.getCurrentPage().pageX this.scroll.goToPage(pageIndex, 0, 0) this.currentPageIndex = pageIndex if (this.autoplay) &#123; this._play() &#125; &#125;, deactivated () &#123; if (!this.slide) &#123; return &#125; this.scroll.disable() clearTimeout(this.timer) &#125;, beforeDestroy () &#123; this.slider.disable() clearTimeout(this.timer) &#125;, 123456789101112131415161718192021229. 为了保证改变窗口大小依然正常轮播，监听窗口 resize 事件，重新渲染轮播图 1. ```javascriptwindow.addEventListener(&apos;resize&apos;, () =&gt; &#123; if (!this.slider || !this.slider.enabled) &#123; // this.slider是指全局可以使用 定义全文可以使用 没有放在data中 return &#125; clearTimeout(this.resizeTimer) this.resizeTimer = setTimeout(() =&gt; &#123; if (this.slider.isInTransition) &#123; this._onScrollEnd() &#125; else &#123; if (this.autoplay) &#123; this._play() &#125; &#125; this.refresh() &#125;, 60) // this._setSliderWidth(true) // this.refresh() &#125;) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103mounted () &#123; setTimeout(() =&gt; &#123; this._setSliderWidth() this._initDots() this._initSlider() if (this.autoPlay) &#123; this._play() &#125; &#125;, 20) window.addEventListener('resize', () =&gt; &#123; if (!this.slider) &#123; return &#125; this._setSliderWidth() this.slider.refresh() &#125;) &#125;,activated () &#123; // 这个是keep-alive if (!this.slide) &#123; return &#125; this.scroll.enabled() let pageIndex = this.scroll.getCurrentPage().pageX this.scroll.goToPage(pageIndex, 0, 0) this.currentPageIndex = pageIndex if (this.autoplay) &#123; this._play() &#125; &#125;, deactivated () &#123; if (!this.slide) &#123; return &#125; this.scroll.disable() clearTimeout(this.timer) &#125;, beforeDestroy () &#123; this.slider.disable() clearTimeout(this.timer) &#125;, methods: &#123; _setSliderWidth (isResize) &#123; this.children = this.$refs.sliderGroup.children let sliderWidth = this.$refs.slider.clientWidth let width = 0 for (let i = 0; i &lt; this.children.length; i++) &#123; let child = this.children[i] child.style.width = sliderWidth + 'px' width += sliderWidth &#125; if (this.loop &amp;&amp; !isResize) &#123; width += 2 * sliderWidth &#125; this.$refs.sliderGroup.style.width = width + 'px' &#125;, _initSlider () &#123; this.slider = new Bscroll(this.$refs.slider, &#123; scrollX: true, scrollY: false, momentum: false, snap: &#123; loop: this.loop, threshold: 0.3, speed: 400 &#125; &#125;) this.slider.on('scrollEnd', this._onScrollEnd) this.slider.on('touchEnd', () =&gt; &#123; // 手指松开 if (this.autoplay) &#123; this._play() &#125; &#125;) this.slider.on('beforeScrollStart', () =&gt; &#123; // 滚动之前 if (this.autoplay) &#123; clearTimeout(this.timer) &#125; &#125;) &#125;, _initDots () &#123; this.dots = new Array(this.children.length) &#125;, _onScrollEnd () &#123; let pageIndex = this.slider.getCurrentPage().pageX this.currentPageIndex = pageIndex if (this.autoplay) &#123; this._play() &#125; &#125;, _play () &#123; clearTimeout(this.timer) this.timer = setTimeout(() =&gt; &#123; this.slider.next() &#125;, this.interval) &#125; &#125;//难点：//BScroll 设置 loop 会自动 clone 两个轮播插在前后位置 所以要增加两个width的宽度保证无缝轮播//初始化dots要放在克隆插入图片的前面//dots active状态 是通过判断 currentIndex 与 index 是否相等//currentIndex 更新是通过获取 scroll 当前 page，BScroll 提供了 api 方便调用this.currentPageIndex = this.scroll.getCurrentPage().pageX// clearTimeout(this.timer)必须调用 1211. s","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"better-scroll-配置纵向滚动","slug":"vue/better-scroll-配置纵向滚动","date":"2018-05-17T15:20:59.000Z","updated":"2019-06-01T13:34:45.374Z","comments":true,"path":"2018/05/17/vue/better-scroll-配置纵向滚动/","link":"","permalink":"http://yoursite.com/2018/05/17/vue/better-scroll-配置纵向滚动/","excerpt":"","text":"概念：是一个移动端滚动解决方案。不仅可以做滚动还可以做轮播图1.安装：npm install–save better-scroll2.在文件中引入 better-scroll。import BScroll from ‘better-scroll’;3.new BScroll(Dom 对象,{//opsitons}); 在 Vue 中要获得 Dom 对象，需设置标签属性‘v-el’。 123456789101112131415161718192021222324252627例如：&lt;div v-el:betterscroll&gt;&lt;/div&gt;获取dom对象，this.$els.betterscroll&lt;div class=&quot;wrapper&quot;&gt; 父元素高度固定的 &lt;ul class=&quot;content&quot;&gt;内容高度随着内容撑开 子元素高度大于父元素高度 &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt;&lt;/div&gt;初始化import BScroll from &apos;better-scroll&apos;mounted () &#123; this.$nextTick(() =&gt; &#123; this._initScroll() &#125;) &#125;, methods: &#123; _initScroll () &#123; // if (!this.$refs.wrapper) &#123; // return // &#125; this.scroll = new BScroll(this.$refs.wrapper, &#123; probeType: this.probeType, click: this.click &#125;) &#125; &#125;, 4.","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"axios-获取接口，mock模拟数据配置","slug":"vue/axios-获取接口，mock模拟数据配置","date":"2018-05-17T15:20:59.000Z","updated":"2019-06-01T13:34:30.996Z","comments":true,"path":"2018/05/17/vue/axios-获取接口，mock模拟数据配置/","link":"","permalink":"http://yoursite.com/2018/05/17/vue/axios-获取接口，mock模拟数据配置/","excerpt":"","text":"https://blog.csdn.net/binginsist/article/details/65630547 1.axios 安装 axios : 1npm install --save axios vue-axios 在 main.js 中引入 123import axios from \"axios\";Vue.use(axios);Vue.prototype.$http = axios; 1234567893. 使用方法 1. ```javascriptthis.$http.get(URL).then(response =&gt; &#123; // success callback&#125;, response =&gt; &#123; // error callback&#125;) 2.mock 的使用 在 mock 文件中定义.json 格式的数据 新版在 webpack.dev.conf.js 配置 12345678在const portfinder = require(‘portfinder’)后添加//首先const express = require('express')//是node.js的框架const app = express()//创建一个路由var appData = require('../mock/getDiscList.json')//加载本地数据文件var data = appData.data//获取对应的本地数据var apiRoutes = express.Router()app.use('/api', apiRoutes) //然后找到 devServer,在里面添加before(app) {app.get(‘/api/seller’, (req, res) =&gt; {res.json({errno: 0,data: seller})//接口返回 json 数据，上面配置的数据 seller 就赋值给 data 请求后调用}),app.get(‘/api/goods’, (req, res) =&gt; {res.json({errno: 0,data: goods})}),app.get(‘/api/ratings’, (req, res) =&gt; {res.json({errno: 0,data: ratings})})} 在 api 的 js 问价下获取接口import axios from ‘axios’export function getDiscList () {return axios.get(‘/api/data’)} 在组件中调用created () {// this.$nextTick(() =&gt; {this._getDiscList()this._bannerList()// })},methods: {_getDiscList () {api.getDiscList().then((res) =&gt; {if (res.data.errno === ERR_OK) {this.discList = res.data.data.list} })},} https://blog.csdn.net/firebird_one/article/details/78656500 12343. &lt;a name=&quot;28o9vy&quot;&gt;&lt;/a&gt;### [](#28o9vy)3.$nextTick.将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"基础(9)-文件函数","slug":"php基础/基础(9)-文件函数","date":"2018-05-09T12:30:40.000Z","updated":"2019-06-09T07:01:11.693Z","comments":true,"path":"2018/05/09/php基础/基础(9)-文件函数/","link":"","permalink":"http://yoursite.com/2018/05/09/php基础/基础(9)-文件函数/","excerpt":"","text":"include()和 require():概念：用于创建多个页面重复使用的函数，页眉，页脚和元素。 12345678910//新建一个footer.php文件 写入需要引入的代码&lt;?php//echo \"&lt;p&gt;我是尾部公用文件&lt;/p&gt;\"?&gt;//在需要的.php文件中引入&lt;?php include 'footer.php';?&gt;include()：只是生成警告会继续执行脚本require():会生成致命的错误并且停止脚本 php 操作文件错误会造成的影响：编辑错误的文件，被垃圾数据填满硬盘，意外删除文件内容 1.文件的基本操作 filetype()：测试是否为文件目录 is_dir()：是否为目录 is_file():是否为函数 file_exists():文件或者是目录是否存在 fontsize（）：文件目录大小 2.文件操作 打开文件：fopen() 1fopen($file,类型) 类型:r(读) w(写：重新开始写】】) a（写：接着上次的内容写） 读取文件:fread(文件名，字节数)，file_get_contents() 1234$file=&apos;wj.txt&apos;;$fp=fopen($file,&apos;r&apos;);$str=fread($fp,3);echo $str; 文件复制 1copy(源文件，要复制的文件) 重命名 1rename(源文件，重命名文件) 关闭文件：close(关闭文件的名称，变量) 关闭文件的好处不想文件暂用服务资源 1fclose（$file） 创建文件： 12//文件打开fopen($file,类型) 类型:r(读) w(写：重新开始写】】) a（写：接着上次的内容写） 写入文件 1fwrite($file,&apos;abc) 删除文件 1unlink($file) 3.目录操作与文件上传 遍历目录： opendir：打开目录 readdir：读取目录 closedir()：关闭目录资源 123456789101112$op=opendir('home');function fdir($op)&#123;//此处去掉. .. readdir($op); readdir($op);&#125;fdir($op);//$rd=readdir($op);while($file=readdir($op))&#123; echo $file; echo \"&lt;br&gt;\";&#125;closedir($op); scandir:目录遍历 创建目录:mkdir() 删除空目录(是指里面没有内容的目录):rmdir() 删除非空目录:deldir() 12345678910$dir='home';function deldir($dir)&#123; $files=scandir($dir); foreach ($files as $file)&#123; if($file!='.'&amp;&amp;$file!='..')&#123; echo \"我是遍历目录\".$file; &#125; &#125;&#125;deldir($dir); 4.文件上传与下载1.","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"基础(8)-字符串函数","slug":"php基础/基础(8)-字符串函数","date":"2018-05-06T14:30:40.000Z","updated":"2019-06-09T07:01:03.943Z","comments":true,"path":"2018/05/06/php基础/基础(8)-字符串函数/","link":"","permalink":"http://yoursite.com/2018/05/06/php基础/基础(8)-字符串函数/","excerpt":"","text":"1.字符串函数 字符串函数 字符串的输出 echo：输出字符串 var_dump()：输出值和类型以及长度 print_r()：输出值 die()；退出当前状态并且输出一条信息 exit()；与 die 的用法类似 printf();格式化输出 sprintf()；与 printf（）类似 字符串的处理介绍 去除空格和字符串填充 trim(),ltrim(),rtrim();分别是去掉字符串左右空格，去掉字符串左边空格，去掉字符串右边空格。 strlen()：获取字符串长度，包含空格。 str_pad()：给字符串填充，默认是往右边填充 str_pad(填充字符，填充长度，填充使用的字符串默认空白，规定填充字符串那边); str_repeat()：指定字符串重复几遍 str_repeat(string,次数)； 字符串大小写转换 strtolower()将字符转换为小写 12$str_lower=\"LINUX IS VERY MUCH\".\"&lt;br&gt;\";echo strtolower($str_lower); strtoupper()将字符转换为大写 ucfirst()首字母单词大写 unwords()每个单词字母大写 与 html 标签和关联的字符串函数 nl2bar()：2 是指 to 转换的意思吧 nl 转换为 br 12$str_bar=\"i\\ncan\\nspeak\\nenglish\";echo nl2br($str_bar).\"&lt;br&gt;\"; trip_tags()：是指将 html 标签去掉，只留下文字 12$str_tags=\"&lt;span style='color: red;'&gt;i like php&lt;span&gt;\";echo strip_tags($str_tags); htmllspecialchars()：标签被显示出来不是被解析 addslashes()： stripslashes() 其他字符串格式化函数 strrev()：语句反转 12$str_strrev=\"linux is very much!\";echo strrev($str_strrev).\"&lt;br&gt;\"; strlen()：获取字符串长度 12$str_strrev=\"linux\";echo strlen($str_strrev).\"&lt;br&gt;\"; number_format()：货币格式化 12$str_num=\"123456789\";echo number_format($str_num).\"&lt;br&gt;\"; md5()：加工成密文 加工后的密文是 32 位的密文 12$str_md5=\"12345\";echo md5($str_md5).\"&lt;br&gt;\"; 字符串分割与拼接 explode()：吧字符串打撒为数组 12$str_explode=\"Hello world. I love Shanghai!\";print_r (explode(\" \",$str_explode)); implode()：吧数组元素组合为字符 12$str_implode=array('hello','world','i','love','shenz');echo implode($str_implode).\"&lt;br&gt;\"; join():是指 implode()的别名。 字符串截取 substr()：对字符串进行截取，定义开始于结束。截取的最后一位不会包括 123$str_substr=\"123467890\";$str_substr2=substr($str_substr,0,3);echo \"我是字符串截取\".$str_substr2.\"&lt;br&gt;\"; mb_substr():对多个字节进行处理。不会出现乱码现象 12$str_mb=\"我的名字叫小马，我的哥哥叫小白菜\";echo mb_substr($str_mb,0,10).'....'.\"&lt;br&gt;\"; 字符串查找 strpos()：查找字符串最开始出现的位置，从索引值 0 开始查找 123$str_strpos='/web/home/index.php';$str_strpos2=strpos($str_strpos,'web');echo $str_strpos2.\"&lt;br&gt;\"; strrpos()：查找字符串最后出现的位置 123$str_pos2='/web/home/index.php';$str_pos3=strrpos($str_pos2,'/');echo substr($str_pos2,$str_pos3+1).\"&lt;br&gt;\"; 字符串替换 str_replace()：用一个字符提哈另外一个字符 12$str_replace2='/web/home/index.php';echo str_replace(\"home\",\"admin\",$str_replace2).\"&lt;br&gt;\"; 其他字符串函数 pathinfo()：地址解析成一个数组 12345$str_url=\"https://www.yzmedu.com/web/home/index.php?id=10&amp;&amp;name=user\";$str_url2=parse_url($str_url);echo \"&lt;pre&gt;\";print_r($str_url2);echo \"&lt;/pre&gt;\"; basename()：获取路径的文件名 12345$str_url=\"https://www.yzmedu.com/web/home/index.php?id=10&amp;&amp;name=user\";echo \"&lt;pre&gt;\";$str_base=basename($str_address);print_r($str_base);echo \"&lt;/pre&gt;\"; dirname():获取路径名 parse_url()：获取地址下的协议 路径 以字符串的形式返回 12345$str_url=\"https://www.yzmedu.com/web/home/index.php?id=10&amp;&amp;name=user\";$str_url2=parse_url($str_url);echo \"&lt;pre&gt;\";print_r($str_url2);echo \"&lt;/pre&gt;\"; parse_str()：吧地址参数切割组装成一个数组 12345$str_string=$str_url2['query'];parse_str($str_string,$string2);echo \"&lt;pre&gt;\";print_r($string2);echo \"&lt;/pre&gt;\";","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"基础(7)-数学函数与日期函数","slug":"php基础/基础(7)-数学函数与日期函数","date":"2018-05-05T14:30:40.000Z","updated":"2019-06-09T04:15:18.627Z","comments":true,"path":"2018/05/05/php基础/基础(7)-数学函数与日期函数/","link":"","permalink":"http://yoursite.com/2018/05/05/php基础/基础(7)-数学函数与日期函数/","excerpt":"","text":"1.数学函数 max():获取数组最大值 round():四舍五入 min():获取数组最小值 mt_rand():生成一定范围的随机数 取整 0 到 21 123456mt_rand(0,10)//定义0到10之间的随机数echo \"随机数\".time().\"_\".mt_rand(0,10).\"&lt;br&gt;\";//随机取图片$arr=array('a.png','b.png','c.png','d.png','e.png');$key=mt_rand(0,count($arr)-1);echo \"&lt;img src='img/&#123;$arr[key]&#125;'&gt;\"; floor():小数向下取整 ceil():小数向上取整 2.错误处理 提示 E_NOTICE 警告 F_WARNING 致命 E_ERROR 语法 E_PASE 所有 E_ALL 3.日期函数 日期函数 unix 时间戳：1970 年 1 月 1 日开始 时间函数： time（）获取时间戳 data()时间戳转日期 12345678//y year 年//m montn 月//d date 日//h hour 小时//i minute 分//s seconed 秒//l是否为闰年 只能被4整除，同时能够被100整除的，必须被400整除echo date('Y-m-d H:m:s',time()); strtotime()日期转时间戳 micrototime（）获取微秒数 ss 修改 php 的默认时区 使用微秒计算 php 脚本执行时间 万年历实例","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"基础(6)-自定义数组函数","slug":"php基础/基础(6)-自定义数组函数","date":"2018-05-02T15:50:40.000Z","updated":"2019-06-09T04:15:10.101Z","comments":true,"path":"2018/05/02/php基础/基础(6)-自定义数组函数/","link":"","permalink":"http://yoursite.com/2018/05/02/php基础/基础(6)-自定义数组函数/","excerpt":"","text":"header(“Content-Type:text/html;charset=utf-8”);这一行代码是为了解决 PHP 中文乱码的问题。 数组函数概念：是指作者写好的数组函数，我们只需要调用即可。 1.数组函数 自定义数组函数 获取数组的值 123456789101112131415161718192021222324252627$arr = array( \"item\" =&gt; \"linux\", \"item2\" =&gt; \"php\", \"item3\" =&gt; \"java\", \"item4\" =&gt; \"mysql\", \"item5\" =&gt; \"jquery\");$arr2 = array( \"item2\" =&gt; \"linux2\", \"item2\" =&gt; \"php2\", \"item3\" =&gt; \"java2\", \"item4\" =&gt; \"mysql2\", \"item5\" =&gt; \"jquery2\");function getVal($arr)&#123; foreach ($arr as $key =&gt; $val) &#123; $row[] = $key; &#125; return $row;&#125;$row=getVal($arr);echo \"&lt;pre&gt;\";print_r($row);echo \"&lt;/pre&gt;\";echo array_values($arr); 获取数组的键 1234567891011121314151617181920212223242526$arr = array( \"item\" =&gt; \"linux\", \"item2\" =&gt; \"php\", \"item3\" =&gt; \"java\", \"item4\" =&gt; \"mysql\", \"item5\" =&gt; \"jquery\");$arr2 = array( \"item2\" =&gt; \"linux2\", \"item2\" =&gt; \"php2\", \"item3\" =&gt; \"java2\", \"item4\" =&gt; \"mysql2\", \"item5\" =&gt; \"jquery2\");function getVal($arr)&#123; foreach ($arr as $key =&gt; $val) &#123; $row[] = $val; &#125; return $row;&#125;$row=getVal($arr);echo \"&lt;pre&gt;\";print_r($row);echo \"&lt;/pre&gt;\";echo array_values($arr); 数组键值对调 12345678910111213141516171819202122232425$arr = array( \"item\" =&gt; \"linux\", \"item2\" =&gt; \"php\", \"item3\" =&gt; \"java\", \"item4\" =&gt; \"mysql\", \"item5\" =&gt; \"jquery\");$arr2 = array( \"item2\" =&gt; \"linux2\", \"item2\" =&gt; \"php2\", \"item3\" =&gt; \"java2\", \"item4\" =&gt; \"mysql2\", \"item5\" =&gt; \"jquery2\");function getVal2($arr)&#123; foreach ($arr as $key =&gt; $val) &#123; $row[$val] = $key; &#125; return $row;&#125;$row=getVal2($arr);echo \"&lt;pre&gt;\";print_r($row);echo \"&lt;/pre&gt;\"; 求数组之和 12345678910111213141516171819202122232425$arr = array( \"item\" =&gt; \"linux\", \"item2\" =&gt; \"php\", \"item3\" =&gt; \"java\", \"item4\" =&gt; \"mysql\", \"item5\" =&gt; \"jquery\");$arr2 = array( \"item2\" =&gt; \"linux2\", \"item2\" =&gt; \"php2\", \"item3\" =&gt; \"java2\", \"item4\" =&gt; \"mysql2\", \"item5\" =&gt; \"jquery2\");function getVal3($arr)&#123; foreach ($arr as $key =&gt; $val) &#123; $total+=$val; &#125; return $total;&#125;$row=getVal3($arr);echo \"&lt;pre&gt;\";print_r($row);echo \"&lt;/pre&gt;\"; 数组合并 123456789101112131415161718192021222324252627$arr = array( \"item\" =&gt; \"linux\", \"item2\" =&gt; \"php\", \"item3\" =&gt; \"java\", \"item4\" =&gt; \"mysql\", \"item5\" =&gt; \"jquery\");$arr2 = array( \"item2\" =&gt; \"linux2\", \"item2\" =&gt; \"php2\", \"item3\" =&gt; \"java2\", \"item4\" =&gt; \"mysql2\", \"item5\" =&gt; \"jquery2\");function getvalthree($arr,$arr2)&#123; foreach ($arr as $key=&gt;$val)&#123; $rowtwo[$key]=$val; &#125; foreach ($arr2 as $key2=&gt;$val2)&#123; $rowtwo[$key2]=$val2; &#125; return $rowtwo;&#125;$rowtwo=getvalthree($arr,$arr2);echo \"&lt;pre&gt;\";print_r($rowtwo);echo \"&lt;/pre&gt;\"; 求数组乘积 1234567891011121314$arr3 = array(1, 3, 5, 7, 9);function getval5($arr3)&#123; $tot=1; foreach ($arr3 as $key =&gt; $val) &#123; $tot *= $val; &#125; return $tot;&#125;$row = getval5($arr3);echo \"&lt;pre&gt;\";print_r($row);echo \"&lt;/pre&gt;\"; 判断一个数值是否在数组中 12345678910111213141516171819202122$arr4 = array( \"item1\" =&gt; \"linux\", \"item2\" =&gt; \"php\", \"item3\" =&gt; \"java\", \"item4\" =&gt; \"mysql\", \"item5\" =&gt; \"jquery\");//原始function getval6($str,$arr4)&#123; foreach ($arr4 as $key =&gt; $val) &#123; if($val==$str)&#123; return true; &#125; &#125; //return true;//return 返回一个值 也可以在函数某个部分充当一段执行的结果&#125;$row = getval6('php',$arr4);echo \"&lt;pre&gt;\";print_r($row);echo \"&lt;/pre&gt;\"; 数组元素个数 123456789101112131415161718192021$arr5 = array( \"item1\" =&gt; \"linux\", \"item2\" =&gt; \"php\", \"item3\" =&gt; \"java\", \"item4\" =&gt; \"mysql\", \"item5\" =&gt; \"jquery\");//原始function getval7($str,$arr5)&#123; foreach ($arr5 as $key =&gt; $val) &#123; $tot++; &#125; return $tot++; //return true;//return 返回一个值 也可以在函数某个部分充当一段执行的结果&#125;$row7 = getval7('php',$arr5);echo \"&lt;pre&gt;\";print_r($row7);echo \"&lt;/pre&gt;\"; 数组过滤 12345678910111213$arr10=array(0,1,2,3,4,5,6,7,8,9,10);function getval9($arr)&#123; foreach ($arr as $key=&gt;$val)&#123; if($val%2==0)&#123; $row[]=$val; &#125; &#125; return $row;&#125;$row9=getval9($arr10);echo \"&lt;/pre&gt;\";print_r($row9);echo \"&lt;/pre&gt;\"; 数组键合并 123456789101112$arr11=array(\"linux\",\"php\");$arr12=array(\"java\",\"mysql\",\"jquery\");function getval10($arr,$arr2)&#123; for ($i=0;$i&lt;2;$i++)&#123; $row8[$arr[$i]]=$arr2[$i]; &#125; return $row8;&#125;$row8 = getval10($arr11,$arr12);echo \"&lt;pre&gt;\";print_r($row8);echo \"&lt;/pre&gt;\"; 系统数组函数 数组键值操作函数 array_values()获取数组的值 1234567891011$arr = array( \"item1\" =&gt; \"linux1\", \"item2\" =&gt; \"linux2\", \"item3\" =&gt; \"linux3\", \"item4\" =&gt; \"linux4\", \"item5\" =&gt; \"linux5\");$arr_value = array_values($arr);echo \"&lt;pre&gt;\";print_r($arr_value);echo \"&lt;/pre&gt;\"; array_keys()获取数组的键 1234567891011$arr = array( \"item1\" =&gt; \"linux1\", \"item2\" =&gt; \"linux2\", \"item3\" =&gt; \"linux3\", \"item4\" =&gt; \"linux4\", \"item5\" =&gt; \"linux5\");$arr_value = array_keys($arr);echo \"&lt;pre&gt;\";print_r($arr_value);echo \"&lt;/pre&gt;\"; in_array()检查一个值是否在数组中 123456789101112$arr = array( \"item1\" =&gt; \"linux1\", \"item2\" =&gt; \"linux2\", \"item3\" =&gt; \"linux3\", \"item4\" =&gt; \"linux4\", \"item5\" =&gt; \"linux5\");$type_in = $_GET['type'];$arr_in = in_array($type_in, $arr);echo \"&lt;pre&gt;\";var_dump($arr_in);echo \"&lt;/pre&gt;\"; array_key_exists()检查一个键是否在数组中 1234567891011$arr = array( \"item1\" =&gt; \"linux1\", \"item2\" =&gt; \"linux2\", \"item3\" =&gt; \"linux3\", \"item4\" =&gt; \"linux4\", \"item5\" =&gt; \"linux5\");$arr_key_exists = array_key_exists(\"item2\", $arr);echo \"&lt;pre&gt;\";var_dump($arr_key_exists);echo \"&lt;/pre&gt;\"; array_flip()数组键值对调 1234567891011$arr = array( \"item1\" =&gt; \"linux1\", \"item2\" =&gt; \"linux2\", \"item3\" =&gt; \"linux3\", \"item4\" =&gt; \"linux4\", \"item5\" =&gt; \"linux5\");$arr_flip = array_flip($arr);echo \"&lt;pre&gt;\";print_r($arr_flip);echo \"&lt;/pre&gt;\"; array_reverse()数组索引值与值对调 1234567891011$arr = array( \"item1\" =&gt; \"linux1\", \"item2\" =&gt; \"linux2\", \"item3\" =&gt; \"linux3\", \"item4\" =&gt; \"linux4\", \"item5\" =&gt; \"linux5\");$arr_reverse = array_reverse($arr);echo \"&lt;pre&gt;\";print_r($arr_reverse);echo \"&lt;/pre&gt;\"; 统计数组的元素和唯一性 count()统计数组元素的个数 12345678910$arr2 = array( \"item1\" =&gt; \"linux1\", \"item2\" =&gt; \"linux2\", \"item3\" =&gt; \"linux3\", \"item4\" =&gt; \"linux4\", \"item5\" =&gt; \"linux5\", \"item6\" =&gt; \"linux5\");$arr_count = count($arr2);echo \"统计数组元素的个数：\", $arr_count; array_count_values()统计数组值出现的次数 123456789101112$arr2 = array( \"item1\" =&gt; \"linux1\", \"item2\" =&gt; \"linux2\", \"item3\" =&gt; \"linux3\", \"item4\" =&gt; \"linux4\", \"item5\" =&gt; \"linux5\", \"item6\" =&gt; \"linux5\");$arr_count_values = array_count_values($arr2);echo \"&lt;pre&gt;\";print_r($arr_count_values);echo \"&lt;/pre&gt;\"; array_unique()统计数组的唯一值 123456789101112$arr2 = array( \"item1\" =&gt; \"linux1\", \"item2\" =&gt; \"linux2\", \"item3\" =&gt; \"linux3\", \"item4\" =&gt; \"linux4\", \"item5\" =&gt; \"linux5\", \"item6\" =&gt; \"linux5\");$arr_unique = array_unique($arr);echo \"&lt;pre&gt;\";print_r($arr_unique);echo \"&lt;/pre&gt;\"; 使用回调函数处理数组和函数 array_filter()过滤数组的值 12345$arr3 = array(0, 'linux', 'php', true, false, array(), '0');$arr_filter = array_filter($arr3);echo \"&lt;pre&gt;\";print_r($arr_filter);echo \"&lt;/pre&gt;\"; array_map()将回调函数改成数组的值 1234567$arr_map=array_map(\"mod\",$arr3);function mod($val)&#123; return $val+1;&#125;echo \"&lt;pre&gt;\";print_r($arr_map);echo \"&lt;/pre&gt;\"; 数组排序函数 sort()不保留原数组 key 升序排序 12345$arr4 = array(1000, 10, 20000, 3, 5);sort($arr4);echo \"&lt;pre&gt;\";print_r($arr4);echo \"&lt;/pre&gt;\"; rsort()不保留原数组 key 降序排序 12345$arr5 = array(1000, 10, 20000, 3, 5);rsort($arr5);echo \"&lt;pre&gt;\";print_r($arr5);echo \"&lt;/pre&gt;\"; asort()保留原来的 key 升序排序 12345arr6 = array(1000, 10, 20000, 3, 5);asort($arr6);echo \"&lt;pre&gt;\";print_r($arr6);echo \"&lt;/pre&gt;\"; arsort()保留原来的 key 降序排序 12345$arr7 = array(1000, 10, 20000, 3, 5);arsort($arr7);echo \"&lt;pre&gt;\";print_r($arr7);echo \"&lt;/pre&gt;\"; ksort()按键排序 升序 保留 key 123456789$arr8 = array( 1000 =&gt; \"linux\", 10 =&gt; \"php\", 50 =&gt; \"mysql\");ksort($arr8);echo \"&lt;pre&gt;\";print_r($arr8);echo \"&lt;/pre&gt;\"; krsort()按键排序 降序 保留 key 123456789$arr9 = array( 1000 =&gt; \"linux\", 10 =&gt; \"php\", 50 =&gt; \"mysql\");krsort($arr9);echo \"&lt;pre&gt;\";print_r($arr9);echo \"&lt;/pre&gt;\"; natsort()按自然数排序 12345$arr10=array(11,100,30,49,2);natsort($arr10);echo \"我是数组自然排序法：\".\"&lt;pre&gt;\";print_r($arr10);echo \"&lt;/pre&gt;\"; natcasesort()忽略大小写排序 12345$arr11=array(\"temp15\",\"Temp13\",\"temp9\",\"TEMP\");natcasesort($arr11);echo \"我是数组忽略大小的自然排序：\".\"&lt;pre&gt;\";print_r($arr11);echo \"&lt;/pre&gt;\"; 拆分，合并，分解与结合函数 array_slice():根据数组索引值截取指定长度。array_slice(array,start,length,preserve) 123456$arr21=array('linux','php','js','java','shell','html');$arr_slice=array_slice($arr21,2,3);//可以是负数 从最后面开始截取echo \"根据数组索引值截取：\".\"&lt;pre&gt;\";print_r($arr_slice);echo \"&lt;/pre&gt;\"; array_splice()删除并替换数组中的元素 123456$arr22 = array('linux', 'php', 'js', 'java', 'shell', 'html');$arr_splice = array_splice($arr22, 2);echo \"根据数组索引值截取：\" . \"&lt;pre&gt;\";print_r($arr_slice);print_r($arr22);echo \"&lt;/pre&gt;\"; array_combine() 数组合并 12345678910//array_combine()是键值合并$trr2 = array('item1', 'item2', 'item3');$trr3 = array('php', 'java', 'linux');$trr4 = array_combine($trr2, $trr3);echo \"array_combine数组合并：\" . \"&lt;pre&gt;\";print_r($trr4);echo \"&lt;/pre&gt;\";//array_mergin()不是键值合并是值合并数组和数据结构 explode()数组拆分 12345$arr_explode=\"2017-03-14\";$arr_explode2=explode(\"-\",$arr_explode);echo \"数组拆分：\".\"&lt;pre&gt;\";print_r($arr_explode2);echo \"&lt;/pre&gt;\"; implode()数组合并 123$arr_implode=array('2017','03','14');$arr_implode2=implode('-',$arr_implode);echo \"数组按指定格式合并：\" . $arr_implode2; join()是 implode()的别名 其他有用的数组处理函数 range()生产有规律的数组 array_sum()计算数组之和 shuffle()打乱数组 array_rand()随机取 key 数组与数据结构 array_pop()删除数组最后一个元素 12$zrr=array('php','java','linux');echo \"删除数组的最后一个元素：\".array_pop($zrr).\"&lt;br&gt;\"; array_shift()删除数组最开始的一个元素 12$zrr2=array('php','java','linux');echo \"删除数组的最开始的一个元素：\".array_shift($zrr2); array_push()数组后面插入一个值 返回数组长度 12$zrr3=array('php','java','linux');echo \"数组后面插入一个元素：\".array_push($zrr3,'css3').\"&lt;br&gt;\"; array_unshift()数组前面插入一个值 返回数组的长度 123$zrr4=array('php','java','linux');echo \"数组前面插入一个元素：\".array_unshift($zrr4,'css3').\"&lt;br&gt;\";print_r($zrr4); 2.数组 4 种遍历 for 循环数组遍历 1234567//count($arr) 用于统计数组元素的个数$arrF=array(1,2,3,5,6,7);$numF=count($arrF);for($i=0;$i&lt;$numF;$i++)&#123; echo \"$&#123;i&#125;=&gt;$arrF&#123;$i&#125;\".\"&lt;br&gt;\";&#125;//f foreach 循环数组遍历 12345678910//foreach循环遍历数组 foreach只能遍历数组$arreach=array( \"item1\"=&gt;\"a\", \"item2\"=&gt;\"b\", \"item3\"=&gt;\"c\", \"item4\"=&gt;\"d\");foreach ($arreach as $key=&gt;$val)&#123; echo \"&#123;$key&#125;=&gt;&#123;$val&#125;\".\"&lt;br&gt;\";&#125; list()循环数组遍历 12345//list()用于将数组的每个值，赋值给list函数的每一个参数//list()解析数组的时候，是按索引解析数组//list()可以通过空参数，选择性的解析数组的值list($a,$b,$c)=[1,2,3];echo $a.\"&lt;br&gt;\".$b.\"&lt;br&gt;\"; each()循环数组遍历 12345678910111213141516/each();用于返回数组当前指针所作为的键值对$zhang = ['a', 'b', 'c', 'd'];$eachH = each($zhang);echo \"&lt;pre&gt;\";print_r($zhang);echo \"&lt;/pre&gt;\";echo \"&lt;pre&gt;\";print_r($eachH);echo \"&lt;/pre&gt;\";list($g, $v) = each($zhang);//list()是指把数组中的值赋给一些变量echo $g . \"-\" . $v . \"&lt;br&gt;\";list($g, $v) = each($zhang);echo $g . \"-\" . $v . \"&lt;br&gt;\";list($g, $v) = each($zhang);echo $g . \"-\" . $v . \"&lt;br&gt;\"; list() each() while() 配合使用 12345678910$arrAll = [ \"item1\" =&gt; \"a\", \"item2\" =&gt; \"b\", \"item3\" =&gt; \"c\", \"item4\" =&gt; \"d\"];while (list($key, $val) = each($arrAll)) &#123; echo \"&#123;$key&#125;=&gt;&#123;$val&#125;\" . \"&lt;br&gt;\";&#125;reset($arrAll);//如果还需要使用 需要用reset()函数，重置数组指针 12 3.print_r()与 var_dump()的区别： print_r()能打印复杂数组类型的值，可以打印数组结构和内容，按照一定格式显示键和元素 1234$aa = array(10, 20);echo \"&lt;pre&gt;\";print_r($aa);echo \"&lt;/pre&gt;\"; var_dump() 判断一个变量的类型的数值，如果变量有值，输出的是变量的数值，返回数据类型 1234$bb = array(10, 20, 40);echo \"&lt;pre&gt;\";var_dump($bb);echo \"&lt;/pre&gt;\";","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"基础(5)-数组与表单","slug":"php基础/基础(5)-数组与表单","date":"2018-04-28T15:20:40.000Z","updated":"2019-06-09T04:15:01.866Z","comments":true,"path":"2018/04/28/php基础/基础(5)-数组与表单/","link":"","permalink":"http://yoursite.com/2018/04/28/php基础/基础(5)-数组与表单/","excerpt":"","text":"1.php 数组定义与数组遍历 数组的作用 作用：单独的一个变量可以存储一个或者是多个值，类型可以是 8 种变量中的任意一种。 数组的定义 $arr=array(1,2,3,4,5); $arr=[1,2,3,4]; 1234arr=array(1,3,5,7,9);echo \"&lt;pre&gt;\";print_r($arr);//print_r输出关于变量易于理解的信息echo \"&lt;/pre&gt;\"; 数组的输出 1234arr=array(1,3,5,7,9);echo \"&lt;pre&gt;\";$arr2=[1,3,5,7,9];echo $arr2[2]; 数组的组成 下标(key)(键) 值(value)(值) 数组的类型 索引数组：下标为数字 关联数组:下标为字符串的 12345678$arr3=array( \"item1\"=&gt;\"linux\", \"item2\"=&gt;\"php\", \"item3\"=&gt;\"java\");echo \"&lt;pre&gt;\";print_r($arr3);echo \"&lt;/pre&gt;\"; 混合数组 12345678$arr4=array( \"5\"=&gt;\"linux\", \"item2\"=&gt;\"php\", \"item3\"=&gt;\"java\");echo \"&lt;pre&gt;\";print_r($arr4);echo \"&lt;/pre&gt;\"; 数组赋值 12345678910111213$arr4=array( \"5\"=&gt;\"linux\", \"item2\"=&gt;\"php\", \"item3\"=&gt;\"java\");$arr4[]=\"html5\";//是所有数值里面最大数字加一echo \"&lt;pre&gt;\";print_r($arr4);echo \"&lt;/pre&gt;\";//简单赋值 $arr[0]=\"html5\";//复杂赋值 $arr[100]=\"javascript\"; $arr[]=\"web\";//它的小标是最大数值加1 for($i=0;$i&lt;10;$i++){ $arr[]=$i;} echo “\";print_r($arr);echo \"“: 123456787. &lt;span data-type=&quot;color&quot; style=&quot;color: rgb(0, 58, 140);&quot;&gt;数组的遍历&lt;/span&gt; 1. 数组的索引值遍历&lt;span data-type=&quot;background&quot; style=&quot;background-color: rgb(212, 177, 6);&quot;&gt;for 循环只能遍历索引数组&lt;/span&gt;: 1. ```php $arrone=array(&quot;linux&quot;,&apos;java&apos;,&apos;php&apos;,&apos;js&apos;); for($i=0;$i&lt;4;$i++)&#123; echo $i.&apos;-&apos;.$arrone[$i].&quot;&lt;br&gt;&quot;; &#125; while…list…each 遍历 1234list($aa2,$bb2)=array(\"linux\",'php');//一定要一一对应echo $aa2;echo \"&lt;br&gt;\";echo \"$bb2\"; $arr10=array( &quot;item1&quot;=&gt;&quot;linux&quot;, &quot;item2&quot;=&gt;&quot;java&quot;, &quot;item3&quot;=&gt;&quot;php&quot;, &quot;item4&quot;=&gt;&quot;js&quot;);while(list($key,$val)=each($arr10)){ echo &quot;&lt;p&gt;{$key}---{$val}&lt;/p&gt;&quot;;} 1234567891011123. &lt;span data-type=&quot;background&quot; style=&quot;background-color: rgb(212, 177, 6);&quot;&gt;foreach 遍历&lt;/span&gt;：foreach 语法结构只能用于&lt;span data-type=&quot;background&quot; style=&quot;background-color: rgb(212, 177, 6);&quot;&gt;遍历数组&lt;/span&gt;或者是&lt;span data-type=&quot;background&quot; style=&quot;background-color: rgb(212, 177, 6);&quot;&gt;对象&lt;/span&gt;，若试图遍历其他数据类型或者是一个未初始化的变量会报错。 1. ```php $arr10=array( &quot;item1&quot;=&gt;&quot;linux&quot;, &quot;item2&quot;=&gt;&quot;java&quot;, &quot;item3&quot;=&gt;&quot;php&quot;, &quot;item4&quot;=&gt;&quot;js&quot; ); foreach ($arr10 as $key=&gt;$val)&#123;//将当前的键名在每次循环中赋值给变量$key值。 echo &quot;&lt;p&gt;&#123;$key&#125;---&#123;$val&#125;&lt;/p&gt;&quot;; &#125; 超全局数组: 这些数组不需要定义，已经定义好了，是超全局变量。超全局是指在函数外面也可以用在函数内部也可以使用、 1. $_GET：获取当前脚本传递的参数。 1. ![image.png | left | 180x44.91295938104449](https://cdn.yuque.com/yuque/0/2018/png/105657/1524797974950-e23dcb4b-78ab-45b7-9bf4-93183a44e948.png &quot;&quot;)$_SERVER：获取服务器的信息 1. SERVER_NAME:服务器名。 2. SERVER_ADDR：服务器的 IP 地址。 3. SERVER_PORT：服务器端口。 4. REMOTE_PORT：客户端 ip。 5. DOCUMENT_ROOT：网站根目录。 6. SCRIPT_FILEANME：当前脚本的系统绝对路径。 7. REQUEST_URI：网站绝对地址+参数 2. $_POST:获取表单给当前脚本栏传递的 post 数据。 1. php echo &quot;&lt;pre&gt;&quot;; print_r($_POST); echo &quot;&lt;/pre&gt;&quot;; // ?&gt; &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;用户注册&lt;/h1&gt; &lt;form action=&quot;szuse2.php&quot; method=&quot;post&quot;&gt; &lt;p&gt;用户名&lt;/p&gt; &lt;p&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;/p&gt; &lt;p&gt;密码&lt;/p&gt; &lt;p&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;ok&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 3. $_REQUEST 1. 获取当前脚本传递的get数据 2. 获取当前脚本传递的post数据 $_COOKIE 5. $_SESSION $_FILES 7. $GLOBALS 1. 超全局数据，用的比较少。可以包含其他所有超全局数组。 8. 超全局作用 1. 预定义：php 已经提前定义好了。 2. 超全局： 1. 函数外面可以用： 2. 函数里面可以用： 数组系统函数 超全局数组的使用： $_GET &lt;&gt;&lt;&gt; $_POST 2.表单 post 传输数据 文本框 1&lt;input type=\"text\" name=\"username\" /&gt; 密码框 1&lt;input type=\"text\" name=\"password\" /&gt; 单选框 1&lt;label&gt; &lt;input type=\"radio\" name=\"love\" value=\"linux\" /&gt;linux &lt;/label&gt; 多选框 1234&lt;label&gt; &lt;input type=\"checkbox\" name=\"love[]\" value=\"linux\" /&gt;linux&lt;/label&gt;&lt;label&gt; &lt;input type=\"checkbox\" name=\"love[]\" value=\"php\" /&gt;php &lt;/label&gt; 下拉菜单 1234567&lt;p&gt; &lt;select name=\"love\" id=\"\"&gt; &lt;option value=\"linux\"&gt;linux&lt;/option&gt; &lt;option value=\"php\"&gt;php&lt;/option&gt; &lt;option value=\"h5\"&gt;h5&lt;/option&gt; &lt;/select&gt;&lt;/p&gt; 多选下拉菜单 1234567&lt;p&gt; &lt;select name=\"love[]\" id=\"\" multiple&gt; &lt;option value=\"linux\"&gt;linux&lt;/option&gt; &lt;option value=\"php\"&gt;php&lt;/option&gt; &lt;option value=\"h5\"&gt;h5&lt;/option&gt; &lt;/select&gt;&lt;/p&gt; 文本框 123456&lt;p&gt; 文本域&lt;/p&gt;&lt;p&gt; &lt;textarea name=\"mess\" id=\"\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;/p&gt; 隐藏框 1234&lt;p&gt;隐藏域&lt;/p&gt;&lt;p&gt; &lt;input type=\"hidden\" name=\"id\" value=\"100\" /&gt;&lt;/p&gt; 图片上传 qq 12345678910111213141516171819202122232425262728293031&lt;form action=\"test.php\" method=\"post\" enctype=\"multipart/form-data\"&gt; 必写//文件上传只能使用post &lt;p&gt;选择图片&lt;/p&gt; &lt;p&gt; &lt;input type=\"file\" name=\"img\" /&gt; &lt;/p&gt;&lt;/form&gt;//&lt;from 表单属性： name='表单名称' 为避免混乱 action=\"表单提交地址\"真正处理表单的数据脚本和程序可以是.php\\.html\\.asp\\mailtomethod=\"数据提交方式\" get\\post enctype=\"表单提交的编码方式\"取值：text/plain以纯文本形式传送,application/x-www-from-urlencoded-默认编码方式multipart/form-data -MIM编码，上传文件表单必须选他target=\"目标窗口打开方式\" _blank _parent _self _top &lt;input ，输入类的控件type=”控件类型” ://text文本输入框 | password密码输入框，（文本类参数有：name，size，maxlength，value）；//button按钮（name，value , onclick） | submit提交按钮（name , value） |reset重置按钮（name , value） | radio单选按钮（name必须设置相同 ,value，checked只能有一项被设置，设置多个时，选中的为最后一个） |checkbox复选按钮（name设置相同 , value，checked可以设置多个，都为选中状态） | image图像按钮（src ,name） |hidden 隐藏域，主要用来传递一些数据，不会显示在页面中（name, value）&gt;5.列表项：与下拉相似，不同的是它可以在页面上显示多个选择项且可以多选,size页面中最多列表项数，multiple 则表示可以多项选择&lt;select name=\"cars\" size=\"3\" multiple&gt; &lt;option value=\"volvo\"&gt;Volvo&lt;/option&gt; &lt;option value=\"saab\"&gt;Saab&lt;/option&gt; &lt;option value=\"fiat\" selected=\"selected\"&gt;Fiat&lt;/option&gt; &lt;option value=\"audi\"&gt;Audi&lt;/option&gt;&lt;/select&gt;multiple 表示多项选择 // &gt;","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"基础(4)-函数","slug":"php基础/基础(4)-函数","date":"2018-04-23T13:59:40.000Z","updated":"2019-06-09T04:14:52.226Z","comments":true,"path":"2018/04/23/php基础/基础(4)-函数/","link":"","permalink":"http://yoursite.com/2018/04/23/php基础/基础(4)-函数/","excerpt":"","text":"1.函数的定义函数：重复使用的代码块，提高代码的重用性。降低冗余度。函数调用:函数名() 1234//语法function functionName() &#123; 被执行的代码;&#125; 判断是否为函数：function_exists() 12345function show()&#123; echo \"我是一个函数\";&#125;$func=\"show\";var_dump(function_exists($func)) 2.语言结构 array(),if(),foe,while(),switch(),echo(),print(),list(),isset(),unset(),foreach(),exit(),die(),include(),require(),empty() 3.函数 系统函数 mysql_connect(); 自定义函数 function show(){} 4.php 变量作用域 局部变量：函数内部的变量 全局变量：函数外面的变量 php 变量作用域的类型: global:在函数内部使用全局变量尽量少使用 12345678$a=10;function show()&#123; global $a; $a++; echo \"我是使用了全局变量a相加后的值：\".$a.\"&lt;br&gt;\";//11&#125;show();echo \"我是全局变量a的值：\".$a.\"&lt;br&gt;\";//11 static：同一个函数被多次调用时可以共享使用 12345678function test()&#123; static $y=1; echo $y; $y++;&#125;echo test(); //1echo test(); //2echo test() parameter：参数是通过调用代码将值传递给函数的局部变量 12345678910$a=10;function sum()&#123; //$a=11; $a++; echo $a.\"&lt;br&gt;\";//1 局部变量&#125;sum();echo $a;//10全局变量?&gt; 5.函数的使用 字符串函数 strlen()函数：返回字符串的长度，以字符计 1echo \"我是strlen定义的一串字符的长度：\".strlen(\"hello world\").\"&lt;br&gt;\"; strpos()函数：用于检索字符串内指定的字符和文本。如果找到匹配，就会返回首个匹配字符的位置。如果未找到就会返回 FLASE 1echo strpos(\"Hello world!\",\"world\"); 函数的返回值：&nbsp;&nbsp;&nbsp;&nbsp;return()语句可以向函数调用者返回任意确定的值，将程序控制权返回到调用者的作用域 1234function showthree($a,$b)&#123; return $a+$b;&#125;echo showthree(10,20);//30 函数的参数 定义：通过参数列表可以传递信息到函数，即以逗号作为分隔符的表达式列表。参数是从左向右传值的。 1234function showfour($k,$y)&#123; return $k+$y;&#125;echo showfour(10,20);//30 函数默认参数 定义：声明函数的时候，参数定义的默认值。如果调用的函数传值将会覆盖默认值。 1234function showfive($i,$j=2)&#123;//$i为必选参数 $j为可选参数 return $i+$j;&#125;echo showfive(10);//12 引用参数 格式 void funName(array&nbsp;&amp;arg) 111 11 可变个数参数的函数 echo “a”,”b”,”c”; 什么是回调函数 定义：是指在一个函数参数中调用另外一个函数。 函数的代码是在检测的时候就已经被加载到内存的代码段中。 123456789function show($i, $j, $c)&#123; return $c($i,$j);&#125;function sum($a, $b)&#123; return $a + $b;&#125; echo “我是回调函数的结果：”.show(10, 20, ‘sum’); 12345678910111213148. &lt;span data-type=&quot;color&quot; style=&quot;color: rgb(0, 58, 140);&quot;&gt;变量函数&lt;/span&gt; 1. 一个变量名可以是函数值 1. ```php function bl() &#123; echo &quot;&lt;p&gt;hello&lt;/p&gt;&quot;; &#125; bl(); $fz=&quot;bl&quot;; $fz();//hello 递归函数： 用于目录删除，目录移入 12345678910$aa3=3;function sumtwo($aa3)&#123; $tot+=$aa3; if($aa3&gt;1)&#123; $tot+=sumtwo(--$aa3); &#125; return $tot; echo $tot;&#125;echo sumtwo($aa3);//6 提高代码重用 include “xxx.php” ;在一个 php 文件里面引入另外一个 php 文件。包含外部文件 require “xxx.php” include 与 require 的区别： include 包含文件报错级别为 warning，不会终止脚本 require 包含文件报错级别为 error，会终止脚本","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"基础(3)-流程控制","slug":"php基础/基础(3)-流程控制","date":"2018-04-20T14:05:40.000Z","updated":"2019-06-09T04:12:34.382Z","comments":true,"path":"2018/04/20/php基础/基础(3)-流程控制/","link":"","permalink":"http://yoursite.com/2018/04/20/php基础/基础(3)-流程控制/","excerpt":"","text":"1.分支结构 if…else…：如果条件为 true，则执行代码。如果条件为 false 则执行另外的代码。 123456$user=\"admin\";if($user==\"admin\")&#123; echo \"正确\",\"&lt;br&gt;\";&#125;else&#123; echo \"错误\",\"&lt;br&gt;\";&#125; if…elseif…else:选择若干代码块来执行 123456789101112$score=95;if($score&gt;=90)&#123; echo \"A\";&#125;else if($score&gt;=80)&#123; echo \"B\";&#125;else if($score&gt;=70)&#123; echo \"C\";&#125;else if($score&gt;=60)&#123; echo \"D\";&#125;else&#123; echo \"E\";&#125; switch…case：语句多个代码块执行其一，使用 switch 可以避免冗长的 if…elseif…else 代码。 123456789101112131415161718192021$w=6;switch ($w)&#123; case 1; echo \"周一\"; break; case 2; echo \"周二\"; break; case 3; echo \"周三\"; break; case 4; echo \"周四\"; break; case 5; echo \"周五\"; break; default; echo \"周末\"; break;&#125; switch 与 if…elseif…else 的区别： if…else 每个条件都会计算一遍。if…else 比较灵活。 switch 使用了 Binary Tree 算法：不管有多少个 case，都直接跳转。不需要逐个比较查询，绝大部分的情况下 switch 会比较快速点儿。 2.循环结构 while：只要条件为真，则循环代码块 12345678910//语法while(条件为真)&#123; 要执行的代码；&#125;//例子$ii=0;while ($ii&lt;10)&#123; echo \"&lt;p&gt;&#123;$ii&#125;&lt;/p&gt;\"; $ii++;&#125; for：循环代码块指定次数 123456789101112131415//语法for (init counter; test counter; increment counter) &#123; code to be executed;&#125;//例子for($i5=0;$i5&lt;10;$i5++)&#123; echo \"&lt;p&gt;&#123;$i5&#125;&lt;/p&gt;\";&#125;//九九乘法表for($o=1;$o&lt;=9;$o++)&#123; for($p=1;$p&lt;=$o;$p++)&#123; echo \"$p*$o=\".$p*$o.\" \"; &#125; echo \"&lt;br&gt;\";&#125; foreach：只使用与数组，用于遍历数组中的每个键/值对。 12345678910//语法foreach ($array as $value) &#123; code to be executed;&#125;//例子$colors = array(\"red\",\"green\",\"blue\",\"yellow\");foreach ($colors as $value) &#123; echo \"$value &lt;br&gt;\";&#125; 3.特殊的流程控制 break break 用在 switch 中使程序流离开 switch 本体语句 break 用在 for,while,或者是 do-while 循环结构体中，终止循环。1234567for($i2=0;$i2&lt;5;$i2++)&#123; if($i2==2)&#123; break;//结束本层循环 &#125;else&#123; echo \"&lt;h1&gt;&#123;$i2&#125;&lt;/h1&gt;\";//结果 0，1 &#125;&#125; continue continue 与 break 的语句差不多，但是 continue 用在 for,while,或者是 do-while 循环结构体中，当程序执行 continue 时，终止本次循环，继续执行下一次的循环。1234567for($i2=0;$i2&lt;5;$i2++)&#123; if($i2==2)&#123; continue;//结束本次循环 &#125;else&#123; echo \"&lt;h1&gt;&#123;$i2&#125;&lt;/h1&gt;\";//结果 0，1，3，4 &#125;&#125; exit 当前脚本只要执行到 exit 语句，不管在哪个结构中都会直接退出当前脚本。exit 是一个函数。123echo \"&lt;h1&gt;11111111&lt;/h1&gt;\";exit;//阻止脚本执行echo \"&lt;h1&gt;11111111&lt;/h1&gt;\"; die die 函数是 exit 的别名。可以带参数输出一条信息，并且退出当前脚本。123echo \"&lt;h1&gt;11111111&lt;/h1&gt;\";die(\"我是小聂子，我快要走了！\");echo \"&lt;h1&gt;11111111&lt;/h1&gt;\";","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"基础(2)-常量与运算符","slug":"php基础/基础(2)-常量与运算符","date":"2018-04-10T12:54:40.000Z","updated":"2019-06-09T04:12:26.820Z","comments":true,"path":"2018/04/10/php基础/基础(2)-常量与运算符/","link":"","permalink":"http://yoursite.com/2018/04/10/php基础/基础(2)-常量与运算符/","excerpt":"","text":"1.常量 define()函数 是指声明一个常量 ，常量一旦定义就不允许更改，常量的声明不需要用$,常量名称必须是大写。 参数一：定义常量的名称 参数二：定义常量的值 参数三：常量名是否对带下不敏感 常量的格式：define(“USERNAME”,”user123”);; 判断一个常量是否存在:defined() 常量与变量的区别： 变量：不会随着环境而改变，同名变量后面的会覆盖前面的 常量：不会随着环境而轻易改变，同名常量不会发生覆盖 12345678910111213define(\"GREETING\", \"Welcome to W3School.com.cn!\");echo GREETING;//exit()阻断$arr=array( 'HOST'=&gt;'localhost', 'USER'=&gt;'root', 'PASS'=&gt;'12345789', 'DBNAME'=&gt;'yzmedu');foreach ($arr as $key=&gt;$val)&#123; define($key,$val); echo $key.$val,\"&lt;br&gt;\";&#125; 2.运算符 一元运算符 ++在前：先运算后赋值 ++在后：先赋值后运算 ++在前 12$ii=10;$j=++$ii;//ii:11 j:11 ++在后 12$i2=10;$j2=$i2++;//i2:10 j2:11 二元运算符 数学运算符（+，-，*，/，%）求余:是指求除以一个数的余数 123456789$kk=0;while($kk&lt;10)&#123; if($kk%2==0)&#123; echo \"&lt;p style='background: pink'&gt;'偶数'.&#123;$kk&#125;&lt;/p&gt;\"; &#125;else&#123; echo \"&lt;p style='background: slateblue'&gt;'奇数'.&#123;$kk&#125;&lt;/p&gt;\"; &#125; $kk++;&#125; 比较运算符(&gt;,&lt;,&gt;=,&lt;=，=，==，===，!=) 123456$xx=30;if($xx&gt;40)&#123; echo \"大于30\",\"&lt;br&gt;\";&#125;else&#123; echo \"小于30\",\"&lt;br&gt;\";&#125; 逻辑运算符(&amp;&amp;(与),||(或),!(非) &amp;&amp;(与)或者 x and y 同真为真，一假为假 前面为真才会执行 ||（或）或者 x or y 一真为真，同假为假 前面为假才会执行 ！（非）或者 x xor y 取反1234567$username=\"admin\";$password=\"123\";if($username==\"admin\"&amp;&amp;$password==\"123\")&#123; echo \"登录成功\",\"&lt;br&gt;\";&#125;else&#123; echo \"登录失败\",\"&lt;br&gt;\";&#125; 赋值运算符(=,.=,+=,-=,/=,%=) 123$zz=10;$zz%=2;echo $zz,\"&lt;br&gt;\"; 三元运算符 变量?true:false;12$cc=true;echo $cc?\"三元运算符成功的结果：\".\"yes\":\"三元运算符失败的结果：\".\"no\"; 运算符的优先级 优先级:++,–高于,/,%高于+,-.高于&lt;,&lt;=,&gt;,&gt;=高于==，！=，===，！===高于&amp;&amp;,||高于?:高于=，+=，-=，=，/=,%=","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"基础(1)-变量定义与类型","slug":"php基础/基础(1)-变量定义与类型","date":"2018-04-08T12:54:40.000Z","updated":"2019-06-09T04:12:09.344Z","comments":true,"path":"2018/04/08/php基础/基础(1)-变量定义与类型/","link":"","permalink":"http://yoursite.com/2018/04/08/php基础/基础(1)-变量定义与类型/","excerpt":"","text":"mysql，apache，php 之间的关系:apache:是一个服务器，是构筑一个 php 和数据库可以沟通的环境。是指 php 和 mysql 两个不同语言的人打电话，通过 Apache 这个同声翻译系统进行构建。 1.php 定义 php 的定义 php 以&lt;?php 开始,代码块 以 ?&gt;结束 php 的拓展名是.php php 的变量以$符号开头，后面跟变量名规则：必须以字母或者是下划线字符开始。变量名只能包含数字字符及下划线（A-Z,0-9 和_）。不能包含空格。严格区分大小写。 echo 和 print 输出的区别 echo：可以输出一个或者是多个字符。 print：只允许输出一个字符，echo 比 print 输出块，echo 没有返回值，print 有返回值 1。 2.php 变量类型 整数（$a=10） 浮点($a=10.10) 字符型($a=”一串字符”) 布尔型($a=true) 数组($a=array()) 对象(由一切事物组成，包括行为，特征)； 资源（操作数据库资源） null()对象理解 *public*是指对属性(特征)或者是方法(行为)的控制，public（公有的），protected（） -&gt;,=&gt;,::,class 的使用：*-&gt;*是指实例化的对象，读取类中的属性和方法。=&gt;用于数组&quot;key&quot;=&gt;&quot;value&quot;,::静态方法和动态方法法引用。class 声明一个类。 代码如下：class Person{//属性是静态的public name=&quot;liuliu&quot;;public age=18;public sex=&quot;nan&quot;;//方法是动态的public function say(){echo &quot;今天的天气真是好&quot;;} }//实例化一个对象$user1=new Person;echo $user1-&gt;name; 数据库资源理解注意：数据库必须在数据库连接成功的情况下进行操作。 连接数据库：$connet=mysql_connet(servername,username,passworld,dbname,port); 定义 msql 语言:mysql_query($connet,”set name usf8”); 选择 msql 数据库语言:mysql_select_db(“数据库名”,”$connet”); 准备查询语句:$sql=”select * from user”; 吧语句发送给数据库:$rst=mysql_query($sql,$connet); 从 msql 返回结果$arr=array(); while($row=mysql_fetch_array(rst)){ var_dump($row); arr_push($arr,$row); } 7.关闭数据库:mysql_close($connet); 3.字符串与字符串的连接$a=”xxx”;$b=”xxx”;echo $a.$b; 4.单引号与双引号的区别 双引号里面可以解析变量，但是要以${变量名}的格式。 但引号不可以解析变量。 双引号里面可以解析变量但是不可以解析表达式。但是可以以”the num id”.($a=$b).”!!!!”; 双引号中解析变量加双引号操作:echo “my name is&quot;${a}&quot;!!!”; 变量测试与转换1.测试变量是否存在 gettype() 获取变量的类型 类似于 var_dump() isset() 判断变量是否设置,是否为 null$aa=array(&#x27;test&#x27;=&gt;1,&#x27;hello&#x27;=&gt;NULL);echo var_dump(isset($aa[&#x27;test&#x27;]);//true empty() 判断一个变量是否为空 2.变量类型之间的转换 自动转换 int，bool,float,string,array,object 例如：$num1=3.14; $num2=(int)$num1; 强制转换 intval(),floatval(),strval() 例如：$str=”123.9abc”; $int=intval($str); 通用类型转换 settype() 例如:$num4=12.8; $flg=settype($num4,”int”);","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"初级笔记","slug":"php基础/初级笔记","date":"2018-04-04T11:54:40.000Z","updated":"2019-06-09T04:07:39.365Z","comments":true,"path":"2018/04/04/php基础/初级笔记/","link":"","permalink":"http://yoursite.com/2018/04/04/php基础/初级笔记/","excerpt":"","text":"php 定义及 php 变量 php 的定义 php 以结束 php 的拓展名是.php php 的变量以$符号开头，后面跟变量名规则：必须以字母或者是下划线字符开始。变量名只能包含数字字符及下划线（A-Z,0-9 和_）。不能包含空格。严格区分大小写。 echo 和 print 输出的区别 echo：可以输出一个或者是多个字符print：只允许输出一个字符 echo 比 print 输出的时间快，echo 没有返回值，print 有返回值 1。 变量的类型\b4.1 整形($a=10)4.2 浮点型($a=10.12)4.3 字符型($a=”字符型”)4.4 布尔型($a=true)4.5 数组 ($a=array(1,3,5))4.6 对象(一切事物,一般由特征，行为组成。特征不会动，行为会动。)4.7 资源4.8 null php 对象 属性或者是方法的访问控制public 是指对属性(特征)或者是方法(行为)的访问控制。public(公有) protected(受保护的)或者是 private(私有的) -&gt;,=&gt;,::，class 作用-&gt;用于类实例化后对象读取类中的属性和方法。=&gt;用于数组’key’=&gt;’value’。::类中静态方法和静态属性的引用方法。class 声明一个类。 数据库连接资源 var_dump()是输出一个变量的具体类型与值。 数据库数据库是在数据库连接成功的情况下进行的操作。1.连接数据库连接 $connent=mysql_connect(servername,username,passworld，dbname,port)2.定义sql语句 mysqli_query($connent,”set name utf8”) 3.选择 sql 数据库 mysql_select_db(“数据库名”,$connent)4.准备查询语句 $sql=”select * from user” 5.吧语句发送个数据库 $rst=mysql_query($sql,$connent);6.从m\bysql服务器返回发结果 while$arr=array();($row=mysqli_fetch_array(rst)){ var_dump($row)array_push($arr,$row)} var_dump($arr)7.关闭连接 mysql_close($connent) php 中字符串连接符 $a=&quot;xxx&quot;; $b=&quot;xxx&quot;; echo $a.$b; php 单双引号的区别: 1.双引号里面可以解析变量但是一定要加{$变量名}，单引号不能解析变量。 2.双引号里面可以解析变量但是不可以执行表达式。但是可以\b以另外的一种方式解析&quot;the num id&quot; .($a+$b).&quot;!!!&quot; 3.双引号中解析变量，并且加双引号 echo &quot;my name is \\&quot;{$a}\\&quot;!!! &quot; 测试变量是否存在 1. 测试变量类型： gettype() var_dump() 2. 测试变量是否存在 isset()： 有两种情况:变量为定义 $a=null值为null empty() 为空:$a=null,$a=0,$a=&quot;&quot;,$a=&quot;0&quot;,$a=array(),$a=0.0,$a=false 变量类型转换 自动转换 强制转换 php 常量与运算符 常量。define()，常量一旦定义就不允许更改，常量命名没有$,常量名称必须是大写。define(“HOST”,”localhost”);","categories":[{"name":"php","slug":"php","permalink":"http://yoursite.com/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"跨域方案","slug":"跨域方案/跨域与浏览器","date":"2018-01-15T13:12:27.000Z","updated":"2019-06-05T12:18:13.699Z","comments":true,"path":"2018/01/15/跨域方案/跨域与浏览器/","link":"","permalink":"http://yoursite.com/2018/01/15/跨域方案/跨域与浏览器/","excerpt":"","text":"https://segmentfault.com/a/1190000011145364 1.跨域同源策略：是浏览器的一个安全功能，不同源的客户端脚本在没有明确的情况下，不能读写对方的资源。若地址里面的协议，域名和端口号均相同属于同源。什么情况下会遇到跨域：非同源策略的情况下会遇到跨域。跨域的解决方法：jsonp，nginx 反向代理，node.js 中间件代理跨域，后端设置 http header，后端在服务器上设置 cors。 通过 jsonp 跨域 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//原生&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res) &#123; alert(JSON.stringify(res)); &#125; &lt;/script&gt;//服务端返回onBack(&#123;\"status\": true, \"user\": \"admin\"&#125;)//jq$.ajax(&#123; url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: \"onBack\", // 自定义回调函数名 data: &#123;&#125;&#125;);//vuethis.$http.jsonp('http://www.domain2.com:8080/login', &#123; params: &#123;&#125;, jsonp: 'onBack'&#125;).then((res) =&gt; &#123; console.log(res);&#125;)//node.jsvar querystring = require('querystring');var http = require('http');var server = http.createServer();server.on('request', function(req, res) &#123; var params = qs.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, &#123; 'Content-Type': 'text/javascript' &#125;); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');//jsonp的缺点，只能实现get一种请求 后端服务器设置 12345678// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'response.setHeader( \"Access-Control-Allow-Origin\", \"http://www.domain1.com\");// 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); nginx 代理跨域 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open(\"get\", \"http://www.domain1.com:81/?user=admin\", true);xhr.send(); vue 框架跨域 12345678910111213141516module.exports = &#123; entry: &#123;&#125;, module: &#123;&#125;, ... devServer: &#123; historyApiFallback: true, proxy: [&#123; context: '/login', target: 'http://www.domain2.com:8080', // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些https服务报错时用 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 &#125;], noInfo: true &#125;&#125; location.hash+iframe 跨域 1234567891011121314&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 向b.html传hash值 setTimeout(function() &#123; iframe.src = iframe.src + '#user=admin'; &#125;, 1000); // 开放给同域c.html的回调方法 function onCallback(res) &#123; alert('data from c.html ---&gt; ' + res); &#125;&lt;/script&gt; ss 2.浏览器相关 浏览器从加载到渲染的过程，比如输入一个网址到显示页面的过程。 加载过程 浏览器根据 DNS 服务器解析得到域名的 IP 地址 向这个 ip 的机器方式 HTTP 请求 服务器收到，处理并返回 HTTP 请求 浏览器得到返回内容 渲染过程 根据 html 结构生成 DOM 数 根据 css 生成 cssom 将 DOM 和 CSSOM 整合形成 RenderTree 根据 RenderTree 开始渲染和展示 遇到时，会执行并阻塞渲染 ss","categories":[{"name":"跨域方案","slug":"跨域方案","permalink":"http://yoursite.com/categories/跨域方案/"}],"tags":[{"name":"跨域方案","slug":"跨域方案","permalink":"http://yoursite.com/tags/跨域方案/"}]},{"title":"webpack3.0","slug":"webpack3/webpack3.0","date":"2018-01-04T12:12:27.000Z","updated":"2019-06-05T12:15:15.629Z","comments":true,"path":"2018/01/04/webpack3/webpack3.0/","link":"","permalink":"http://yoursite.com/2018/01/04/webpack3/webpack3.0/","excerpt":"","text":"理解：webpack 是运用程序的模块打包器。主要用于编译，打包，转换 \b，代码分割，把第三方内库作为模板使用，模块热更新。(把 css 和 js\b 打包成浏览器能够运行的文件)package.json:是指项目配置文件node_mudules:npm 加载时所需的项目以来模块 \b 步骤 1.新建一个文件 2.建src文件 3.创建webpack.config.js 4.终端npm init 5.npm i webpack --save-dev 6.src下新建:js,css,images 7.给src新建一个静态\bhtml配置 \bwebpack.config.js 文件配置 \b注意：配置文件命名默认-config文件名指定 入口文件配置 123456var config=&#123;&#123;]件//单个文件只需配置一个\bjs，多个文件配置多个js 出口文件配置 123456output:&#123; path: path.resolve(__dirname, &apos;./dist&apos;), publicPath: WEBPACK_ENV == &apos;dev&apos; ? &apos;/dist&apos; : &quot;../&quot;, filename: &apos;js/[name].js&apos;&#125;[name]是指生成的名字是入口文件定义的名字 loader 加载器配置 1modules:&#123;loaders:[]&#125;//loader加载器 插件配置 1置 npm install cross-env –save-dev 跨平台配置 Npm i webpack-dev-server —save-dev 起一个服务 可以实时监控效果 配置 build 可以打包的命令“build”: “cross-env WEBPACK_ENV=online webpack -p” webpack.config.js 中插件 \b 配置 编译 es6 配置安装：npm install –save-dev babel-loader babel- core babel-preset-env webpack 1234567891011121314loader配置：module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;env&apos;] &#125; &#125; &#125; ]&#125; babel-loader：允许使用 babel 和 webpack 传输 js 文件Babel-core:编译 babel 的核心包 操作 html安装：npm install html-webpack-plugin –save-dev作用：1.动态的添加 css 和 js 每次 compile 之后会加上 hash，防止引用缓存的外部文件。2.可以生成 html 入口文件引入：var HtmlWebpackPlugin=require(‘html-webpack-plugin’); 1234567891011封装:var getHtmlConfig=function(name,title)&#123; return&#123; template:&apos;./src/view/&apos;+name+&apos;.html&apos;, filename:&apos;view/&apos;+name+&apos;.html&apos;, title:title, inject:true, hash:true, chunks:[&apos;common&apos;,name] &#125;&#125; 配置插件：plugins: [new HtmlWebpackPlugin(getHtmlConfig(‘login’,’登录’))] 拷贝静态资源安装：npm install –save-dev copy-webpack-plugin引入：const CopyWebpackPlugin = require(‘copy-webpack-plugin’);作用：把 webpack 下开发环境静态资源拷贝到打包文件夹下 12345new CopyWebpackPlugin([&#123;From:””定义要拷贝的资源To:定义拷贝到目标目录igore：忽略拷贝指定的文件&#125;]) 编译 less安装:npm install style-loader –save-dev 吧 js 中 css 添加到页面 style 标签中npm install css-loader –save-dev 能够使用@import 和 url（）的方法实现 require 功能。处理 js 中的 cssNpm install postcss-loader —save-dev 给 css 添加前缀npm install autoprefixer –save-dev 指定那个版本添加前缀 npm install –save-dev less-loader less 编译 less 12345添加postcss.config.js的文件,loader配置&#123; test: /\\.less|css$/, loaders: ExtractTextPlugin.extract([&apos;css-loader&apos;, &apos;postcss-loader&apos;, &apos;less-loader&apos;])&#125; 5.抽离 css安装：npm I extract-text-webpack-plugin —save-dev引入:var ExtractTextPlugin = require(‘extract-text-webpack-plugin’); 1插件配置: new ExtractTextPlugin(&quot;css/[name].css&quot;), 图片获取安装:npm i html-loader —save-dev 引入图片一定要装这个插件npm i file-loader –save-dev 处理文件Npm i url-loader —save-dev 将图片转换为字符 减少 http 请求 但是图片过大会消耗内存所以有 limit 小于 limit 字节可以转换为 dataurl 12345678910111213在output中，根据引入路径设置publicPath:’./’loader配置: &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use:[ &#123; loader:&apos;url-loader&apos;, options:&#123; limit:1000, name:&apos;img/[name].[hash:7].[ext]&apos; &#125; &#125; ] &#125; html 中引入:&lt;img src=&lt;%= require(‘../img/login_cn.png’) %&gt; alt=”login 图加载中…” class=”Welcome_use p_title” /&gt;默认情况下，每个本地的 都需要通过 require （require(‘./image.png’)）来进行加载。您可能需要在配置中为图片指定 loader（推荐 file-loader 或 url-loader ） css 压缩安装：npm I optimize-css-assets-webpack-plugin —save-dev引入：const OptimizeCSSPlugin = require(‘optimize-css-assets-webpack-plugin’) 12345插件配置:new OptimizeCSSPlugin(&#123; cssProcessorOptions: config.build.productionSourceMap ? &#123; safe: true, map: &#123; inline: false &#125; &#125; : &#123; safe: true &#125; &#125;), js 压缩uglifyjs-webpack-plugin 这个是 webpack 下面自带的不需要安装，不需要引入，直接配置 123456789插件配置:new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false//是否显示警告 &#125;, sourceMap:false,//是否要map文件 parallel: true//将js平行化 &#125;),注意：开发环境不要压缩，只是在打包环境下压缩 font 配置 12345678910loader配置:&#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name:&apos;font/[name].[hash:7].[ext]&apos; &#125;&#125;在js中引入import &apos;../../font/css/iconfont.css&apos;注意：必须在页面加icon浏览器才能有font文件 js 文件提取出来 12345插件配置:new webpack.optimize.CommonsChunkPlugin(&#123;//生产通用模块吧公共的js文件提取出来 name: &apos;common&apos;, filename: &apos;js/common.js&apos;&#125;), 11.art-template 模板使用安装:npm install art-template-loader –save-dev 1234567891011 loader配置: &#123; test: /\\.art$/, loader: &quot;art-template-loader&quot;, options: &#123; // art-template options (if necessary) // @see https://github.com/aui/art-template &#125; &#125;在页面引入模板:建立一个公共的head.html在其他页面的引入方式&lt;%=require(&apos;html-loader!./common/head.html&apos;)%&gt; 服务器热加载配置 1234567 插件配置: devServer: &#123; historyApiFallback: true, noInfo: true, overlay: true &#125;,var WEBPACK_ENV = process.env.WEBPACK_ENV || &apos;dev&apos;; 区分开发环境与生产环境 \b 一些配置理解: path：是 build 打包后的路径 。 path:path.resolve(__dirname,’./dist’) publicPath:顾名思义就是一个公共地址，用于处理静态资源引用的地址。 PurifyCSS-webpack:消除项目中不需要使用的 css 代码 webpack 优化：ProvidePlugin 和 import：CommonsChunkPlugin package.json 中配置运行与打包： 1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;cross-env WEBPACK_ENV=dev webpack-dev-server --inline --port 8088&quot;, &quot;build&quot;: &quot;cross-env WEBPACK_ENV=online webpack -p&quot; &#125;, 7.__dirname 表示相对路径","categories":[{"name":"webpack3","slug":"webpack3","permalink":"http://yoursite.com/categories/webpack3/"}],"tags":[{"name":"webpack3","slug":"webpack3","permalink":"http://yoursite.com/tags/webpack3/"}]},{"title":"css和js基础面试题","slug":"基础前端/css和js基础面试题","date":"2017-12-04T12:12:27.000Z","updated":"2019-06-05T12:15:51.627Z","comments":true,"path":"2017/12/04/基础前端/css和js基础面试题/","link":"","permalink":"http://yoursite.com/2017/12/04/基础前端/css和js基础面试题/","excerpt":"","text":"css 面试题 页面布局: 假设高度已知，请写出三栏布局，其中左右栏宽度各为 300px，中间自适应。 回答：绝对定位 浮动 弹性盒子 table 表格 grid 网格布局 5 中方案的优缺点：浮动布局会脱离文档流 绝对定位不适应。弹性盒子是最优的布局方法。 css 盒模型：标准模型+ie 模型 区别：标准模型的宽度只是内容的宽度，不包含 padding 和 border。 ie 盒模型：宽度计算 padding 和 border。 设置：box-sizing:content-box/border-box 如何去盒模型的宽度: dom.style.width/height,只能获取到内嵌方式设置的 css dom.currentStyle.width/height,兼容 IE，获取的是元素最终 css 的值（包括外部 css 文件中的 style 的值） window.getComputedStyle(dom)[‘width/height’],获取的是元素最终 css 的值（包括外部 css 文件中的 style 的值） getBoundingClientRect().width/height:表示元素各边与页面上边和左边的距离。计算元素的绝对位置。 BFC：块级格式化上下文（边距重叠） BFC 不会与 float box 发生重叠，计算 BFC 的高度时浮动元素也参与计算，在这个元素垂直的方向发生重叠。里面元素不会影响外面的元素。计算高度的时候，浮动元素也参与计算。 怎么创建 BFC：overflow:hidden float:属性不为 none position 为 absolute 和 fixed js 面试题 DOM 事件 事件级别： Element.onclick=function(){} Element.addEventListener(‘click’,function(){},false) Element.addEventListener(‘keyup’,function(){},true); 事件模型： 捕获：从上往下 冒泡：从小往上 事件流： 从页面接受事件的顺序 -&gt;事件捕获-&gt;处理目标-&gt;事件冒泡 事件捕获的流程：window-&gt;document-&gt;html-&gt;body-&gt;具体元素 event 对象的常见应用： event.preventDefault() 阻止默认事件 event.stopPropagation() event.cancelbubble()阻止冒泡 一个兼容谷歌浏览器一个兼容 ie 浏览器 event.currentTarget();返回绑定事件的元素 事件的监听者 event.target();触发事件的元素 event.stopImmediatePropagation()执行第一个事件处理程序，并阻止剩下的事件处理程序被执行。 HTTP 协议： 定义：从浏览器访问服务器传输文本域数据的。简称请求资源。 特点：简单快速，灵活，无状态，无连接。 报文的组成部分：请求报文 想要报文 方法：GET(获取资源),POST(传输资源),PUT(更新资源),DELETE(删除资源),HEDA(获取报文首部) get 与 post 的区别： get 在浏览器回退时时无害的，而 post 会再次提交 get 产生的 url 地址可以被收藏，post 不会 get 请求会被浏览器主动缓存，而 post 不会，除非手动设置 get 请求的参数会被完整的保留在浏览器历史记录，而 post 不会。 get 没有 post 安全，因为参数直接暴露在 url 上。 get 参数是通过 url 传递，post 是放在 request body 中。 HTTP 状态码： 1xx:表示请求已经接受，继续处理 2xx：成功 3xx：重定向。要完成请求必须更进一步的操作。 4xx：客户端错误 5xx：服务端错误 面向对象：概念：对象是键值对的集合特点：就是有封装，继承，多态的特点 类的创建方式： 工厂函数 1234567function create(name)&#123; var obj=new Object() obj.name=name return obj &#125; create(‘工厂名’)工厂方式优缺点：避免了大量重复的代码。但是没有解决对象识别的问题，不能决定一个对象的类别。 构造函数 12345678function Person(name,age,job)&#123; this.name=name; this.age=age; this.job=job; &#125; var p=new Person(‘二麻子‘，’18‘，’worker‘)//通过new Person实例化一个类构造函数的优缺点：解决了对象归属的问题，能够确定对象的类型，但是每个方法都要在实例上重新创建一遍，虽然函数名一样，但是不相等。影响性能。构造函数new一下做的几件事情：创建对象 将this指向这个对象 返回这个对象 原型模式 123456789function Car()&#123;&#125;Car.prototype.color = “red”;Car.prototype.doors = 4;Car.prototype.showColor = function()&#123;alert(this.color);&#125;var car1 = new Car();var car2 = new Car(); 对象实例可以访问原型中的值，但是不能重写原型中的值，如果对象实例中定义了和原型重名的属性，那么改属性就会屏蔽原型中的那个属性，但是不会重写。 类与继承 继承的本质就是原型链：借助构造函数实现继承 借助原型链实现继承 call()，Apply():用法在函数体内改变 this 的指向。不同点：obj.call(thisObj,arg1,arg2,…);Obj.apply(thisObj,[arg1,arg2]);区别：apply()接收的是数组参数,call 接收的是连续参数。 原型链 概念：主要是实现继承的方法。思路是利用原先让一个引用类型继承另一个引用类型的属性和方法。 函数对象：就是通过 new Function()的方法进行创建的。函数对象有一个 prototype 属性，这个属性是指向函数的原型对象。（每个对象都有_proto_属性，但是 prototype 只是函数对象才有的属性） constructor:默认的情况下，所有的原型对象都会自动获取 constructor(构造函数)属性，而这个属性是指向 prototype 所在的函数。注意：实例构造函数的属性 constructor 是指向构造函数的。 创建对象的方式： 字面量：var o1={name:”02”}; object 构造函数创建 var aa=new Object({name:”02”}) prototype:是指原型对象包含梳理共享的属性和方法。这个函数用作构造函数时调用，使用 new 操作符调用的时候，新创建的对象会从原型对象上得到同样的属性和方法。 proto:原型链。每个对象都有属性，但不是一个规范的属性，只是部分浏览器实现了这个属性。对应的标准应该是 prototype。简单的理解为_proto_为构造函数的原型。（即：__proto__===constructor.prototype） 原型对象：无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为改函数创建一个 prototype 的属性，这个属性指向函数的原型对象。（原型对象的用途：为每个实例对象存储共享的方法和属性。）。 a instanceof b原理：用来判断一个构造函数的 prototype 是否存在于 object 的原型链上。用来判断对象 a 是不是 b 的类型。a instanceof Array() A.__proto__===B.prototype 构造函数:当任意一个普通函数用于创建一类对象的时候，它就被称为构造函数，或者是构造器。特点：构造函数名一般大写字母开头。与 new 运算符一起实例化对象。 New 运算符： 1.一个新的对象被创建。它继承自 foo.prototype 2.构造函数 foo 被执行。执行的时候，相应的传参会被传入，同时上下文（this）被指定新实例。 3.如果构造函数 new 出来一个对象，那么这个对象会取代整个 new 出来的结果。如果构造函数没有返回对象，那么 new 出来的结果为步骤 1 创建的对象。 什么是原型链：我和我的实例对象一直往上找，构造这个实例相关联的对象，然后这个对象往上找它上一级的原型对象。直到 Object.prototype 为止。（每个对象都有自己的原型对象，原型对象本身也是对象，原型对象也有自己的原型对象，这样形成一个链式结构，叫做原型链） 作用域 js 的解析与执行过程：分为预处理阶段和执行阶段。 作用域概念： 确定一个变量，一个函数，一个成员在整个程序里面可以访问的范围。同时可以做信息隐藏。 全局作用域：对于任何内部函数来说都是可以访问的。局部作用域：只是在固定的代码片段才可以被访问。 在 js 中局部作用域高于全局作用域 变量提升：是指将声明提升到它 所在作用域的开始部分。 块作用域：被{}包含起来的一个块。js 中没有块作用域的概念。 函数作用域：是指函数内声明的所有变量在函数体内始终都是可见的。","categories":[{"name":"css和js基础面试题","slug":"css和js基础面试题","permalink":"http://yoursite.com/categories/css和js基础面试题/"}],"tags":[{"name":"css和js基础面试题","slug":"css和js基础面试题","permalink":"http://yoursite.com/tags/css和js基础面试题/"}]}]}