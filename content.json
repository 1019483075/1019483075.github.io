{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"令夕","url":"http://yoursite.com","root":"/"},"pages":[{"title":"这是自我介绍的题目","date":"2019-06-01T08:54:31.000Z","updated":"2019-06-01T08:54:55.313Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这是一段自我介绍"}],"posts":[{"title":"（八）处理CSS/SCSS文件","slug":"webpack4/（八）处理css和scss","date":"2019-06-03T15:22:47.000Z","updated":"2019-06-03T15:43:04.227Z","comments":true,"path":"2019/06/03/webpack4/（八）处理css和scss/","link":"","permalink":"http://yoursite.com/2019/06/03/webpack4/（八）处理css和scss/","excerpt":"","text":"demo8 源码地址 （一）准备工作 CSS 在 HTML 中常引入方法有&lt;link&gt;标签和&lt;style&gt;标签两种，所以就结合 webpack 特点实现以下功能： 将 css 通过 link 标签引入 将 css 放在 style 标签里 下图展示了这次代码的目录结构：这次我们要用到 css-loader，style-loader 等 loader，跟 babel 一样，webpack 不知道将 CSS 提取到文件中。需要使用 loader 来加载对应的文件 css-loader：负责解析 CSS 代码，主要是为了处理 CSS 中的依赖，例如@import 和 url()等引用外部文件的声明 style-loader: 会将 css-loader 解析的结果转变为 JS 代码，运行时动态插入 style 标签来让 CSS 代码生效。 （二）安装依赖 npm i css-loader style-loader –save-dev package.json 如下:更改配置文件 12345678910(module.exports = &#123; \"module\": &#123; \"rules\": [ &#123; \"test\": /\\.css$/, // 针对 .css 后缀的文件设置 loader \"use\": [\"style-loader\", \"css-loader\"] &#125; ] &#125;&#125;) 配置 module 中 rules 属性，和配置 babel 一样，首先在 test 中使用正则来过滤 .css 文件，对 .css 文件使用 loader，&#39;``style-loader``&#39;,``&#39;css-loader&#39; 在 base.css 中写入样式 12345678*,body &#123; margin: 0; padding: 0;&#125;html &#123; background: red;&#125; 并在 index.js 中引入 base.css 1import style from \"./css/base.css\"; 配置文件完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940const path = require(\"path\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); // 引入插件module.exports = &#123; entry: &#123; app: \"./src/app.js\" &#125;, output: &#123; publicPath: \"./\", // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"[name].bundle.js\", // 代码打包后的文件名 chunkFilename: \"[name].js\" // 代码拆分后的文件名 &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 针对 .css 后缀的文件设置 loader use: [\"style-loader\", \"css-loader\"] // 使用 loader &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; // 打包输出HTML title: \"自动生成 HTML\", minify: &#123; // 压缩 HTML 文件 removeComments: true, // 移除 HTML 中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true // 压缩内联 css &#125;, filename: \"index.html\", // 生成后的文件名 template: \"index.html\", // 根据此模版生成 HTML 文件 chunks: [\"app\"] // entry中的 app 入口才会被打包 &#125;) ]&#125;; 项目打包，查看 dist 文件夹发现并没有生成 CSS 文件，但是打开 index.html 是有样式的 原因是：style-loader，css-loader 两个 loader 处理后，CSS 代码会转变为 JS，会和 index.js 一起打包可以发现 css 是通过标签注入的 如果需要单独吧 CSS 文件分离出来，我们需要使用mini-css-extract-plugin插件。之前是使用extract-text-webpack-plugin 插件，此插件与 webpack4.0不太匹配，现在使用 mini-css-extract-plugins 确保将 webpack 更新到 4.2.2 版及以上。否则 mini-css-extract-plugin 将无效！ 目前还不支持热更新，也就是在开发环境下更改了 css，需要手动的刷新页面才会看到效果，目前这个插件一般在生产环境中使用，开发环境下还是使用‘style-loader’,具体见官网配置 1npm i mini-css-extract-plugin --save-dev 更改配置文件： 1234567891011121314151617181920212223const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, // 针对 .css 后缀的文件设置 loader use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, \"css-loader\" ] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: \"[name].css\", chunkFilename: \"[id].css\" &#125;) ]&#125;; 这样只是生成了单独的 css 文件，但是并没有压缩，引入 optimize-css-assets-webpack-plugin插件来实现 css 压缩 12&gt; npm install optimize-css-assets-webpack-plugin --save-dev&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&gt;完整代码```javascriptconst path = require(&quot;path&quot;);const CleanWebpackPlugin = require(&quot;clean-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const OptimizeCssAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;);module.exports = &#123; entry: &#123; main: &quot;./src/index.js&quot; &#125;, output: &#123; publicPath: &quot;./&quot;, // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, &quot;dist&quot;), // 打包文件的输出目录 filename: &quot;[name].bundle.js&quot;, // 代码打包后的文件名 chunkFilename: &quot;[name].js&quot; // 代码拆分后的文件名 &#125;, // optimization: &#123; // splitChunks: &#123; // chunks: &apos;all&apos;, // minSize: 30000, // maxSize: 0, // minChunks: 1, // maxAsyncRequests: 5, // maxInitialRequests: 3, // automaticNameDelimiter: &apos;~&apos;, // name: true, // cacheGroups: &#123; // lodash: &#123; // name: &apos;lodash&apos;, // test: /[\\\\/]node_modules[\\\\/]lodash[\\\\/]/, // priority: 10 // &#125;, // commons: &#123; // name: &apos;commons&apos;, // minSize: 0, //表示在压缩前的最小模块大小,默认值是 30kb // minChunks: 2, // 最小公用次数 // priority: 5, // 优先级 // reuseExistingChunk: true // 公共模块必开启 // &#125;, // vendors: &#123; // test: /[\\\\/]node_modules[\\\\/]/, // priority: -10 // &#125;, // default: &#123; // minChunks: 2, // priority: -20, // reuseExistingChunk: true // &#125; // &#125; // &#125; // &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 针对.css后缀文件设置loader // use: [&quot;style-loader&quot;, &quot;css-loader&quot;] use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, &quot;css-loader&quot; ] &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: &quot;处理CSS文件&quot;, // 打包输出HTMl minify: &#123; removeComments: true, // 一出HTML中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true // 压缩内联css &#125;, filename: &quot;index.html&quot;, // 生成后的文件名 template: &quot;index.html&quot; // 根据此模板生成HTML文件 &#125;), new MiniCssExtractPlugin(&#123; filename: &quot;[name].css&quot;, chunkFilename: &quot;[id].css&quot; &#125;), new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: /\\.css$/g, cssProcessor: require(&quot;cssnano&quot;), //用于优化\\最小化 CSS 的 CSS处理器，默认为 cssnano cssProcessorOptions: &#123; safe: true, discardComments: &#123; removeAll: true &#125; &#125;, //传递给 cssProcessor 的选项，默认为&#123;&#125; canPrint: true //布尔值，指示插件是否可以将消息打印到控制台，默认为 true &#125;) ]&#125;; 再打开 css 文件可以发现已经被压缩了，并且打开 index.html 也是有样式的 （三）处理 scss 文件 安装 sass 依赖： npm i node-sass sass-loader –save-dev 在 src 文件夹下新增 scss 文件夹及 main.scss 文件 main.scss 引入样式 123456789$bgColor: black !default;*,body &#123; margin: 0; padding: 0;&#125;html &#123; background: $bgColor;&#125; 在 index.js 中引入 main.scss 文件 12import \"./css/base.css\";import \"./scss/main.scss\"; 修改配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const path = require(\"path\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); // 将 css 单独打包成文件const OptimizeCssAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\"); // 压缩 cssmodule.exports = &#123; entry: &#123; app: \"./src/index.js\" &#125;, output: &#123; publicPath: \"./\", // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"[name].bundle.js\", // 代码打包后的文件名 chunkFilename: \"[name].js\" // 代码拆分后的文件名 &#125;, module: &#123; rules: [ &#123; test: /\\.(scss|css)$/, // 针对.css后缀文件设置loader // use: [\"style-loader\", \"css-loader\"] use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, \"css-loader\", \"sass-loader\" // 使用 sass-loader 将 scss 转为 css ] &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; title: \"处理CSS文件\", // 打包输出HTMl minify: &#123; removeComments: true, // 一出HTML中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true // 压缩内联css &#125;, filename: \"index.html\", // 生成后的文件名 template: \"index.html\", // 根据此模板生成HTML文件 chunks: [\"app\"] &#125;), new MiniCssExtractPlugin(&#123; // 从js里面吧css提取成一个css文件，插入到html中 filename: \"[name].css\", chunkFilename: \"[id].css\" &#125;), new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: /\\.css$/g, cssProcessor: require(\"cssnano\"), //用于优化\\最小化 CSS 的 CSS处理器，默认为 cssnano cssProcessorOptions: &#123; safe: true, discardComments: &#123; removeAll: true &#125; &#125;, //传递给 cssProcessor 的选项，默认为&#123;&#125; canPrint: true //布尔值，指示插件是否可以将消息打印到控制台，默认为 true &#125;) ]&#125;; module.rules.use 数组中，loader 的位置。根据 webpack 规则：放在最后的 loader 首先被执行，从上往下写的话是下面先执行，从左往右写的话是右边先执行。 1[\"style-loader\", \"css-loader\", \"sass-loader\"]; 执行顺序为sass-loader,css-loader,style-loader首先利用 sass-loader 将 scss 编译为 css，剩下的配置和处理 css 相同的文件打包后在打开 index.html 文件会发现样式已经被 main.scss 中写的覆盖了，处理 scss 成功 （四）为 css 加上浏览器前缀 安装 postcss-loader 和 autoprefixer 依赖 12&gt; npm install postcss-loader autoprefixer --save-dev&gt; 1234567891011&gt;给src/scss/main.css中添加下面的代码```css.example &#123; display: grid; transition: all 0.5s; user-select: none; background: linear-gradient(to bottom, white, black);&#125; 有两种方式来配置 postcss，第一中是直接写在 webpack.config.js 中 12345678910111213141516171819202122module: &#123; rules: [ &#123; test: /\\.(scss|css)$/, // 针对.css后缀文件设置loader // use: [\"style-loader\", \"css-loader\"] use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, \"css-loader\", &#123; loader: \"postcss-loader\", // 使用 postcss 为 css 加上浏览器前缀 options: &#123; plugins: [require(\"autoprefixer\")] &#125; &#125;, \"sass-loader\" // 使用 sass-loader 将 scss 转为 css ] &#125; ];&#125; 打包完之后,查看 dist/app.css 文件第二种方式，在 webpack.config.js 同级目录下，新建 postcss.config.js 配置文件 123module.exports = &#123; plugins: [require(\"autoprefixer\")]&#125;; 同时在 webpack.config.js 中 12345678910111213141516module: &#123; rules: [ &#123; test: /\\.(scss|css)$/, // 针对.css后缀文件设置loader // use: [\"style-loader\", \"css-loader\"] use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, \"css-loader\", \"postcss-loader\", // 使用 postcss 为 css 加上浏览器前缀 \"sass-loader\" // 使用 sass-loader 将 scss 转为 css ] &#125; ];&#125; 由于 module 中的 rules 是倒着执行的，以上的执行顺序sass-loader -&gt; postcss-loader -&gt; css-loader -&gt; MiniCssExtractPlugin.loader postcss-loader 在 css-loader 和 style-loader 之后使用，但要在其他预处理器加载器之前，例如 sass | less | stylus-loader 补充：在 css-loader 中使用 importantLoaders 属性 123456789101112131415161718192021module: &#123; rules: [ &#123; test: /\\.(scss|css)$/, // 针对.css后缀文件设置loader // use: [\"style-loader\", \"css-loader\"] use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, &#123; loader: css - loader, options: &#123; importLoaders: 2 &#125; &#125;, \"postcss-loader\", // 使用 postcss 为 css 加上浏览器前缀 \"sass-loader\" // 使用 sass-loader 将 scss 转为 css ] &#125; ];&#125; importLoaders: 2 表示：在一个 css 中引入了另一个 css，也会执行之前两个 loader，即 postcss-loader 和 sass-loader参考：webpack 官网指南","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（七）自动生成 HTML 文件","slug":"webpack4/（七）自动生成 HTML 文件","date":"2019-06-03T12:50:28.000Z","updated":"2019-06-03T12:52:21.290Z","comments":true,"path":"2019/06/03/webpack4/（七）自动生成 HTML 文件/","link":"","permalink":"http://yoursite.com/2019/06/03/webpack4/（七）自动生成 HTML 文件/","excerpt":"","text":"demo7 源码经过上面几个小节的操作，有没有觉得每次进去更改 index.html 中引入 js 文件很麻烦，一旦打包的名字变更后，也要对应的去修改 index.html 引入的 js 名称，这个时候就要使用一个插件来帮助我们，打包完之后自动生成 HTML 文件，并自动引入打包后的 js 文件** （一）安装依赖 npm i html-webpack-plugin html-loader –save-dev package.json 如下： （二）更改配置文件 12345678910111213141516module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; // 打包输出HTML title: \"自动生成 HTML\", minify: &#123; // 压缩 HTML 文件 removeComments: true, // 移除 HTML 中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true // 压缩内联 css &#125;, filename: \"index.html\", // 生成后的文件名 template: \"index.html\" // 根据此模版生成 HTML 文件 &#125;) ]&#125;; HtmlWebpackPlugin 是在 plugin 这个选项中配置的。常用参数含义如下： title：打包后生成 html 的 title filename：打包后 html 文件名称 template： 模板文件（例子源码中根目录下的 index.html） chunks：和 entry 配置中相匹配。支持多页面，多入口 minify:压缩选项 由于使用了 title 选项，则需要在 template 选项对应的 html 的 title 中加入&lt;%= htmlWebpackPlugin.options.title %&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const path = require(\"path\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); // 引入插件module.exports = &#123; entry: &#123; page: \"./src/page.js\" &#125;, output: &#123; publicPath: __dirname + \"/dist/\", // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"[name].bundle.js\", // 代码打包后的文件名 chunkFilename: \"[name].js\" // 代码拆分后的文件名 &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; // 打包输出HTML title: \"自动生成 HTML\", minify: &#123; // 压缩 HTML 文件 removeComments: true, // 移除 HTML 中的注释 collapseWhitespace: true, // 删除空白符与换行符 minifyCSS: true // 压缩内联 css &#125;, filename: \"index.html\", // 生成后的文件名 template: \"index.html\" // 根据此模版生成 HTML 文件 &#125;) ], optimization: &#123; splitChunks: &#123; chunks: \"all\", cacheGroups: &#123; lodash: &#123; name: \"chunk-lodash\", // 单独将 lodash 拆包 priority: 10, // 优先级要大于 commons 不然会被打包进 commons test: /[\\\\/]node_modules[\\\\/]lodash[\\\\/]/ &#125;, commons: &#123; name: \"chunk-commons\", minSize: 1, //表示在压缩前的最小模块大小,默认值是 30kb minChunks: 2, // 最小公用次数 priority: 5, // 优先级 reuseExistingChunk: true // 公共模块必开启 &#125; &#125; &#125; &#125;&#125;; （三）打包并测试 运行 npm run build打开 dist 文件夹里自动生成的 index.html在浏览器中打开 index.htm 文件，打开控制天也发现有输出，ok，自动生成 HTML 文件成功细心的朋友可能会发现一个问题，生成后的 HTML 文件引入的 js 为绝对路径，但是真实的项目打包完之后都是部署在服务器上面的，用绝对路径肯定不行，因为你本地电脑的绝对路径放在服务器上面肯定找不到 我们要将引入的 js 文件从绝对路基改为相对路径修改 webpack.config.js 文件找到 output 输出配置，更改 publicPath 公共路径，修改为./绝对路径 123456output:&#123; publicPath:'./', // js引用的路径或者是CDN地址 path: path.resolve(__dirname,'dist'), // 打包文件输出目录 filename: '[name].bundle.js', // 代码打包后的文件名 chunkFileName: '[name].js' // 代码拆分后的文件名&#125; 再次打包，看打包后的 index.html 文件，打开浏览器测试也是没有问题的","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（六）Lazy Loading、Prefetching","slug":"webpack4/（六）Lazy Loading、Prefetching","date":"2019-06-02T13:47:28.000Z","updated":"2019-06-02T13:54:26.252Z","comments":true,"path":"2019/06/02/webpack4/（六）Lazy Loading、Prefetching/","link":"","permalink":"http://yoursite.com/2019/06/02/webpack4/（六）Lazy Loading、Prefetching/","excerpt":"","text":"demo6 源码地址 在 demo5 的基础上修改 index.js 文件，并删除了多余的 js 文件 12345document.addEventListener(\"click\", function() &#123; import(/* webpackChunkName: 'use-lodash'*/ \"lodash\").then(function(_) &#123; console.log(_.join([\"3\", \"4\"])); &#125;);&#125;); 这段代码表示的是，当点击页面的时候，异步加载 lodash 并输出内容。 第一次进入页面的时候，并没有加载 lodash 和 use-lodash，当去点击网页的时候，浏览器在去加载，并且控制台输出内容，这就是代码懒加载，如果有用过vue-router的朋友应该会知道路由懒加载，并且官方也推荐使用懒加载的写法，就是为了结合 webpack，下图是生成的项目 其实懒加载就是通过 import 去异步的加载一个模块，具体什么时候加载，这要根据业务来写，比如弹窗组件，模态框组件等等，都是点击按钮后再出现。 懒加载能加载网页的加载速度，如果把你的详情页，弹窗页面打包到一个 js 文件中，用户如果只是访问首页，只需要首页的代码，不需要其他页面的代码，加入多余的代码只会让加载时间变长，所以我们可以对路由进行懒加载，只有当用户访问到对应路由时，再去加载对应的模块 懒加载并不是 webpack 里的概念，而是 ES6 中的 import 语法，webpack 只能识别 important 语法，能进行代码分割而已。important 后面返回的是一个 then，说明这是一个 promise 类型，一些低端浏览器不支持 promise，比如 IE ，如果要使用这种异步代码，就要使用 babel 以及 babel-polyfill 来做转换，因为我使用的是 73 版本的 chrome 浏览器，对 ES6 语法是支持的，所以我并没有安装 babel 也能使用 更改 index.js 文件 12345document.addEventListener(\"click\", function() &#123; const element = document.createElement(\"div\"); element.innerHTML = \"Hello World\"; document.body.appendChild(element);&#125;); 重新打包，并打开 index.html,打开浏览器控制台，按 ctrl + shift + p ，输入 coverage就能看到当前页面加载的 js 代码未使用率，红色区域表示未被使用的代码段 打开 coverage 如果没出现分析的文件，记得刷新一下 这里一开始红色区域的代码未被使用，当我点击了页面后，变成绿色，页面出现了 Hello World，说明代码被使用了 页面刚加载的时候，异步的代码根本就不会执行，但是我们却把它下载下来，实际上就会浪费页面执行性能，webpack 就希望像这样交互的功能，应该把它放到一个异步加载的模块去写 新建一个 click.js 文件 1234567function handleClick() &#123; const element = document.createElement(\"div\"); element.innerHTML = \"Dell Lee\"; document.body.appendChild(element);&#125;export default handleClick; 并且将 index.js 文件改为异步加载的模块 12345document.addEventListener(\"click\", () =&gt; &#123; import(\"./click.js\").then((&#123; default: func &#125;) =&gt; &#123; func(); &#125;);&#125;); 重新打包，使用 coverage 分析演示当加载页面的时候，没有加载业务逻辑，当点击网页的时候，才会加载 1.js 模块，也就是我们在 index.js 中异步引入的 click.js 这么去写代码，才是使页面加载最快的一种方式，写高性能前端代码的时候，不关是考虑缓存，还要考虑代码使用率** **所以 webpack 在打包过程中，是希望我们多写这种异步的代码，才能提升网站的性能，这也是为什么 webpack 的 splitChunks 中的 chunks 默认是 async，异步的 异步能提高你网页打开的性能，而同步代码是增加一个缓存，对性能的提升是非常有限的，因为缓存一般是第二次打开网页或者刷新页面的时候，缓存很有用，但是网页的性能一般是用户第一次打开网页，看首屏的时候。 当然，这也会出现另一个问题，当用户点击的时候，才去加载业务模块，如果业务模块较大的时候，用户点击后并没有立马看到结果，而是要等待几秒，这样体验上也不好，怎么去解决这个问题 一：如果访问首页的时候，不需要加载详情页的逻辑，等用户首页加载完以后，页面展示出来了，页面的宽带被释放出来了，网络空闲了，再「偷偷」的去加载详情页的内容，而不是等用户去点击的时候再去加载 这个解决方案就是依赖 webpack 的 Prefetching/Preloading 特性修改 index.js 12345document.addEventListener(\"click\", () =&gt; &#123; import(/* webpackPrefetch: true */ \"./click.js\").then((&#123; default: func &#125;) =&gt; &#123; func(); &#125;);&#125;); webpackPrefetch: true 会等你主要的 JS 都加载完了之后，网络带宽空闲的时候，它就会预先帮你加载好 重新打包后刷新页面，注意看 Network当网页打开的时候，main.bundle.js 被加载完了，网络空闲了，就会预先加载 1.js 耗时 14ms，等我去点击页面的时候，Network 又多了一个 1.js，耗时 2ms，这是因为第一次加载完了 1.js，被浏览器给缓存起来了，等我点击的时候，浏览器直接从缓存中取，响应速度非常快这里 这里我们使用的是 webpackPrefetch，还有一种 webpackPreload 与 prefetch 相比，Preload 指令有很多不同之处： Prefetch 会等待核心代码加载完之后，有空闲之后再去加载。Preload 会和核心的代码并行加载，还是不推荐 针对优化，不仅仅是局限于缓存，缓存能带来的代码性能提升是非常有限的，而是如何让代码的使用率最高，有一些交互后才用的代码，可以写到异步组件里面去，通过懒加载的形式，去把代码逻辑加载进来，这样会使得页面访问速度变的更快，如果你觉得懒加载会影响用户体验，可以使用 Prefetch 这种方式来预加载，不过在某些游览器不兼容，会有兼容性的问题，重点不是在 Prefetch 怎么去用，而是在做前端代码性能优化的时候，缓存不是最重要的点，最重要的是代码使用的覆盖率上(coverage)","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（一）成功学的秘密","slug":"墨菲定理/（一）成功学的秘密","date":"2019-06-01T11:54:40.000Z","updated":"2019-06-01T12:11:52.086Z","comments":true,"path":"2019/06/01/墨菲定理/（一）成功学的秘密/","link":"","permalink":"http://yoursite.com/2019/06/01/墨菲定理/（一）成功学的秘密/","excerpt":"","text":"洛克定律：确定目标，专注行动 有目标才会成功 除非你清楚自己要到哪里去，否则你永远也到不了自己想去的地方。 古希腊彼得斯说：“须有人生的目标，否则精力全属浪费。” 古罗马小塞涅卡说：“有些人活着没有任何目标，他们在世间行走，就像河中一颗小草，他们不是行走，而是随波逐流。” 在这个世界上有这样一种现象，那就是“没有目标的人在为有目标的人达到目标”。 博恩崔西说：“成功就是目标的达成，其他都是这句话的注解”。 目标要“跳一跳，够得着” 目标不是越大也好，越高越棒，而是根据自己的实际情况，制定出切实可行的目标才有效。这个目标不能太容易就能达到，也不能高到永远也碰不着，“跳一跳，够得着”最好。 千里之行始于足下，汪洋大海积于滴水。成功都是一步一步走出来的。当然也有人一页暴富，一下成名，但又有谁能看到他们之前的努力与艰辛。在俄国著名生物学家巴普洛夫临终前，有人向他请教成功的秘诀。巴浦洛夫值说了八个字：“要热诚而且慢慢来”。“热诚”，有持久的兴趣才能坚持到成功。“慢慢来”，不要急于求成，做自己力所能及的事情，然后不断提高自己：不要妄想一步登天，要为自己定一个切实可行的目标，有挑战又能达到，不断追求，走向成功。 瓦拉赫效应：成功，要懂得经营自己的长处 经营自己的长处，让人生增值 曾有一个叫奥托，瓦拉赫的人，中学时，服务为他选了文学之路，可一学期下来，老师给他的评语竟为：‘瓦拉赫很用功，但过分拘泥，这样的人即使有着完美的品德也绝不可能在文学上发挥出来。’无奈，他又改学油画，但这次得到的评语更令人难以接受：“你是绘画艺术方面不可造就之才”。面对如此“笨拙”的学生，大多数老师认为他已成才无望，只有化学老师觉得他做事情一丝不苟，这是做好化学实验应有的品格，建议他试学化学。谁料，瓦拉赫的智慧火花一下子被点燃了，并最终成为了诺贝尔化学奖的得主… 这就是人们广为传颂的“瓦拉赫效应”。承认缺憾，弥补缺陷 缺憾应该成为一种促使自己向上的激励机制，为而不恃一种自甘沉沦的理由，它暗示你在它上面应当作一点努力。 重要的并不在于你做的是什么事，而在于你应当采取某种行动。最不可取的态度是一点事情都不会去做，一味的让自己躲藏在困难的后面，动不动就被困难吓倒，这很任意让自己滋生一种自卑感，久而久之，就什么事情都不敢去做了。 木桶定律：抓最“长”的，不如抓最“短”的 克服人性“短板”，避开成事“暗礁”俗话说“人无完人”，确实，人性是存在许多弱点的，如恶习，自卑，犯错，忧虑，嫉妒等等。根据木桶定律，这些短处往往是限制我们能力的关键。就像木桶一样，一个桶能装多少水，并不是用最长的木板来衡量。而是要靠最短的木板来衡量，木桶装水的容量受到短木板的限制，所以，要想让桐木装更多的说，我们必须加长自己最短的木板。恶习我们时时刻刻都在无意间地培养着习惯，这令我们在很多情况下都要臣服于习惯。而然，好的习惯可我们效力，不好的习惯，尤其是恶习（如果拖沓，酗酒等），会在做事时严重拖我们的腿。所以，我们要学会对自己的习惯分类，对不好的习惯进行改正，完善，一面将成功毁在自己的恶习之中。自卑自卑，可以说是一种性格上的缺陷，表现为对自己能力，品质评价过低。它往往会抹杀我们的自信心，本来有足够的能力去完成学业或者是工作任务，却因怀疑自己而失败，显得处处不行，处处不如别人。所以，做事情要相信自己的能力，要告诉自己“我能行”，“我是最棒的”，那样，才能吧事情办好，走向成功。犯错人们通常不吧犯错看成是一种缺陷，甚至吧“失败乃成功之母”当成自理名言。殊不知，有两种情况下犯错就是一种缺陷。一种是不断地在一个问题上犯错误，另一种是犯错误的频率比别人高。这些错误，或许是因为他们态度问题，或许是他们做事不够细心，没有责任心导致的，但无论那种，都是成功的绊脚石。因此，平时要学会控制自己，改掉马虎大意等不良习惯；犯错后不要找托词和借口，懂得正视错误，并加以改正。忧虑有位作家曾写道，给人们造成精神压力的，并不是今天的现实，而是对昨天所发生事情的悔恨，以及对明天将要发生的事情的忧虑。没错，忧虑不仅会影响我们的心情，而且给我们的工作和学习带来更大的压力。更重要的是，无休止的忧虑并不能解决问题。所以，我们要学会控制自己的情绪，客观地去看待问题，在现实中磨炼自己的性格。妒忌妒忌是人类最普遍，最根深蒂固的感情之一。它的存在，总是令我们不能理智地，积极地做事，于是，常导致事半功倍，甚至劳而无功的结果。因此，无论在生活中，还是在工作中，我们都应平和，宽容地对待他人，客观地看待自己。虚荣每个人都有一点虚荣心，但是过强的虚荣心，使人很容易被赞美之词迷惑，甚至不能自持，很容易被对手打败。所以，我们要控制自己的虚荣，摆脱虚荣，正确地认识自己。贪婪由于太看重眼前的利益，改放弃时不能放弃，结果X成大错，甚至是悔恨终生。总所周知，很多人因太贪钱财等身外之物而毁了大好前程，有时明知是圈套，却因为抵御不住诱惑而落入陷阱。说到底，不是人不聪明，而是白给了自己的贪欲。可见，要成事，先要找对心态，知足才能常乐。 艾森豪威尔法则：分清主次，高效成事 做事分等级，先抓牛鼻子 做事要有科学地安排，要事第一，先抓住牛鼻子，然后在依照轻重缓急逐步执行，一串串，一层层地吧所有的事情拎起来，条理清晰，成效才能最显著，不要眉毛胡子一把抓。 确定事情的顺序 A：必须要做的事情； B：应该做的事情； C：量力而为的事情； D：可委托他人去做的事情； E：应该删除的工作； 每天吧要做的事情写在纸上，按以上5个类别将事情归类： A：需要做； B：应该做； C：做了也不会错； D：可以授权别人去做； E：可以省略不做； 然后根据上面归类，在每天大部分的时间里做A类和B类的事情，即使一天不能完成所有事情，只要将最值得做的事情做完就好。同样的道理，吧自己1~5年内想要做的事情列出来，然后分为A,B,C三类： A：最想做的事情； B：愿意做的事情； C：无所谓的事情； 接着，从A类目标中跳出A1,A2,A3代表最重要，次重要和第三重要的事情。在针对A类目标，抄在另外一张纸上，列出你想要达成这些目标需要做的工作，接着将这份清单在分出A,B,C等级： A：最想做的事情； B：愿意做的事情； C：做了也不会错的事情； 把这些工作放回原来的目标底下，重新调整结构，规划步骤，接着执行。 这些又被称为六步走方法，几挑选目标，设定优先次序，挑选工作，设定优先次序，安排行程，执行。把这些培养成每天的习惯，长期坚持下来并贯彻下去，相信，无数个条理性的成功慢慢积累，将会使你拥有非常成功的人生。 相关定律：","categories":[{"name":"墨菲定律","slug":"墨菲定律","permalink":"http://yoursite.com/categories/墨菲定律/"}],"tags":[{"name":"墨菲定律","slug":"墨菲定律","permalink":"http://yoursite.com/tags/墨菲定律/"}]},{"title":"（五）Code  Splitting代码分割","slug":"webpack4/（五）Code Splitting代码分割","date":"2019-05-25T13:01:59.000Z","updated":"2019-06-01T12:39:04.855Z","comments":true,"path":"2019/05/25/webpack4/（五）Code Splitting代码分割/","link":"","permalink":"http://yoursite.com/2019/05/25/webpack4/（五）Code Splitting代码分割/","excerpt":"","text":"demo5 源码地址package.json 文件所用依赖，npm install 安装： 1234567891011121314&#123; \"script\": &#123; \"dev\": \"webpack --mode development\", \"build\": \"webpack --mode production\" &#125;, \"devDependencies\": &#123; \"clean-webpack-plugin\": \"^2.0.0\", \"webpack\": \"^4.29.6\", \"webpack-cli\": \"^3.2.3\" &#125;, \"dependencies\": &#123; \"lodash\": \"^4.17.11\" &#125;&#125; 我们在 src/文件夹下创建 index.js 文件 12import _ from 'lodash'console.log(_.join(['a','b','c'])) 目录结构为：配置 webpack.config.js 文件 123456789101112131415161718let path = require('path');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; entry: &#123; main:'./src/index.js', // 入口文件 &#125;, output: &#123; publicPath: __dirname + '/dist/', // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, 'dist'), // 打包文件的输出目录 filename: '[name].bundle.js', // 代码打包后的文件名 chunkFilename: '[name].js' // 代码拆分后的文件名 &#125;, plugins: [ new CleanWebpackPlugin() // 默认情况下，此插件将删除 webpack output.path中所有的文件，以及每次重建后所有未使用的webpack的产品。 ]&#125; 运行 npm run build 打包在 index.html 中使用打包后的文件 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"./dist/main.bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用浏览器打开 index.html 文件，进入控制台，可以看到如下信息：a,b,c 如果我们再改动业务代码，将 index.js 中的代码改为 123import _ from \"lodash\";console.log(_.join([\"a\", \"b\", \"c\"], \"***\")); 再打包，刷新页面可以看到 a***b*****c** 我们引用的第三方框架和我们的业务代码一起被打包，这样会存在着什么问题假设 lodash 为 11M，业务代码也为 11M，打包后就是 2M 浏览器每次打开页面，都要先加载 2M 的文件，才能显示业务逻辑，这样会使得加载时间变长。 业务代码更新会比较频繁，第三方代码基本不会改变，这样重新打包后，假设为 2M 用户重新打开网页后，又会加载 2M 的文件 浏览器是有缓存的，如果文件没有变动的话，就不用去再发送 http 请求，直接从缓存中取，这样在刷新页面或者是第二次进入的时候可以加快网页加载的速度。 怎么解决呢？可以利用 webpack 中代码分割 在 webpack4.0 之前是使用commonsChunkPlugin来拆分公共代码，4.0 之后废弃，并用 splitChunksPlugins在使用 splitChunksPlugins 之前，首先要知道 splitChunksPlugins 是 webpack 主模块中的一个细分模块，无需 npm 引入** 现在我们来配置 webpack.config.js 文件 1234567891011121314151617181920212223let path = require(\"path\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");module.exports = &#123; entry: &#123; main: \"./src/index.js\" // 入口文件 &#125;, output: &#123; publicPath: __dirname + \"/dist/\", // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"[name].bundle.js\", // 代码打包后的文件名 chunkFilename: \"[name].js\" // 代码拆分后的文件名 &#125;, optimization: &#123; splitChunks: &#123; chunks: \"all\" &#125; &#125;, plugins: [ new CleanWebpackPlugin() // 默认情况下，此插件将删除 webpack output.path中所有的文件，以及每次重建后所有未使用的webpack的产品。 ]&#125;; 上面高亮的代码段就是告诉 webpack，要做代码分割了，这里的 chunk:‘all’是分割所有的代码，包括同步代码和异步代码，webpack 默认是 chunks: ‘async’分割异步代码。 我们使用 npm run dev 来打包开发环境下的代码，这样代码就不会压缩，方便我们来观察，可以看到代码被分割成两个文件了打开dist/main.bundle.js文件，在最底部可以看到 src/index.js，里面放的是业务逻辑代码，但是并没有 lodash 的代码 打开dist/vendors~main.js文件，在最上面可以看到 lodash 模块 再次打开页面，控制台也输出了内容，这样就实现了Code Splitting(代码分割) 其实没有 webpack 的时候，也是有代码分割的，不过是需要我们自己手动的分割，而现在使用了 webpack，通过这种配置项的方式，它会自动帮我们去做代码分割 仔细看分割完的代码名称，vendors~main.js，我们对分割完的名称进行更改 还是在 splitChunks 的配置项中，添加 cacheGroups 对象 12345678910optimization: &#123; splitChunks: &#123; chunks: 'all', cacheGroups: &#123; vendors: &#123; name: 'vendors' &#125; &#125; &#125; &#125; 再次打包就可以看到效果了，*cacheGroups *的默认配置会定义 venders 和 default test: /[\\/]node_modules[\\/]/,使用正则过滤，只有 node_modules 引入第三方库才会被分割为了验证默认配置，我们将 splitChunks 属性设置为空对象，再次打包 打包完发现只有一个文件，这是为什么？因为 chunks 默认为 async，只会分割异步的代码，而我们之前写的都是同步的代码，先 import lodash，再去写业务逻辑，现在使用异步的方式来做，将 index.js 中的代码改为如下： 123456789101112function getComponent() &#123; // 使用 异步的形式导入 lodash，default: _ 表示用 _ 代指 lodash return import(\"lodash\").then((&#123; default: _ &#125;) =&gt; &#123; var element = document.createElement(\"div\"); element.innerHTML = _.join([\"hello\", \"world\"], \"-\"); return element; &#125;);&#125;getComponent().then(element =&gt; &#123; document.body.appendChild(element);&#125;); 这里分割出了 0.js 和 main.bundle.js,0 是以 id 为编号来命名 所以一般我们设置 chunk 是为 all，异步，同步代码都在打包现在我们将 webpack 官网上的默认配置拷贝到我们的 webpack.config.js 中来分析一下 1234567891011121314151617181920212223optimization: &#123; splitChunks: &#123; chunks: 'async', minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125; webpack 代码分割的配置是这样的，比如我们要分割 jQuery 和 lodash 这样的第三方库，它会先经过 chunks、minSize、maxSize、minChunks 等等，满足条件后生成 jQuery 和 lodash 两个文件，然后放入 cacheGroup 中缓存着，再根据你在 cacheGroup 中配置的组来决定是将两个文件整合到一个文件打包，还是单独分开打包，比如上面代码中的 vendors，就是将 node_modules 中所有的第三方库都打包到 vendors.js 文件中，如果你还想继续分割可以这么做 12345678910111213141516cacheGroups: &#123; lodash: &#123; name: 'lodash', test: /[\\\\/]node_modules[\\\\/]lodash[\\\\/]/, priority: 5 // 优先级要大于 vendors 不然会被打包进 vendors &#125;, vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125;&#125; 再次打包，就可以看到 lodash 被分割出来了，以后使用第三方库都可以用这种配置来单独分割成一个 js 文件，比如 element-ui，注意设置 priority 的值很重要，优先级越高的会越先被打包如果 index.js 引入了 A.js 和 B.js，同时 A、B 又引入了 common，common 被引入了两次，可以被称为公共模块目录结构为：代码如下： 12345678910111213141516171819202122232425262728293031// a,jsimport './common'console.log('A')export default 'A'// b.jsimport './common'console.log('B')export default 'B'// common.jsconsole.log('公共模块')export default 'common'// index.jsimport './a.js'import './b.js'// 异步代码function getComponent() &#123; // 使用异步的形式导入 lodash，default: _ 表示用 _ 代指 lodash return import('lodash').then((&#123; default: _ &#125;) =&gt; &#123; var element = document.createElement('div') element.innerHTML = _.join(['hello', 'world'], '-') return element &#125;)&#125;getComponent().then(element =&gt; &#123; document.body.appendChild(element)&#125;) 上面那种异步的写法可能比较绕，现在精简一下，并且 webpack 对异步代码通过注释可以直接修改打包后的名称，以下代码全部以异步的形式引入 123456789101112// 异步代码import(/* webpackChunkName: 'a'*/ \"./a\").then(function(a) &#123; console.log(a);&#125;);import(/* webpackChunkName: 'b'*/ \"./b\").then(function(b) &#123; console.log(b);&#125;);import(/* webpackChunkName: 'use-lodash'*/ \"lodash\").then(function(_) &#123; console.log(_.join([\"1\", \"2\"]));&#125;); 将 minChunks 设置为 2，最小公用 2 次才分割 1234567891011121314151617181920212223242526272829303132333435optimization: &#123; splitChunks: &#123; chunks: 'all', minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; lodash: &#123; name: 'lodash', test: /[\\\\/]node_modules[\\\\/]lodash[\\\\/]/, priority: 10 &#125;, commons: &#123; name: 'commons', minSize: 0, //表示在压缩前的最小模块大小,默认值是 30kb minChunks: 2, // 最小公用次数 priority: 5, // 优先级 reuseExistingChunk: true // 公共模块必开启 &#125;, vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125;&#125; 这里分割出了 lodash 和我们在注释中定义的 use-lodash，前者是第三方库，后者是用第三库写的业务代码，也能被分割出来。 这里之所以会自动引入分割后的依赖，可以查看打包后的 main.bundle.js 文件 常用的配置项在下面的表格中，更多配置详情见官网 参考文章webpack4 系列教程 (三): 多页面解决方案 – 提取公共代码webpack 官网","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（四）用babel编译成 ES6","slug":"webpack4/（四）用babel编译成 ES6","date":"2019-05-24T13:01:59.000Z","updated":"2019-06-01T12:43:33.084Z","comments":true,"path":"2019/05/24/webpack4/（四）用babel编译成 ES6/","link":"","permalink":"http://yoursite.com/2019/05/24/webpack4/（四）用babel编译成 ES6/","excerpt":"","text":"demo4 源码地址 （一）了解 Babel 及生态 现代 javascript 主要是用 ES6 编写的。并非每个浏览器都知道怎么去处理 ES6。我们需要某种转换，这个转换步骤称为 transpiling(转译)。transpiling(转译)是指采用 ES6 的语法，转义为旧的浏览器可以理解的行为。 Webpack不知道如何进行转换但是有loading(加载器)：将他们视为转换器。babel-loader 是一个 webpack 的 loader（加载器），用于将 ES6 及以上的版本编译为 ES5 要开始使用loader，我们需要安装一堆依赖项，建议以 ES7 为主，升级建议 @babel/core webpack 和 babel 之前的一个桥梁 @babel/preset-env: 包含 ES6、7 等版本的语法转化规则 @babel/plugin-transform-runtime:避免 polyfill 污染全局变量，减小打包体积 @babel/polyfill:ES6 内置方法和函数转化垫片 babel-loader: 负责 ES6 的转换 如果是用 babel7 来转义，则需要安装@babel/core,@babel-preset-env 和@babel/plugin-transform-runtime,而不是 babel/core,babel-preset-env 和 babel-transform-runtime，他们是用于 babel6 的。 使用@babel/plugin-transform-runtime 的原因：Babel 使用非常小的功能才完成常见的功能。默认情况下，这将添加到需要他的每个文件中。这种重复有时是不必要的，尤其是当你的应用程序分布在多个文件上的时候。transform-runtime 可以重复使用 Babel 注入的程序代码来节省代码，减小开支。 > 使用@babel/polyfill的原因：Babel默认只转换javascript的句法（syntax），而不转换新的**API,比如Iterator,Generator,Set,Maps,Proxy,Reflect,Symbol,Promise等全局对象,**以及一些定义在全局对象上的方法（比如Object.assgin）都不会转码。必须要使用**@babel/polyfill，**为当前环境提供一个垫片。所谓垫片也就是垫平不同浏览器或者不同环境下的差异。 （二）安装依赖或配置 1.安装依赖 npm i @babel/core babel-loader @babel/preset-env @babel/plugin-transform-runtime –save-devnpm i @babel/polyfill @babel/runtime 2.在项目的根目录中创建名.babelrc 的新文件来配置 Babel; 1234&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; 如果遇到如下错误： 123456WARNING: We noticed you're using the `useBuiltIns` option without declaring a core-js version. Currently, we assume version 2.x when no version is passed. Since this default version will likely change in future versions of Babel, we recommend explicitly setting the core-js version you are using via the `corejs` option.You should also be sure that the version you pass to the `corejs` option matches the version specified in your `package.json`'s `dependencies` section. If it doesn't, you need to run one of the following commands: npm install --save core-js@2 npm install --save core-js@3 yarn add core-js@2 yarn add core-js@3 不仅仅要安装 npm install –save core-js@3 还需要设置 .babelrc 设置 “corejs”: 3 123456789101112&#123; \"preset\": [ [ \"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\", \"corejs\": 3 &#125; ] ], \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; 3.webpack 配置 loader（加载器） 1234567891011module:&#123; rules: [ &#123; test: /\\.js$/, // 使用正则来匹配js文件 exclude: /node_modules/, // 排除依赖包文件 use: &#123; loader: 'babel-loader' //使用babel-loader &#125; &#125; ]&#125; webpack.config.js 配置：4.在 app.js 全局引入@babel/polyfill 并写入 ES6 语法，并执行 npm run build 打包 12345678910111213// 全局引入import '@babel/polyfill'// 测试ES6语法是否通过babel转义const array = [1,2,3]const isES6 = () =&gt; console.log(...array)isES6()const arr = [new Promise(() =&gt; &#123;&#125;),new Promise(() =&gt; &#123;&#125;)]arr.map(item =&gt; &#123; console.log(item)&#125;) 5.打包完之后使用IE 浏览器打开 index.html 文件，看控制台是否有输出，如果是新版的 chrome，是可以使用 es6 语法的，所以要用IE 这个浏览器试试 更改.babelrc，只转译我们使用到的 123456789101112&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\", \"corejs\": 2 &#125; ] ], \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; 同时，将全局引入这段代码注释掉在打包 12// 全局引入js// import '@babel/polyfill' 体积就减小了很多，但是更多的情况是我们并不确切的知道项目中引发兼容性的具体原因，所以还是全局的引入比较好。 （三）了解.browserslistrc 配置文件 browserslistrc 用于在不同前端工具之间共享目标浏览器和 Node.js 版本的配置可以看看 browserslist 兼容浏览器的页面当您将一下内容添加到 package.json 时，所有工具都会自动找到目标浏览器 12345\"browserslist\": [ \"&gt; 1%\", \"last 2 version\", \"not ie &lt;= 8\"] 也可以创建.browserslistrc 文件单独写配置 # 所支持的浏览器版本 1% #全球使用统计选择的浏览器版本样式last 2 version #每个浏览器的最后两个版本not ie &lt;= 8 排除小于 ie8 一下的浏览器 该项目还是使用单独创建配置文件的方式，便于理解，如果觉得配置文件不好，也可以写在 package.json 中 参考文献 webpack4 系列教程 (二): 编译 ES6babel 7 的使用的个人理解babel 7 升级建议browserslist","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（三）覆盖默认entry和output","slug":"webpack4/（三）覆盖默认entry和output","date":"2019-05-23T13:01:59.000Z","updated":"2019-06-01T12:39:16.939Z","comments":true,"path":"2019/05/23/webpack4/（三）覆盖默认entry和output/","link":"","permalink":"http://yoursite.com/2019/05/23/webpack4/（三）覆盖默认entry和output/","excerpt":"","text":"demo3 源码地址 1.检验 webpack 规范支持webpack 支持 ES6，CommonJS，AMD 规范创建 wendor 文件夹，其中 minus.js,multi.js 和 sum.js 分别用 CommonJS，AMD，ES6 规范编写 1234567891011121314151617// CommonJS minus.jsmodule.exports = function(a, b) &#123; return a - b;&#125;;// AMD multi.jsdefine([\"require\", \"dependency\"], function(require, factory) &#123; \"use strict\"; return function(a, b) &#123; return a * b; &#125;;&#125;);// ES6 sum.jsexport default function(a, b) &#123; return a + b;&#125; 在 index.js 中引入以上三个文件 2.编写配置文件覆盖 entry/outputwebpack.config.js 是 webpack 默认配置的文件名，在根目录下创建： 1234567891011let path = require(\"path\");module.exports = &#123; entry: \"./src/index.js\", // 入口文件 output: &#123; path: path.resolve(__dirname, \"dist\"), // __dirname 是指webpack.config.js的绝对路径 dist 是指出口的目录 filename: \"bundle.js\", // 打包输出的文件夹的文件名 publicPath: __dirname + \"/dist/\" // 打包后的文件夹 &#125;, module: &#123;&#125;, plugins: []&#125;; path.resolve() 方法会把一个路径或者是路径片段的序列解析为一个绝对路径__dirname：当前模板的文件夹名称。 可以使用 console.log 输出下就明白了执行 npm run build 打包 js 文件会发现生成了 dist 文件，并且生成了两个打包后的文件 这跟 AMD 的引入方式有关，如果在 app.js 中注释掉 AMD 的写法，则只会打包出一个 bundle.js 文件 在实际写代码的时候，最好使用 ES6 和 CommonJS 的规范来写 当你注释 AMD 后，打包后的 dist 中有多个文件，这是因为打包的时候没有先删除掉 dist 文件，在打包，我们需要使用一个插件来帮助我们实现：github 链接：clear-webpack-plugin1.安装插件npm install clean-webpack-plugin –save-dev2.修改 webpack 配置文件 1234567891011121314let path = require(\"path\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");module.exports = &#123; entry: \"./src/index.js\", // 入口文件 output: &#123; path: path.resolve(__dirname, \"dist\"), // __dirname 是指webpack.config.js的绝对路径 bundle 是指出口的文件名 filename: \"bundle.js\", // 打包输出的文件夹的文件名 publicPath: __dirname + \"/dist/\" // 打包后的文件夹 &#125;, module: &#123;&#125;, plugins: [ new CleanWebpackPlugin() // 默认情况下，此插件将删除 webpack output.path中所有的文件，以及每次重建后所有未使用的webpack的产品。 ]&#125;; 之后在执行 npm run build 就可以了 打包后的 js 文件会按照我们的配置放在 dist 目录下，创建一个 html 文件，引用打包好的 js 文件，打卡 F12 就能看到效果了。 参考文献 webpack4 系列教程 (一): 打包 JSWebpack4 教程：从零配置到生产模式","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（二）生产和开发模式","slug":"webpack4/（二）生产和开发模式","date":"2019-05-22T13:01:59.000Z","updated":"2019-06-01T12:39:20.459Z","comments":true,"path":"2019/05/22/webpack4/（二）生产和开发模式/","link":"","permalink":"http://yoursite.com/2019/05/22/webpack4/（二）生产和开发模式/","excerpt":"","text":"demo2 源码记录拥有 2 个配置文件在 webpack 中是常见的模式。一个典型的项目可能有： 用于开发的配置文件，配置热更新，跨域配置，端口设置等。 用于生产的配置文件，配置 js 压缩，代码拆分等。 虽然在较大的项目可能任然需要 2 个配置文件，但是在 webpack4.0 中，你可以在没有一行配置的情况下完成。 细心的朋友会发现在 npm run build 打包后会有一段报警提示‘mode’选项尚未设置，webpack 将会退到‘production’。将‘mode’选项设置为‘development’或者‘production’以启用每个环境的默认值。你还可以将其设置为‘none’以禁止任何默认行为。 1.打开 package.json 并填充 script 部分，如下所示： 12\"dev\": \"webpack --mode development\",\"build\": \"webpack --mode production\", 2.运行 npm run dev 打开./build/bundle.js，是一个 bundle（包）文件，并没有压缩！ 3.运行 npm run build可以看到./build/bundle.js 文件已经压缩了 其实在终端里面发现，看构建完的大小，dev 模式下文件大小是 3.81KB,build 模式下文件大小仅为 966 字节 production mode（生成模式）可以开箱即用地进行各种优化。包括压缩，作用域提升，tree-shaking 等。另一方面，development mode(开发模式）针对速度进行了优化，仅仅提供了一种不压缩的 bundle。 在 webpack4.0 中,可以在没有一行配置的情况下完成任务！只需定义-mode 的参数即可获得所有内容！","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（四）拆分组件与组件之前的传值","slug":"react/（四）拆分组件与组件之前的传值","date":"2019-05-22T12:01:59.000Z","updated":"2019-06-01T13:53:52.331Z","comments":true,"path":"2019/05/22/react/（四）拆分组件与组件之前的传值/","link":"","permalink":"http://yoursite.com/2019/05/22/react/（四）拆分组件与组件之前的传值/","excerpt":"","text":"1.react组件拆分的重要性模块化，组件化，提高性能，方便维护。 2.父组件给子组件传递数据1234567// 通过属性的方式进行传递//1.父组件定义属性&lt;div&gt; &lt;TodoItem info=&#123;item&#125;/&gt; &lt;/div&gt;//2.子组件通过this.props.属性 的方式接受属性 &lt;div onClick=&#123;this.handClick&#125;&gt;&#123;this.props.info&#125;&lt;/div&gt; 3.子组件调用父组件的方法传递数据1234567891011// 父组件 &lt;div&gt; &lt;TodoItem info=&#123;item&#125; index=&#123;index&#125; deleteItem=&#123;this.handItemDelete.bind(this)&#125;/&gt; // 父组件必须绑定this&lt;/div&gt;// 子组件 handClick()&#123; this.props.deleteItem(this.props.index) &#125; 4.优化方式 代码的优化 123456789101112131415const &#123;info&#125; = this.propsreturn(&lt;div onClick=&#123;this.handClick&#125;&gt;&#123;info&#125;&lt;/div&gt;)// 等价于return(&lt;div onClick=&#123;this.handClick&#125;&gt;&#123;this.props.info&#125;&lt;/div&gt;) const &#123;deleteItem,index&#125; = this.props deleteItem(index) // 等价于 this.props.deleteItem(this.props.index) 一般引入方式的优化 style.css样式是在组件之后引入的 .bind(this)的绑定一般放在顶部 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import React,&#123;Component,Fragment &#125; from 'react';import TodoItem from './TodoItem';import './style.css';class TodoList extends Component&#123; constructor(props) &#123; super(props); //负责存储组件里面的数据 this.state = &#123; inputValue: '', list: ['学习英文', '学习中文'] &#125; this.handleInputChange = this.handleInputChange.bind(this) this.handBtnClick = this.handBtnClick.bind(this) this.handItemDelete = this.handItemDelete.bind(this) &#125; render() &#123; return( &lt;Fragment&gt; &lt;div&gt; &#123; //下面是一个输入框 &#125; &lt;label htmlFor=\"insertArea\"&gt;输入内容&lt;/label&gt; &lt;input id=\"insertArea\" className='input' value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;button onClick=&#123;this.handBtnClick&#125;&gt; 按钮 &lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item,index) =&gt; &#123; return ( &lt;div&gt; &lt;TodoItem info=&#123;item&#125; index=&#123;index&#125; deleteItem=&#123;this.handItemDelete&#125;/&gt; &#123;/* &lt;li key=&#123;index&#125; onClick=&#123;this.handItemDelete.bind(this,index)&#125; // dangerouslySetInnerHTML=&#123;&#123; __html: item &#125;&#125; &gt; &#123;item&#125; &lt;/li&gt;*/&#125; &lt;/div&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; handleInputChange(event) &#123; // event.persist(); // console.log(this);// 打印this指向 this.setState (&#123; // react中修改数据项的值要使用setState inputValue: event.target.value &#125;) &#125; handBtnClick() &#123; this.setState (&#123; list: [...this.state.list,this.state.inputValue], inputValue: '' &#125;) &#125; handItemDelete(index) &#123; // immutable // state不允许我们做任何的改变 const list = [...this.state.list]; list.splice(index, 1); this.setState(&#123; list: list &#125;) &#125;&#125;export default TodoList; setState的最新语法写法 123456789101112handleInputChange(event) &#123; // event.persist(); this.setState (&#123; // react中修改数据项的值要使用setState inputValue: event.target.value &#125;)&#125;// 最新写法this.setState(()=&gt;&#123; return&#123; inputValue: event.target.value &#125;&#125;) 结构赋值的简写形式 123this.setState(() =&gt; (&#123; list //等价于list:list是es6的简写形式&#125;))","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"（一）搭建项目并打包JS文件","slug":"webpack4/（一）搭建项目并打包JS文件","date":"2019-05-21T13:01:59.000Z","updated":"2019-06-01T12:39:12.011Z","comments":true,"path":"2019/05/21/webpack4/（一）搭建项目并打包JS文件/","link":"","permalink":"http://yoursite.com/2019/05/21/webpack4/（一）搭建项目并打包JS文件/","excerpt":"","text":"依赖环境：os:win10node:10.5.0npm:6.1.0webpack:4.29.6webpack-cli:3.2.4每个知识点对应一个 demo，clone 源码后运行 npm install 安装依赖 1.搭建项目并且打包 js 文件demo1 源码地址创建空文件夹，通过运行一下命令进行初始化 package.json:npm init npm int 用来初始化生成一个新的 package.json 文件。他会向用户提一系列问题，如果不觉得不需要修改默认配 置，一路回车就可以了。如果使用了-y（代表 yes），则跳过了提问阶段，直接生成一个新的 package.json 文 件。引入 webpacknpm i webpack –save-dev还需要 webpack-cli，作为一个单独的包引入，如果不装 webpack-cli 是无法在命令行里面使用 webpack 的npm i webpack-cli –save-dev该项目 webpack 的版本如下： 12\"webpack\": \"^4.32.0\",\"webpack-cli\": \"^3.3.2\" 现在打开 package.json 并且添加一个 build（构建）脚本： 尝试运行看看会发生什么：npm run build 在 webpack4.0 版本中，必须在名为 webpack.config.js 的配置文件中，通过 entry 属性定义 entry point（入口点），就行这样： 从 webpack4.0 开始，就不必在在定义 entry point（入口点）：它默认为./src/index.js测试这个功能前，首先创建.src/index.js 文件 在次运行 npm run build 试试： 打包成功，并且在当前的根目录中得到打包后的文件夹，也就是 build 文件夹： 讲查找./src/index.js 作为默认入口点。而且，他会在./build/bundle.js 中输出模块包，目前代码量小，可以格式化看看效果：至此，打包 js 结束参考：webpack 官网入门","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（三）react的jsx语法理解","slug":"react/（三）react的jsx语法理解","date":"2019-05-20T12:01:59.000Z","updated":"2019-06-01T13:54:28.204Z","comments":true,"path":"2019/05/20/react/（三）react的jsx语法理解/","link":"","permalink":"http://yoursite.com/2019/05/20/react/（三）react的jsx语法理解/","excerpt":"","text":"1.jsx语法怎么添加注释1234567// render函数里面的代码就是jsx语法// 大写字母开头的标签就是组件，其他的标签都是元素&lt;Fragment&gt;&lt;/Fragment&gt; // 单行注释的写法&#123;//注释内容&#125;// 多行注释的写法&#123;/*注释内容*/&#125; 2.react的class命名注意点 在react中class是类的概念所以在react中class的写法要改成className。3.dangerouslySetInnerHTML理解dangerouslySetInnerHTMl 是React标签的一个属性，类似于angular的ng-bind3.既可以插入DOM，又可以插入字符串；4.label标签的用法扩大聚焦的一个范围，例如：点击label标签文字会聚焦到input标签 1234567891011121314// input定义一个id名 label的htmlfor属性对应到该id名&lt;div&gt; &#123; //下面是一个输入框 &#125; &lt;label htmlFor=\"insertArea\"&gt;输入内容&lt;/label&gt; &lt;input id=\"insertArea\" className='input' value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; /&gt; &lt;button onClick=&#123;this.handBtnClick.bind(this)&#125;&gt;按钮&lt;/button&gt;&lt;/div&gt;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"（二）响应设计思想与事件绑定","slug":"react/（二）响应设计思想与事件绑定","date":"2019-05-18T12:01:59.000Z","updated":"2019-06-01T13:54:35.731Z","comments":true,"path":"2019/05/18/react/（二）响应设计思想与事件绑定/","link":"","permalink":"http://yoursite.com/2019/05/18/react/（二）响应设计思想与事件绑定/","excerpt":"","text":"1.react的新建组件12345678important React from 'react'class App extends React.Components&#123; //新建一个react组件 render()&#123; return( &lt;div&gt;hello&lt;/div&gt; ) &#125;&#125; 2.react的jsx语法 3.Fragment：在react的最外层包一个div隐藏掉的方法。1234567891011121314151617181920import React,&#123;Component,Fragment &#125; from 'react';class TodoList extends Component&#123; render() &#123; return( &lt;Fragment className=\"TodoList\"&gt; &lt;div&gt; &lt;input/&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;学英语&lt;/li&gt; &lt;li&gt;learn React&lt;/li&gt; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125;&#125;export default TodoList; 4.react的响应设计思想与事件绑定思路;操作的是数据层不是Dom操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React,&#123;Component,Fragment &#125; from 'react';class TodoList extends Component&#123; constructor(props) &#123; super(props); //负责存储组件里面的数据 this.state = &#123; inputValue: '', list: ['学习英文', '学习中文'] &#125; &#125; render() &#123; return( &lt;Fragment&gt; &lt;div&gt; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; /&gt; &lt;button onClick=&#123;this.handBtnClick.bind(this)&#125;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item,index) =&gt; &#123; return ( &lt;li key=&#123;index&#125; onClick=&#123;this.handItemDelete.bind(this,index)&#125; &gt; &#123;item&#125; &lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; handleInputChange(event) &#123; // event.persist(); // console.log(this);// 打印this指向 this.setState (&#123; // react中修改数据项的值要使用setState inputValue: event.target.value &#125;) &#125; handBtnClick() &#123; this.setState (&#123; list: [...this.state.list,this.state.inputValue], inputValue: '' &#125;) &#125; handItemDelete(index) &#123; // immutable // state不允许我们做任何的改变 const list = [...this.state.list]; list.splice(index, 1); this.setState(&#123; list: list &#125;) &#125;&#125;export default TodoList;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"（一）react开发目录介绍","slug":"react/（一）react开发目录介绍","date":"2019-05-17T13:01:59.000Z","updated":"2019-06-01T13:54:23.769Z","comments":true,"path":"2019/05/17/react/（一）react开发目录介绍/","link":"","permalink":"http://yoursite.com/2019/05/17/react/（一）react开发目录介绍/","excerpt":"","text":"demo 源码地址 react 简介React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在 2013 年 5 月开源了。由于 React 的设计思想极其独特，属于革命性创新，性能出众，代码逻辑却非常简单。所以，越来越多的人开始关注和使用，认为它可能是将来 Web 开发的主流工具。ReactJS 官网地址：http://facebook.github.io/react/Github 地址：https://github.com/facebook/react。 React 特点 1.声明式设计 −React 采用声明范式，可以轻松描述应用。 2.高效 −React 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互。 3.灵活 −React 可以与已知的库或框架很好地配合。 4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。 5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。 6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 脚手架工具安装与运行下载 node 安装包查看 npm 安装包react 全局安装的脚手架工具：npm install -g create-react-app初始化一个项目：create-react-app projectName成功后的提示然后 cd 项目目录yarn start 项目启动成功 react 项目目录认识1234567891011121314151617#项目结构├── node_modules 包含了react下的组件 项目启动页面，react比较适合单页开发，所以暂时只包含一个index.html，是react的入口页面│ ├────favicon.ico 图片│ ├────index.html 项目入口│ └────manifest.json 5+移动App的配置 app的快捷方式的图片和网址的定义├─- src 开发目录│ ├───—App.css 组件的css│ ├───—App.js 负责页面显示内容│ ├───—App.test.js 自动化的测试的文件│ ├───—index.js 整个程序的入口文件│ ├───—logo.svg 图片│ └────serviceWorker.js├── .gitignore git那些文件不需要添加到版本管理├── package.json 项目所需要的各种模块，配置信息├── yarn.lock 项目依赖安装包的版本号md 项目的说明文件，使用markdown的语法。 index.js 文件的基本理解123456789import React from \"react\";import ReactDOM from \"react-dom\";import App from \"./App\"; //APP来自APP.js文件// registerServiceWorker 是指将网页打开运行一半时，将网页关闭。可以将网页保存在浏览器内。再次打开可以继续访问。import * as serviceWorker from \"./serviceWorker\"; //借助网页写手机app的效果// PWA progressive web applicationReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\"));serviceWorker.unregister(); App.js 文件的基本理解1234567891011121314import React, &#123; Component &#125; from \"react\";// import './App.css';class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt;hello person&lt;/header&gt; &lt;/div&gt; ); &#125;&#125;export default App;","categories":[{"name":"react","slug":"react","permalink":"http://yoursite.com/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"JYSHT-跳转同一页面判断","slug":"vue/JYSHT-跳转同一页面判断","date":"2018-07-15T13:50:59.000Z","updated":"2019-06-01T13:34:53.754Z","comments":true,"path":"2018/07/15/vue/JYSHT-跳转同一页面判断/","link":"","permalink":"http://yoursite.com/2018/07/15/vue/JYSHT-跳转同一页面判断/","excerpt":"","text":"例如：交易所后端的法币增值税，跳转到新增和修改页面。但是新增和修改同为一个页面的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445461.可以通过路由的一个type来判断&#123; path: '/exchange/new', component: ExchangeNew, name:'ExchangeNew_f', props: &#123; type: 'new'//type判断是新增还是修改 &#125;, hidden: true,&#125;,&#123; path: '/exchange/edit/:id', component: ExchangeNew, name:'ExchangeEdit_f', props: &#123; type: 'edit' &#125;, hidden: true,&#125;2.在既是新增又是修改的页面定义prop接受router下的propprops: &#123; type: String&#125;,3.页面文字显示不同的定义 &lt;el-breadcrumb-item &gt;&#123;&#123;type === 'edit' ? '修改' : '新增'&#125;&#125;&lt;/el-breadcrumb-item&gt;提交接口根据页面自动调用对应的接口 handleSubmit()&#123; //是新增接口 exchangeNew 修改接口exchangeUpdate let exce = this.type === 'new' ? api.exchangeNew : api.exchangeUpdate exce(this.form).then(res =&gt; &#123; console.log(res); if(res.status.code===0)&#123; this.$message.success(&#123; showClose: true, message: '提交成功', duration: 2000 &#125;); &#125;else&#123; this.$message.error(&#123; showClose: true, message: res.status.msg, duration: 2000 &#125;); &#125; &#125;)&#125;,","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"组件生命周期与组件传值","slug":"vue/组件生命周期与组件传值","date":"2018-05-30T15:29:59.000Z","updated":"2019-06-01T13:04:25.234Z","comments":true,"path":"2018/05/30/vue/组件生命周期与组件传值/","link":"","permalink":"http://yoursite.com/2018/05/30/vue/组件生命周期与组件传值/","excerpt":"","text":"组件生命周期与组件传值 1.组件生命周期 https://segmentfault.com/a/1190000008010666 beforeCreate:组件实例刚刚被创建，组件属性刚刚创建，计算属性之前。 Created：组件实例创建完成，属性已经绑定，但是 dom 还未生成，$el 属性还不存在。 beforeMounted:编译挂载之前，完成了 data 和 el 初始化。 Mounted:编译挂载之后。 beforeUpdate:组件更新之前。 Updated:组件更新之后。 actived：keep-alive，组件被激活时调用 deactived：keep-alive 组件被溢出时调用 beforeDestory:组件销毁之前。 Destroyed:组件销毁之后。 activated（）：keep-alive 组件激活时，该钩子在服务器端渲染期间不被调用 deactivated（）：keep-alive 组件停用时调用。该钩子在服务端渲染期间不被调用。 keep-alive:https://www.cnblogs.com/sysuhanyf/p/7454530.html概念：是 vue 的内置组价，能在组件切换过程中将状态保存在内存中，防止重复渲染 Dom ### 2.父子组件之间传值 父组件给子组件传值:props 12345678910111213141516171819202122232425262728//1.在父组件的子组件中定义singerDatas变量名，吧singer赋值给singerDatas&lt;div class=\"singer\"&gt; &lt;v-singerlist :singerDatas=\"singers\"&gt;&lt;/v-singerlist&gt; &lt;/div&gt; data () &#123; return &#123; singers: [] &#125; &#125;,//2.在singerList子组件的props中接受父组件传的值,singerDatas。必须是singerDatasprops: &#123; singerDatas: &#123; type: Array, default: () =&gt; [] &#125; &#125;,//3.在子组件的组件中定义变量名接受传递的数据，使用。&lt;scroll :singerInfos=\"singerDatas\" &lt;ul&gt; &lt;li v-for=\"group in singerDatas\" :key=\"group.id\" ref=\"listGroup\" class=\"list_group\"&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/scroll&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748492. 子组件给父组件传值：$emit 1. ```php//vm.$emit(event,arg);是指子组件可以通过是￥emit触发父组件的自定义事件//子组件&lt;template&gt; &lt;div class=&quot;train-city&quot;&gt; &lt;h3&gt;父组件传给子组件的toCity:&#123;&#123;sendData&#125;&#125;&lt;/h3&gt; &lt;br/&gt;&lt;button @click=&apos;select(`大连`)&apos;&gt;点击此处将‘大连’发射给父组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&apos;trainCity&apos;, props:[&apos;sendData&apos;], // 用来接收父组件传给子组件的数据 methods:&#123; select(val) &#123; let data = &#123; cityname: val &#125;; this.$emit(&apos;showCityName&apos;,data);//select事件触发后，自动触发showCityName事件 &#125; &#125; &#125;&lt;/script&gt;//父组件&lt;template&gt; &lt;div&gt;父组件的toCity&#123;&#123;toCity&#125;&#125;&lt;/div&gt; &lt;train-city @showCityName=&quot;updateCity&quot; :sendData=&quot;toCity&quot;&gt;&lt;/train-city&gt;&lt;template&gt;&lt;script&gt; import TrainCity from &quot;./train-city&quot;; export default &#123; name:&apos;index&apos;, components: &#123;TrainCity&#125;, data () &#123; return &#123; toCity:&quot;北京&quot; &#125; &#125;, methods:&#123; updateCity(data)&#123;//触发子组件城市选择-选择城市的事件 this.toCity = data.cityname;//改变了父组件的值 console.log(&apos;toCity:&apos;+this.toCity) &#125; &#125; &#125;&lt;/script&gt; vuex 的传值方法 12345678910111213141516171819202122//1.src下新建一个store文件夹//2.store文件夹下新建：state.js,mutations.js,mutation-type.js,getter.js,action.js,index.js//3.index.jsimport Vue from 'vue'import Vuex from 'vuex'import state from './state'import mutations from './mutations'import getters from './getters'import actions from './actions'// 此处的变量名命名必须小写，不能大写 大写的渲染不了Vue.use(Vuex)const store = new Vuex.Store(&#123; state, mutations, getters, actions&#125;)export default store//state.js下export default &#123; count: 0, price: 100&#125; export default state//mutation-types.js 下//mutation-type.js 这个文件的目的是声明整个项目用于修改 state 方法有哪些export const COUNT = ‘COUNT’//mutations.js 下import _ as types from ‘./mutation-types’export default{[types.COUNT] (state, count) {state.count = count} }export default mutations//getters.jsexport default{total: state =&gt; {return state.count _ state.price} }//actions.jsimport * as types from ‘./mutation-types’export default{actionCount ({commit}, count) {commit(types.COUNT, count)} } 12","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"router-link与redirect用法","slug":"vue/router-link与redirect用法","date":"2018-05-30T15:29:59.000Z","updated":"2019-06-01T13:35:10.029Z","comments":true,"path":"2018/05/30/vue/router-link与redirect用法/","link":"","permalink":"http://yoursite.com/2018/05/30/vue/router-link与redirect用法/","excerpt":"","text":"https://www.cnblogs.com/SamWeb/p/6610733.html 1.router-link : 简单的定死路由跳转：:路由跳转，将组件映射到路由。 123456789101112131415161718192021&lt;!--route:是指一条路由（Home按钮 =&gt; home内容） --&gt;&lt;!--routes:是指一组路由：把每一条路由组合起来组合成一个数组[&#123;home 按钮 =&gt;home内容 &#125;， &#123; about按钮 =&gt; about 内容&#125;]--&gt;&lt;!--router：是一个记住，相当于管理者，管理路由。--&gt;1.vue写法&lt;!--&lt;router-link&gt; 就是定义页面中点击的部分 to是指点击之后跳转到哪里去指定链接 &lt;router-view&gt; 定义显示部分--&gt;&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;&lt;router-link to=\"/foo\"&gt;Go to Foo&lt;/router-link&gt;&lt;router-link to=\"/bar\"&gt;Go to Bar&lt;/router-link&gt;2.router中的index.js配置路由配置&lt;!--1.单个路由用route多个路由用routes--&gt;&lt;!--2.引入组件：import Reaconmend from '../views/reaconmend/reaconmend.vue' --&gt;&lt;!--3.path是指路径 component是指组件--&gt;Vue.use(VueRouter);// 要告诉 vue 使用 vueRouter const routes = [ &#123; path:'/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125; ]3.最后创建router对路由进行管理，它是有构造函数new vueRouter()创建，接受routes 参数。 const router = new VueRouter(&#123; routes // routes:routes 的简写 &#125;)4.创建完成后，把router实例注入到vue跟实例中，就是main.js文件。就可以使用路由了。const app = new Vue(&#123; router &#125;).$mount('#app')&lt;!--执行过程：当用户点击 router-link 标签时，会去寻找它的 to 属性， 它的 to 属性和 js 中配置的路径&#123; path: '/home', component: Home&#125; path 一一对应，从而找到了匹配的组件， 最后把组件渲染到 &lt;router-view&gt; 标签所在的地方。所有的这些实现才是基于hash 实现的。--&gt;注意：要安装vue-router但是vue-cli有配置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647482. 嵌套路由：是指点击进入一个页面后下面还有分类还有跳转。 1. ```html在路由设计上先进入home页面，在进入下面的phone子页面。所以vue需要childrens属性1.vue&lt;template&gt; &lt;div&gt; &lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt; &lt;p&gt; &lt;router-link to=&quot;/home/phone&quot;&gt;手机&lt;/router-link&gt; &lt;router-link to=&quot;/home/tablet&quot;&gt;平板&lt;/router-link&gt; &lt;router-link to=&quot;/home/computer&quot;&gt;电脑&lt;/router-link&gt; &lt;/p&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;2.index.jsconst routes = [ &#123; path:&quot;/home&quot;, component: home, // 子路由 children: [ &#123; path: &quot;phone&quot;, component: phone &#125;, &#123; path: &quot;tablet&quot;, component: tablet &#125;, &#123; path: &quot;computer&quot;, component: computer &#125;， // 当进入到home时，下面的组件显示 因为当刚刚进入时他children对应的路由为空。 &#123; path: &quot;&quot;, component: phone &#125; ] &#125;, &#123; path: &apos;/&apos;, redirect: &apos;/home&apos; &#125;] 动态路由：就是登陆页面除了名字不同其他是相同的跳转的是同一个组件。假设一个 user 组件，不同用户(用户的 id)会导航到同一个 user 组件中。就是 path 属性不能写死。 1234567891011121314151617181920212223242526272829303132333435363738394041424344在vue-router中，动态部分 以 : 开头，那么路径就变成了 /user/:id,这条路由就可以这么写： &#123; path:\"/user/:id\", component: user &#125;. .vue&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\" /&gt; &lt;header&gt; &lt;router-link to=\"/home\"&gt;Home&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;About&lt;/router-link&gt; &lt;!-- 增加两个到user组件的导航，可以看到这里使用了不同的to属性 --&gt; &lt;router-link to=\"/user/123\"&gt;User123&lt;/router-link&gt; &lt;router-link to=\"/user/456\"&gt;User456&lt;/router-link&gt; &lt;/header&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;index.js const routes = [ &#123; path:\"/home\", component: home &#125;, &#123; path:\"/about\", component: about &#125;, /*新增user路径，配置了动态的id*/ &#123; path:\"/user/:id\", component: user &#125;, &#123; path: '/', redirect: '/home' &#125; ]获取动态内容&lt;template&gt; &lt;div&gt; &lt;h1&gt;User&lt;/h1&gt; &lt;div&gt;我是user组件, 动态部分是&#123;&#123;dynamicSegment&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; dynamicSegment: '' &#125; &#125;, computed: &#123; dynamicSegment () &#123; return this.$route.params.id &#125; &#125;， watch: &#123; $route (to,from)&#123; this.dynamicSegment = to.params.id &#125; &#125; &#125;&lt;/script&gt; 12345678910114. 命名路由：加一个name 属性 1. ```&lt;router-link to=&quot;/user/123&quot;&gt;User123&lt;/router-link&gt; // 和下面等价 &lt;router-link :to=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;&#123; path: &quot;/user/:id&quot;, name: &quot;user&quot;, component: user&#125; 2.redirect 重定向 概念：是指当页面初始化进入事指向的那个路由。 12const routes = [ // 重定向 &#123; path: '/', redirect: '/home' &#125;， &#123;//点击跳转path:\"/home\", component: home &#125; ] 122. ss","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vuex与父子组件通讯","slug":"vue/vuex与父子组件通讯","date":"2018-05-24T12:29:59.000Z","updated":"2019-06-01T13:35:42.915Z","comments":true,"path":"2018/05/24/vue/vuex与父子组件通讯/","link":"","permalink":"http://yoursite.com/2018/05/24/vue/vuex与父子组件通讯/","excerpt":"","text":"1.vuex 理解 概念：是一个公共的状态库，可以在所有组价库里面去使用，修改。 目录： index.js state.js mutations.js getters.js actions.js 2.store 的状态理解 state：最基本定义的状态： 1. 123456789101112export default &#123; count: 0, price: 100&#125;在组件中运用:Import &#123;mapState&#125; from ‘vuex’Computed:&#123; …mapState(&#123; count:’count’ &#125;)&#125;&lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; getter：相当于计算属性。当我们得到 state 的值之后，使用 getter，将这些基本的值，进行加工，得到我们需要的值 123456789101112export default&#123; total: state =&gt; &#123; return state.count * state.price &#125;&#125;//组件中运用：computed:&#123; …mapGetters(&#123; total:’total’ &#125;)&#125;&lt;p&gt;&#123;&#123;total&#125;&#125;&lt;/p&gt; mutations：改变 state 的值，这个是唯一的方法： 123456789101112131415首先在mutation-type.js中声明变量例如:export const COUNT=‘COUNT’在mutation中操作：import *as types from ‘./mutation-types’Export default&#123; [types.COUNT](state,count)&#123; state.count=count//等号后面的count是这个函数传参进来的值，赋值给state.状态中的count。 &#125;&#125;//组件运用methods:&#123; …mapMutations(&#123; ‘setCount’:types.COUNT//此处的setCount是需要传参的。 &#125;) &#125; 123454. actions： 1. ```undefined假如你有好几个mutation需要提交, 一个一个的写就太傻逼了. 可以用 actions 来封装 mutations. index.js 下面操作 1234567891011121314import vue from ‘vue’ import vuex from ‘vuex’ import state from ‘./state’ import mutations from ‘./mutations’ import getters from ‘./getters’ import actions from ‘./actions’ vue.use(vuex) const store=new Vuex.Store(&#123; state, mutations, getters, actions &#125;) export default store 123456789101112131415161718192021222324252627282930313233343536373839404142436. ss&lt;a name=&quot;l7dzpe&quot;&gt;&lt;/a&gt;### [](#l7dzpe)3.父组件给子组件传值1. s 1. ```javascript//1,父组件的子组件上定义要变量名data，接受要传递的singers数据&lt;template&gt; &lt;div class=&quot;singer&quot;&gt; &lt;singerList :data=&quot;singers&quot;&gt;&lt;/singerList&gt; &lt;/div&gt;&lt;/template&gt;data () &#123; return &#123; singers: [] &#125; &#125;,methods: &#123; _singerData () &#123; api.singerData().then((res) =&gt; &#123; if (res.data.code === ERR_OK) &#123; this.singers = res.data.data.list // console.log(this.singers) &#125; &#125;) &#125; &#125;//在子组件的props接受传递的数据 名称必须与父组件定义的:data变量名一致export default &#123; name: &apos;singer_list&apos;, props: &#123; data: &#123; type: Array, default: () =&gt; [] &#125; &#125;&#125;//在子组件中使用&lt;div class=&quot;singer_list&quot; :singerInfos=&quot;data&quot;&gt;&lt;/div&gt; 4.子组件给父组件传值（$emit）12345678910111213141516171819202122232425262728293031323334353637383940vm.$emit(event,args)//触发当前实例上的事件//子&lt;template&gt; &lt;div class=\"train-city\"&gt; &lt;span @click='select(`大连`)'&gt;大连&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:'trainCity', methods:&#123; select(val) &#123; let data = &#123; cityname: val &#125;; this.$emit('showCityName',data);//select事件触发后，自动触发showCityName事件 &#125; &#125;&#125;&lt;/script&gt;//父&lt;template&gt; &lt;trainCity @showCityName=\"updateCity\" :index=\"goOrtoCity\"&gt;&lt;/trainCity&gt; //监听子组件的showCityName事件。&lt;template&gt;&lt;script&gt;export default &#123; name:'index', data () &#123; return &#123; toCity:\"北京\" &#125; &#125; methods:&#123; updateCity(data)&#123;//触发子组件城市选择-选择城市的事件 this.toCity = data.cityname;//改变了父组件的值 console.log('toCity:'+this.toCity) &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-music歌手详情页","slug":"vue/vue-music歌手详情页","date":"2018-05-21T11:20:59.000Z","updated":"2019-06-01T13:35:18.363Z","comments":true,"path":"2018/05/21/vue/vue-music歌手详情页/","link":"","permalink":"http://yoursite.com/2018/05/21/vue/vue-music歌手详情页/","excerpt":"","text":"1.singer 页面引入 singer-detail 二级路由12345678910111213141516171819202122232425262728//1.在singerlist中触发事件 @click=\"selectItem(items)\"//2.在methods中： selectItem (items) &#123; this.$emit('select', items)//将事件传递给父组件，将items给父组件&#125;,//3.在singer组件中 &lt;div class=\"singer\"&gt; &lt;v-singerlist @select=\"selectSinger\" :singerDatas=\"singers\"&gt;&lt;/v-singerlist&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;//4.在父组件的methods中使用 selectSinger (singer) &#123; this.$router.push(&#123; path: `/singer/$&#123;singer.id&#125;` &#125;) this.setSinger(singer)&#125;//5.index.js路由中配置&#123; path: '/singer', component: Singer, children: [ &#123; path: ':id', component: SingerDetail &#125; ] 2.Vuex 传值vuex 的安装与配置： 1234567891011121314151617181920212223242526272829//1.安装npm install vuex --save//2.在main.js中注入vueximport Vuex from \"vuex\"Vue.use(Vuex)//3.在store.js中使用import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state:&#123; count:0 &#125;, mutations:&#123; increment:state =&gt; state.count ++, decrement:state =&gt; state.count --, &#125;&#125;)&lt;br&gt;//简单的计数//4.在main.js中导入import store from './store/store'//实例化 storenew Vue(&#123; el: '#app', store, router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) vuex 的流程一般为: 定义 state，考虑项目的原始数据(最好是底层数据)。 getter，就是对原始数据的一层映射，可以只为底层数据做一个代理访问，也可以根据底层数据映射为新的计算属性。 mutation 是，定义如何修改数据的逻辑 在定义 mutation 之前，要先定义 mutation-types(通常为动词加名词) actions.js 异步操作 对 mutation 的封装，比如一个动作需要触发多个 mutation 的时候，就可以吧 mutation 封装到 action 是里面去，达到调用一个 action 去修改多个 mutation 的目的。 vuex 传值： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//通过vuex将singerlist.vue的数据传值给singerdetail//1.首先singerlist.vue检测点击事件，将具体点击的歌手派发出去，以供父组件监听selectItem(item)&#123; this.$emit(\"select\",item)&#125;//2.父组件监听事件执行selectSinger(singer)selectSinger(singer)&#123;this.$router.push(&#123; path:`/singer/$&#123;singer.id&#125;` &#125;)this.setSinger(singer)&#125;...mapMutations(&#123; setSinger: 'SET_SINGER'&#125;)//3.使用mapMutations语法映射mutations，this.setSinger(singer)相当于执行this.$store.commit('SET_SINGER')//singer为mutation的地呢个参数[types.SET_SINGER](state, singer) &#123; state.singer = singer&#125;//4.SingerDetail取vuex中存好的数据computed: &#123; ...mapGetters([ 'singer' ])&#125;//getters内singer的逻辑为：singer = state =&gt; state.singer//singerdetail获取的数据的name和avatar通过props传值给MusicList//在singerdetail中&lt;transition name=\"slider\"&gt; &lt;v-musiclist :title=\"title\" :bgImage=\"bgImage\"&gt;&lt;/v-musiclist&gt;&lt;/transition&gt;computed: &#123; title () &#123; return this.singer.name &#125;, bgImage () &#123; return this.singer.avatar &#125;, ...mapGetters([ 'singer' ]) &#125;//在musiclist中props: &#123; title: &#123; type: String, default: '' &#125;, bgImage: &#123; type: String, default: '' &#125; &#125;, 3.歌手详情页对应数据的获取","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"loading-图片懒加载","slug":"vue/loading-图片懒加载","date":"2018-05-18T15:20:59.000Z","updated":"2019-06-01T13:35:03.251Z","comments":true,"path":"2018/05/18/vue/loading-图片懒加载/","link":"","permalink":"http://yoursite.com/2018/05/18/vue/loading-图片懒加载/","excerpt":"","text":"https://www.cnblogs.com/xyyt/p/7650539.html 安装插件 npm install vue-lazyload –save-dev main.js 中插入 12345import VueLazyLoad from \"vue-lazyload\";Vue.use(VueLazyLoad, &#123; error: \"./static/error.png\", loading: require(\"./common/images/default.png\")&#125;); 123454. vue文件中将需要懒加载的图片绑定 v-bind:src 修改为 v-lazy 1. ```&lt;img class=&quot;item-pic&quot; v-lazy=&quot;newItem.picUrl&quot;/&gt; ss","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"axios-获取接口，mock模拟数据配置","slug":"vue/axios-获取接口，mock模拟数据配置","date":"2018-05-17T15:20:59.000Z","updated":"2019-06-01T13:34:30.996Z","comments":true,"path":"2018/05/17/vue/axios-获取接口，mock模拟数据配置/","link":"","permalink":"http://yoursite.com/2018/05/17/vue/axios-获取接口，mock模拟数据配置/","excerpt":"","text":"https://blog.csdn.net/binginsist/article/details/65630547 1.axios 安装 axios : 1npm install --save axios vue-axios 在 main.js 中引入 123import axios from \"axios\";Vue.use(axios);Vue.prototype.$http = axios; 1234567893. 使用方法 1. ```javascriptthis.$http.get(URL).then(response =&gt; &#123; // success callback&#125;, response =&gt; &#123; // error callback&#125;) 2.mock 的使用 在 mock 文件中定义.json 格式的数据 新版在 webpack.dev.conf.js 配置 12345678在const portfinder = require(‘portfinder’)后添加//首先const express = require('express')//是node.js的框架const app = express()//创建一个路由var appData = require('../mock/getDiscList.json')//加载本地数据文件var data = appData.data//获取对应的本地数据var apiRoutes = express.Router()app.use('/api', apiRoutes) //然后找到 devServer,在里面添加before(app) {app.get(‘/api/seller’, (req, res) =&gt; {res.json({errno: 0,data: seller})//接口返回 json 数据，上面配置的数据 seller 就赋值给 data 请求后调用}),app.get(‘/api/goods’, (req, res) =&gt; {res.json({errno: 0,data: goods})}),app.get(‘/api/ratings’, (req, res) =&gt; {res.json({errno: 0,data: ratings})})} 在 api 的 js 问价下获取接口import axios from ‘axios’export function getDiscList () {return axios.get(‘/api/data’)} 在组件中调用created () {// this.$nextTick(() =&gt; {this._getDiscList()this._bannerList()// })},methods: {_getDiscList () {api.getDiscList().then((res) =&gt; {if (res.data.errno === ERR_OK) {this.discList = res.data.data.list} })},} https://blog.csdn.net/firebird_one/article/details/78656500 12343. &lt;a name=&quot;28o9vy&quot;&gt;&lt;/a&gt;### [](#28o9vy)3.$nextTick.将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vueMusic歌手-左右链动","slug":"vue/vueMusic歌手-左右链动","date":"2018-05-17T15:20:59.000Z","updated":"2019-06-01T13:35:30.384Z","comments":true,"path":"2018/05/17/vue/vueMusic歌手-左右链动/","link":"","permalink":"http://yoursite.com/2018/05/17/vue/vueMusic歌手-左右链动/","excerpt":"","text":"https://blog.csdn.net/tyrionj/article/details/79145667 1.singer.vue 数据重构与排序 歌手页面的结构是 热门、 A-Z 的顺序排列，但抓取的接口数据只是 100 条常见的歌手，并且是乱序的，但我们可以利用接口的 Findex 进行数据的重构 1234567const HOT_NAME = \"热门\";let map = &#123; hot: &#123; title: HOT_NAME, item: [] &#125;&#125;; 12345678910111213141516171819202122232. 接着遍历得到的数据，将前10条添加到热门 hot 里。然后查看每条的 Findex ，如果 map[Findex] 没有，创建 map[Findex] push 进新条目，如果 map[Findex] 有，则向其 push 进新条目 1. ```javascriptlist.forEach((item, index) =&gt; &#123; if (index &lt; HOT_SINGER_LEN) &#123; map.hot.items.push(new Singer(&#123; name: item.Fsinger_name, id: item.Fsinger_mid &#125;)) &#125; const key = item.Findex if (!map[key]) &#123; map[key] = &#123; title: key, items: [] &#125; &#125; map[key].items.push(new Singer(&#123; id: item.Fsinger_mid, name: item.Fsinger_name &#125;)) &#125;) 所以还要将其进行排序，这里会用到 数组的 sort 方法，所以我们要先把 map 对象 转为 数组 1. 4) ss 2.右侧锚点点击，滚动对应的区块 点击锚点跳转到对应的区块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781.第一次点击触碰 shortcut获取点击具体锚点的 index 值记录触碰位置的 index ，利用 scrollToElement滚动至相应 index 的区块2.右侧滚动锚点思路：利用touchmove事件，将2次触碰的位置计算变成delta差值，变成改变后锚点区块index值再将首次触碰的index值+改变后的delta值，再利用scrollToElement滚动至相应区块//几种事件修饰符&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt; 阻止事件传播&lt;a v-on:click.stop.prevent=\"doThis\"&gt;&lt;/a&gt;事件可以串联&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;提交事件不再重载页面//1.给li增加data-index='index'这个属性，data-index属性的值为当前的索引值。点击右侧锚点//获取对应的index索引。根据scroll的scrollToElement属性滚动至对应的索引值//vue代码&lt;div class=\"list_shortcut\" @touchstart=\"onShortcutTouchStart\" @touchend.stop&gt; &lt;ul&gt; &lt;li v-for=\"(items,index) in shortcutList\" :key=\"items.id\" :data-index=\"index\" :class=\"&#123;shortcut_item_active:currentIndex===index&#125;\" class=\"shortcut_item\" &gt;&#123;&#123;items&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;//js//封装dom方法 是获取data-index的值export function getData (el, name, val) &#123; let prefix = 'data-' name = prefix + name if (val) &#123; // console.log('el.getAttribute(name)', el.setAttribute(name)) return el.setAttribute(name, val) &#125; else &#123; // console.log('el.getAttribute(name)', el.getAttribute(name)) return el.getAttribute(name) &#125;&#125;//methods: &#123; onShortcutTouchStart (e) &#123; let anchorIndex = getData(e.target, 'index') // 获取 点击具体锚点的 index 值 console.log(anchorIndex) //滚动前获取初始位置 let firstTouch = e.touches[0] this.touch.y1 = firstTouch.pageY// 保存第一次触碰的位置 this.touch.anchorIndex = anchorIndex// 保存第一次触碰锚点的位置 _scrollTo (index) &#123; this.$refs.singerList.scrollToElement(this.$refs.listGroup[index], 0) //当点击右侧锚点的时候回有高亮，并且跳转到对应的位置 this.scrollY = this.$refs.singerlist.scroll.y &#125; &#125;, _scrollTo (index) &#123; if (!index &amp;&amp; index !== 0) &#123; return &#125; this.$refs.singerlist.scrollToElement(this.$refs.listGroup[index], 0) &#125;，//滚动处理 onShortcutTouchMove (e) &#123; let firstTouch = e.touches[0] this.touch.y2 = firstTouch.pageY let delta = (this.touch.y2 - this.touch.y1) / ANCHOR_HEIGHT | 0 let anchorIndex = +this.touch.anchorIndex + delta this._scrollTo(anchorIndex) &#125;//注意这样还不会生效，必须引入scroll.vue并且在scroll.vue中封装scrollTo方法和scrollToElement scrollTo () &#123; this.scroll &amp;&amp; this.scroll.scrollTo.apply(this.scroll, arguments) &#125;, scrollToElement () &#123; this.scroll &amp;&amp; this.scroll.scrollToElement.apply(this.scroll, arguments) &#125;////event.clientX:返回事件触发时鼠标指向与浏览器页面的水平坐标clientY相反发纵轴坐标//event.pageX:鼠标在页面上的位置，从页面左上角开始，即以页面为参考点，不随滑动条移动而变化//event.screenX:用事件属性可返回事件发生时鼠标指向相对于屏幕的水平坐标 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465662. s&lt;a name=&quot;36knqr&quot;&gt;&lt;/a&gt;### [](#36knqr)3.左边内容滚动，右侧自动高亮不同的锚点```javascript$emit：监听触发的自定义事件1.首先BScroll组件 监听滚动事件，并且派发事件以供父组件监听，将pos值传出去if(this.listenScroll)&#123; let self=this this.scroll.on(&apos;scroll&apos;,(pos)=&gt;&#123; self.$emit(&apos;scroll&apos;,pos)&#125;)&#125;2.父组件监听到滚动派发的事件@scroll=&quot;scroll&quot;将pos.y存在this.scrollY this.scrollY = pos.y3.每个区块的高度列表是 通过_calculateHeight函数实现的_calculateHeight()&#123; this.listHeight=[] const list=this.$refs.listGroup let height=0 this.listHeight.push(height) for(let i=0;i&lt;list.length;i++)&#123; let item=list[i] height+=item.clientHeight this.listHeight.push(height) &#125;&#125;//4.用watch检测数据的变化，一旦变化，重新计算每个区块的高度列表，在判断当前滚动的y抽值，是否应该落在相应grop高度区间，然后更新currentIndex，使shorcut的锚点高亮watch: &#123; singerDatas() &#123; // 延时，确保DOM渲染之后执行，通常是nextTick，这里用setTimeout是为了兼容更低 setTimeout(() =&gt; &#123; this._calculateHeight() &#125;, 20) &#125;, // 这里的 scrollY 是当前组件上的，和 BScroll 的并不是一个 scrollY(newY) &#123; const listHeight = this.listHeight // 1. 当滚动至顶部以上 if (newY &gt; 0) &#123; this.currentIndex = 0 return &#125; // 2. 当在中间部分滚动，length之所以 -1 是因为 当初高度列表定义必须多一个 for (let i = 0; i &lt; listHeight.length - 1; i++) &#123; let height1 = listHeight[i] let height2 = listHeight[i + 1] if (-newY &gt;= height1 &amp;&amp; -newY &lt; height2) &#123; this.currentIndex = i this.diff = height2 + newY // height 上限 - newY 的值 return &#125; &#125; // 3. 当滚动至底部，且 newY 大于最后一个元素的上限 this.currentIndex = listHeight.length - 2 &#125;&#125;//6.在右侧列表上绑定高亮的class： :class=&quot;&#123;&apos;shortcut_item_active&apos;:currentIndex===index&#125;&quot; //注意：1.watch函数回调函数，第一个参数是变化后的新值，第二个参数是旧值 //2.scrollY是定义在data里面的，所以当列表滚动的时候，scroll事件的糊掉函数有修改this.scrollY，所以watch能够监听到它的变化 4.滚动固定标题 效果实现1234567891011121314151617181920212223//html固定代码 &lt;div class=\"list_fixed\" v-show=\"fixedTitle\" ref=\"fixed\"&gt; &lt;h1 class=\"fixed-title\"&gt;&#123;&#123;fixedTitle&#125;&#125;&lt;/h1&gt; &lt;/div&gt;//头部title固定效果 fixedTitle () &#123; if (this.scrollY &gt; 0) &#123; return '' &#125; return this.singerDatas[this.currentIndex] ? this.singerDatas[this.currentIndex].title : ''&#125;//在中间部分滚动时，会不断设置diff的值。每个区块的高度上限（就是底部）减去y轴偏移量的值this.diff=height2+newY;//watch监听到diff的变化，判断如果diff&gt;0且小于区块的高度，设为差值，否则为0.在将fixed的title块translate偏移diff(newVal) &#123; let fixedTop = (newVal &gt; 0 &amp;&amp; newVal &lt; TITLE_HEIGHT) ? newVal - TITLE_HEIGHT : 0 if (this.fixedTop === fixedTop) return // 判断如果两个title区块没有碰到，是不会触发 DOM 操作的 this.fixedTop = fixedTop this.$refs.fixed.style.transform = `translate3d(0,$&#123;fixedTop&#125;px,0)`&#125; e.target 与 e.currentTarget 的区别 e.target 是 tap 点击事件触发的对象（也就是点击的是谁） e.currentTarget 是事件绑定在哪个元素上（也就是这个事件在哪个组件上）。 js 中 call 和 apply call()和 apply()是指改变 this 的指向 12345obj.call(thisObj, arg1, arg2, ...);obj.apply(thisObj, [arg1, arg2, ...]);apply：接受的是数组参数call：接受的是连续参数两者作用一致，都是把obj(即this)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj『继承』了obj的属性和方法。绑定后会立即执行函数。 122. s","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"banner横向轮播图-组件封装思路","slug":"vue/banner横向轮播图-组件封装思路","date":"2018-05-17T15:20:59.000Z","updated":"2019-06-01T13:34:37.513Z","comments":true,"path":"2018/05/17/vue/banner横向轮播图-组件封装思路/","link":"","permalink":"http://yoursite.com/2018/05/17/vue/banner横向轮播图-组件封装思路/","excerpt":"","text":"https://segmentfault.com/a/1190000013294187 https://github.com/ustbhuangyi/better-scroll/blob/master/example/components/slide/slide.vue v-for 一定要加 key 否则会报错 1&lt;li v-for=&quot;item in discList&quot; class=&quot;list_item&quot; :key=&quot;item.id&quot;&gt;&lt;/li&gt; 123456789101112131415161718192021222324252627282930&lt;a name=&quot;fn9wrw&quot;&gt;&lt;/a&gt;### [](#fn9wrw)banner1. 初始化图片的宽度个数，并且监听屏幕变化时刷新图片宽度2. 初始化better-scroll滚动条。better-scroll不同的版本对应的内容不一样，此处是v1.11.13. 初始化dots小圆点，注意初始化的dots要放在放过克隆图片的前面。4. 图片链动小圆点，监听scrollEnd事件，在滚动图片的时候对应的获取图片当前的索引值，并赋值给小圆点的active。5. 设置图片自动loop，计时器定义之前必须清除计数器，否则会叠加计时器时间，造成时间混乱6. 自动loop时，如果要操作手动轮播，就要在scrollEnd结束事件中调用_play()，否则滚动完毕不会执行自动轮播。7. 隐形Bug：点击图片拖动至一半，不松手的情况下，会自动轮播下一页。所以：在滚动之前清理计时器，就不会自动轮播，在触摸滚动结束开启计时器。 1. ```javascriptthis.slider.on(&apos;touchEnd&apos;, () =&gt; &#123; // 手指松开 if (this.autoplay) &#123; this._play() &#125; &#125;) this.slider.on(&apos;beforeScrollStart&apos;, () =&gt; &#123; // 滚动之前 if (this.autoplay) &#123; clearTimeout(this.timer) &#125; &#125;) 隐形 Bug：在切换 tab 相当于 切换了 keep-alive 的组件，轮播会出问题，需要手动帮助执行，利用了 activated , deactivated 钩子函数 1234567891011121314151617181920212223activated () &#123; // 这个是keep-alive if (!this.slide) &#123; return &#125; this.scroll.enabled() let pageIndex = this.scroll.getCurrentPage().pageX this.scroll.goToPage(pageIndex, 0, 0) this.currentPageIndex = pageIndex if (this.autoplay) &#123; this._play() &#125; &#125;, deactivated () &#123; if (!this.slide) &#123; return &#125; this.scroll.disable() clearTimeout(this.timer) &#125;, beforeDestroy () &#123; this.slider.disable() clearTimeout(this.timer) &#125;, 123456789101112131415161718192021229. 为了保证改变窗口大小依然正常轮播，监听窗口 resize 事件，重新渲染轮播图 1. ```javascriptwindow.addEventListener(&apos;resize&apos;, () =&gt; &#123; if (!this.slider || !this.slider.enabled) &#123; // this.slider是指全局可以使用 定义全文可以使用 没有放在data中 return &#125; clearTimeout(this.resizeTimer) this.resizeTimer = setTimeout(() =&gt; &#123; if (this.slider.isInTransition) &#123; this._onScrollEnd() &#125; else &#123; if (this.autoplay) &#123; this._play() &#125; &#125; this.refresh() &#125;, 60) // this._setSliderWidth(true) // this.refresh() &#125;) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103mounted () &#123; setTimeout(() =&gt; &#123; this._setSliderWidth() this._initDots() this._initSlider() if (this.autoPlay) &#123; this._play() &#125; &#125;, 20) window.addEventListener('resize', () =&gt; &#123; if (!this.slider) &#123; return &#125; this._setSliderWidth() this.slider.refresh() &#125;) &#125;,activated () &#123; // 这个是keep-alive if (!this.slide) &#123; return &#125; this.scroll.enabled() let pageIndex = this.scroll.getCurrentPage().pageX this.scroll.goToPage(pageIndex, 0, 0) this.currentPageIndex = pageIndex if (this.autoplay) &#123; this._play() &#125; &#125;, deactivated () &#123; if (!this.slide) &#123; return &#125; this.scroll.disable() clearTimeout(this.timer) &#125;, beforeDestroy () &#123; this.slider.disable() clearTimeout(this.timer) &#125;, methods: &#123; _setSliderWidth (isResize) &#123; this.children = this.$refs.sliderGroup.children let sliderWidth = this.$refs.slider.clientWidth let width = 0 for (let i = 0; i &lt; this.children.length; i++) &#123; let child = this.children[i] child.style.width = sliderWidth + 'px' width += sliderWidth &#125; if (this.loop &amp;&amp; !isResize) &#123; width += 2 * sliderWidth &#125; this.$refs.sliderGroup.style.width = width + 'px' &#125;, _initSlider () &#123; this.slider = new Bscroll(this.$refs.slider, &#123; scrollX: true, scrollY: false, momentum: false, snap: &#123; loop: this.loop, threshold: 0.3, speed: 400 &#125; &#125;) this.slider.on('scrollEnd', this._onScrollEnd) this.slider.on('touchEnd', () =&gt; &#123; // 手指松开 if (this.autoplay) &#123; this._play() &#125; &#125;) this.slider.on('beforeScrollStart', () =&gt; &#123; // 滚动之前 if (this.autoplay) &#123; clearTimeout(this.timer) &#125; &#125;) &#125;, _initDots () &#123; this.dots = new Array(this.children.length) &#125;, _onScrollEnd () &#123; let pageIndex = this.slider.getCurrentPage().pageX this.currentPageIndex = pageIndex if (this.autoplay) &#123; this._play() &#125; &#125;, _play () &#123; clearTimeout(this.timer) this.timer = setTimeout(() =&gt; &#123; this.slider.next() &#125;, this.interval) &#125; &#125;//难点：//BScroll 设置 loop 会自动 clone 两个轮播插在前后位置 所以要增加两个width的宽度保证无缝轮播//初始化dots要放在克隆插入图片的前面//dots active状态 是通过判断 currentIndex 与 index 是否相等//currentIndex 更新是通过获取 scroll 当前 page，BScroll 提供了 api 方便调用this.currentPageIndex = this.scroll.getCurrentPage().pageX// clearTimeout(this.timer)必须调用 1211. s","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"better-scroll-配置纵向滚动","slug":"vue/better-scroll-配置纵向滚动","date":"2018-05-17T15:20:59.000Z","updated":"2019-06-01T13:34:45.374Z","comments":true,"path":"2018/05/17/vue/better-scroll-配置纵向滚动/","link":"","permalink":"http://yoursite.com/2018/05/17/vue/better-scroll-配置纵向滚动/","excerpt":"","text":"概念：是一个移动端滚动解决方案。不仅可以做滚动还可以做轮播图1.安装：npm install–save better-scroll2.在文件中引入 better-scroll。import BScroll from ‘better-scroll’;3.new BScroll(Dom 对象,{//opsitons}); 在 Vue 中要获得 Dom 对象，需设置标签属性‘v-el’。 123456789101112131415161718192021222324252627例如：&lt;div v-el:betterscroll&gt;&lt;/div&gt;获取dom对象，this.$els.betterscroll&lt;div class=&quot;wrapper&quot;&gt; 父元素高度固定的 &lt;ul class=&quot;content&quot;&gt;内容高度随着内容撑开 子元素高度大于父元素高度 &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt;&lt;/div&gt;初始化import BScroll from &apos;better-scroll&apos;mounted () &#123; this.$nextTick(() =&gt; &#123; this._initScroll() &#125;) &#125;, methods: &#123; _initScroll () &#123; // if (!this.$refs.wrapper) &#123; // return // &#125; this.scroll = new BScroll(this.$refs.wrapper, &#123; probeType: this.probeType, click: this.click &#125;) &#125; &#125;, 4.","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]}]}