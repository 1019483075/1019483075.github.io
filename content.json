{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"令夕","url":"http://yoursite.com","root":"/"},"pages":[{"title":"这是自我介绍的题目","date":"2019-06-01T08:54:31.000Z","updated":"2019-06-01T08:54:55.313Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这是一段自我介绍"}],"posts":[{"title":"（一）成功学的秘密","slug":"墨菲定理/（一）成功学的秘密","date":"2019-06-01T11:54:40.000Z","updated":"2019-06-01T12:11:52.086Z","comments":true,"path":"2019/06/01/墨菲定理/（一）成功学的秘密/","link":"","permalink":"http://yoursite.com/2019/06/01/墨菲定理/（一）成功学的秘密/","excerpt":"","text":"洛克定律：确定目标，专注行动 有目标才会成功 除非你清楚自己要到哪里去，否则你永远也到不了自己想去的地方。 古希腊彼得斯说：“须有人生的目标，否则精力全属浪费。” 古罗马小塞涅卡说：“有些人活着没有任何目标，他们在世间行走，就像河中一颗小草，他们不是行走，而是随波逐流。” 在这个世界上有这样一种现象，那就是“没有目标的人在为有目标的人达到目标”。 博恩崔西说：“成功就是目标的达成，其他都是这句话的注解”。 目标要“跳一跳，够得着” 目标不是越大也好，越高越棒，而是根据自己的实际情况，制定出切实可行的目标才有效。这个目标不能太容易就能达到，也不能高到永远也碰不着，“跳一跳，够得着”最好。 千里之行始于足下，汪洋大海积于滴水。成功都是一步一步走出来的。当然也有人一页暴富，一下成名，但又有谁能看到他们之前的努力与艰辛。在俄国著名生物学家巴普洛夫临终前，有人向他请教成功的秘诀。巴浦洛夫值说了八个字：“要热诚而且慢慢来”。“热诚”，有持久的兴趣才能坚持到成功。“慢慢来”，不要急于求成，做自己力所能及的事情，然后不断提高自己：不要妄想一步登天，要为自己定一个切实可行的目标，有挑战又能达到，不断追求，走向成功。 瓦拉赫效应：成功，要懂得经营自己的长处 经营自己的长处，让人生增值 曾有一个叫奥托，瓦拉赫的人，中学时，服务为他选了文学之路，可一学期下来，老师给他的评语竟为：‘瓦拉赫很用功，但过分拘泥，这样的人即使有着完美的品德也绝不可能在文学上发挥出来。’无奈，他又改学油画，但这次得到的评语更令人难以接受：“你是绘画艺术方面不可造就之才”。面对如此“笨拙”的学生，大多数老师认为他已成才无望，只有化学老师觉得他做事情一丝不苟，这是做好化学实验应有的品格，建议他试学化学。谁料，瓦拉赫的智慧火花一下子被点燃了，并最终成为了诺贝尔化学奖的得主… 这就是人们广为传颂的“瓦拉赫效应”。承认缺憾，弥补缺陷 缺憾应该成为一种促使自己向上的激励机制，为而不恃一种自甘沉沦的理由，它暗示你在它上面应当作一点努力。 重要的并不在于你做的是什么事，而在于你应当采取某种行动。最不可取的态度是一点事情都不会去做，一味的让自己躲藏在困难的后面，动不动就被困难吓倒，这很任意让自己滋生一种自卑感，久而久之，就什么事情都不敢去做了。 木桶定律：抓最“长”的，不如抓最“短”的 克服人性“短板”，避开成事“暗礁”俗话说“人无完人”，确实，人性是存在许多弱点的，如恶习，自卑，犯错，忧虑，嫉妒等等。根据木桶定律，这些短处往往是限制我们能力的关键。就像木桶一样，一个桶能装多少水，并不是用最长的木板来衡量。而是要靠最短的木板来衡量，木桶装水的容量受到短木板的限制，所以，要想让桐木装更多的说，我们必须加长自己最短的木板。恶习我们时时刻刻都在无意间地培养着习惯，这令我们在很多情况下都要臣服于习惯。而然，好的习惯可我们效力，不好的习惯，尤其是恶习（如果拖沓，酗酒等），会在做事时严重拖我们的腿。所以，我们要学会对自己的习惯分类，对不好的习惯进行改正，完善，一面将成功毁在自己的恶习之中。自卑自卑，可以说是一种性格上的缺陷，表现为对自己能力，品质评价过低。它往往会抹杀我们的自信心，本来有足够的能力去完成学业或者是工作任务，却因怀疑自己而失败，显得处处不行，处处不如别人。所以，做事情要相信自己的能力，要告诉自己“我能行”，“我是最棒的”，那样，才能吧事情办好，走向成功。犯错人们通常不吧犯错看成是一种缺陷，甚至吧“失败乃成功之母”当成自理名言。殊不知，有两种情况下犯错就是一种缺陷。一种是不断地在一个问题上犯错误，另一种是犯错误的频率比别人高。这些错误，或许是因为他们态度问题，或许是他们做事不够细心，没有责任心导致的，但无论那种，都是成功的绊脚石。因此，平时要学会控制自己，改掉马虎大意等不良习惯；犯错后不要找托词和借口，懂得正视错误，并加以改正。忧虑有位作家曾写道，给人们造成精神压力的，并不是今天的现实，而是对昨天所发生事情的悔恨，以及对明天将要发生的事情的忧虑。没错，忧虑不仅会影响我们的心情，而且给我们的工作和学习带来更大的压力。更重要的是，无休止的忧虑并不能解决问题。所以，我们要学会控制自己的情绪，客观地去看待问题，在现实中磨炼自己的性格。妒忌妒忌是人类最普遍，最根深蒂固的感情之一。它的存在，总是令我们不能理智地，积极地做事，于是，常导致事半功倍，甚至劳而无功的结果。因此，无论在生活中，还是在工作中，我们都应平和，宽容地对待他人，客观地看待自己。虚荣每个人都有一点虚荣心，但是过强的虚荣心，使人很容易被赞美之词迷惑，甚至不能自持，很容易被对手打败。所以，我们要控制自己的虚荣，摆脱虚荣，正确地认识自己。贪婪由于太看重眼前的利益，改放弃时不能放弃，结果X成大错，甚至是悔恨终生。总所周知，很多人因太贪钱财等身外之物而毁了大好前程，有时明知是圈套，却因为抵御不住诱惑而落入陷阱。说到底，不是人不聪明，而是白给了自己的贪欲。可见，要成事，先要找对心态，知足才能常乐。 艾森豪威尔法则：分清主次，高效成事 做事分等级，先抓牛鼻子 做事要有科学地安排，要事第一，先抓住牛鼻子，然后在依照轻重缓急逐步执行，一串串，一层层地吧所有的事情拎起来，条理清晰，成效才能最显著，不要眉毛胡子一把抓。 确定事情的顺序 A：必须要做的事情； B：应该做的事情； C：量力而为的事情； D：可委托他人去做的事情； E：应该删除的工作； 每天吧要做的事情写在纸上，按以上5个类别将事情归类： A：需要做； B：应该做； C：做了也不会错； D：可以授权别人去做； E：可以省略不做； 然后根据上面归类，在每天大部分的时间里做A类和B类的事情，即使一天不能完成所有事情，只要将最值得做的事情做完就好。同样的道理，吧自己1~5年内想要做的事情列出来，然后分为A,B,C三类： A：最想做的事情； B：愿意做的事情； C：无所谓的事情； 接着，从A类目标中跳出A1,A2,A3代表最重要，次重要和第三重要的事情。在针对A类目标，抄在另外一张纸上，列出你想要达成这些目标需要做的工作，接着将这份清单在分出A,B,C等级： A：最想做的事情； B：愿意做的事情； C：做了也不会错的事情； 把这些工作放回原来的目标底下，重新调整结构，规划步骤，接着执行。 这些又被称为六步走方法，几挑选目标，设定优先次序，挑选工作，设定优先次序，安排行程，执行。把这些培养成每天的习惯，长期坚持下来并贯彻下去，相信，无数个条理性的成功慢慢积累，将会使你拥有非常成功的人生。 相关定律：","categories":[{"name":"墨菲定律","slug":"墨菲定律","permalink":"http://yoursite.com/categories/墨菲定律/"}],"tags":[{"name":"墨菲定律","slug":"墨菲定律","permalink":"http://yoursite.com/tags/墨菲定律/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-01T08:54:31.000Z","updated":"2019-06-01T09:04:30.786Z","comments":true,"path":"2019/06/01/hello-world/","link":"","permalink":"http://yoursite.com/2019/06/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"（五）Code  Splitting代码分割","slug":"webpack4/（五）Code Splitting代码分割","date":"2019-05-25T13:01:59.000Z","updated":"2019-06-01T12:39:04.855Z","comments":true,"path":"2019/05/25/webpack4/（五）Code Splitting代码分割/","link":"","permalink":"http://yoursite.com/2019/05/25/webpack4/（五）Code Splitting代码分割/","excerpt":"","text":"demo5 源码地址package.json 文件所用依赖，npm install 安装： 1234567891011121314&#123; \"script\": &#123; \"dev\": \"webpack --mode development\", \"build\": \"webpack --mode production\" &#125;, \"devDependencies\": &#123; \"clean-webpack-plugin\": \"^2.0.0\", \"webpack\": \"^4.29.6\", \"webpack-cli\": \"^3.2.3\" &#125;, \"dependencies\": &#123; \"lodash\": \"^4.17.11\" &#125;&#125; 我们在 src/文件夹下创建 index.js 文件 12import _ from 'lodash'console.log(_.join(['a','b','c'])) 目录结构为：配置 webpack.config.js 文件 123456789101112131415161718let path = require('path');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; entry: &#123; main:'./src/index.js', // 入口文件 &#125;, output: &#123; publicPath: __dirname + '/dist/', // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, 'dist'), // 打包文件的输出目录 filename: '[name].bundle.js', // 代码打包后的文件名 chunkFilename: '[name].js' // 代码拆分后的文件名 &#125;, plugins: [ new CleanWebpackPlugin() // 默认情况下，此插件将删除 webpack output.path中所有的文件，以及每次重建后所有未使用的webpack的产品。 ]&#125; 运行 npm run build 打包在 index.html 中使用打包后的文件 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"./dist/main.bundle.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用浏览器打开 index.html 文件，进入控制台，可以看到如下信息：a,b,c 如果我们再改动业务代码，将 index.js 中的代码改为 123import _ from \"lodash\";console.log(_.join([\"a\", \"b\", \"c\"], \"***\")); 再打包，刷新页面可以看到 a***b*****c** 我们引用的第三方框架和我们的业务代码一起被打包，这样会存在着什么问题假设 lodash 为 11M，业务代码也为 11M，打包后就是 2M 浏览器每次打开页面，都要先加载 2M 的文件，才能显示业务逻辑，这样会使得加载时间变长。 业务代码更新会比较频繁，第三方代码基本不会改变，这样重新打包后，假设为 2M 用户重新打开网页后，又会加载 2M 的文件 浏览器是有缓存的，如果文件没有变动的话，就不用去再发送 http 请求，直接从缓存中取，这样在刷新页面或者是第二次进入的时候可以加快网页加载的速度。 怎么解决呢？可以利用 webpack 中代码分割 在 webpack4.0 之前是使用commonsChunkPlugin来拆分公共代码，4.0 之后废弃，并用 splitChunksPlugins在使用 splitChunksPlugins 之前，首先要知道 splitChunksPlugins 是 webpack 主模块中的一个细分模块，无需 npm 引入** 现在我们来配置 webpack.config.js 文件 1234567891011121314151617181920212223let path = require(\"path\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");module.exports = &#123; entry: &#123; main: \"./src/index.js\" // 入口文件 &#125;, output: &#123; publicPath: __dirname + \"/dist/\", // js 引用的路径或者 CDN 地址 path: path.resolve(__dirname, \"dist\"), // 打包文件的输出目录 filename: \"[name].bundle.js\", // 代码打包后的文件名 chunkFilename: \"[name].js\" // 代码拆分后的文件名 &#125;, optimization: &#123; splitChunks: &#123; chunks: \"all\" &#125; &#125;, plugins: [ new CleanWebpackPlugin() // 默认情况下，此插件将删除 webpack output.path中所有的文件，以及每次重建后所有未使用的webpack的产品。 ]&#125;; 上面高亮的代码段就是告诉 webpack，要做代码分割了，这里的 chunk:‘all’是分割所有的代码，包括同步代码和异步代码，webpack 默认是 chunks: ‘async’分割异步代码。 我们使用 npm run dev 来打包开发环境下的代码，这样代码就不会压缩，方便我们来观察，可以看到代码被分割成两个文件了打开dist/main.bundle.js文件，在最底部可以看到 src/index.js，里面放的是业务逻辑代码，但是并没有 lodash 的代码 打开dist/vendors~main.js文件，在最上面可以看到 lodash 模块 再次打开页面，控制台也输出了内容，这样就实现了Code Splitting(代码分割) 其实没有 webpack 的时候，也是有代码分割的，不过是需要我们自己手动的分割，而现在使用了 webpack，通过这种配置项的方式，它会自动帮我们去做代码分割 仔细看分割完的代码名称，vendors~main.js，我们对分割完的名称进行更改 还是在 splitChunks 的配置项中，添加 cacheGroups 对象 12345678910optimization: &#123; splitChunks: &#123; chunks: 'all', cacheGroups: &#123; vendors: &#123; name: 'vendors' &#125; &#125; &#125; &#125; 再次打包就可以看到效果了，*cacheGroups *的默认配置会定义 venders 和 default test: /[\\/]node_modules[\\/]/,使用正则过滤，只有 node_modules 引入第三方库才会被分割为了验证默认配置，我们将 splitChunks 属性设置为空对象，再次打包 打包完发现只有一个文件，这是为什么？因为 chunks 默认为 async，只会分割异步的代码，而我们之前写的都是同步的代码，先 import lodash，再去写业务逻辑，现在使用异步的方式来做，将 index.js 中的代码改为如下： 123456789101112function getComponent() &#123; // 使用 异步的形式导入 lodash，default: _ 表示用 _ 代指 lodash return import(\"lodash\").then((&#123; default: _ &#125;) =&gt; &#123; var element = document.createElement(\"div\"); element.innerHTML = _.join([\"hello\", \"world\"], \"-\"); return element; &#125;);&#125;getComponent().then(element =&gt; &#123; document.body.appendChild(element);&#125;); 这里分割出了 0.js 和 main.bundle.js,0 是以 id 为编号来命名 所以一般我们设置 chunk 是为 all，异步，同步代码都在打包现在我们将 webpack 官网上的默认配置拷贝到我们的 webpack.config.js 中来分析一下 1234567891011121314151617181920212223optimization: &#123; splitChunks: &#123; chunks: 'async', minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125; webpack 代码分割的配置是这样的，比如我们要分割 jQuery 和 lodash 这样的第三方库，它会先经过 chunks、minSize、maxSize、minChunks 等等，满足条件后生成 jQuery 和 lodash 两个文件，然后放入 cacheGroup 中缓存着，再根据你在 cacheGroup 中配置的组来决定是将两个文件整合到一个文件打包，还是单独分开打包，比如上面代码中的 vendors，就是将 node_modules 中所有的第三方库都打包到 vendors.js 文件中，如果你还想继续分割可以这么做 12345678910111213141516cacheGroups: &#123; lodash: &#123; name: 'lodash', test: /[\\\\/]node_modules[\\\\/]lodash[\\\\/]/, priority: 5 // 优先级要大于 vendors 不然会被打包进 vendors &#125;, vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125;&#125; 再次打包，就可以看到 lodash 被分割出来了，以后使用第三方库都可以用这种配置来单独分割成一个 js 文件，比如 element-ui，注意设置 priority 的值很重要，优先级越高的会越先被打包如果 index.js 引入了 A.js 和 B.js，同时 A、B 又引入了 common，common 被引入了两次，可以被称为公共模块目录结构为：代码如下： 12345678910111213141516171819202122232425262728293031// a,jsimport './common'console.log('A')export default 'A'// b.jsimport './common'console.log('B')export default 'B'// common.jsconsole.log('公共模块')export default 'common'// index.jsimport './a.js'import './b.js'// 异步代码function getComponent() &#123; // 使用异步的形式导入 lodash，default: _ 表示用 _ 代指 lodash return import('lodash').then((&#123; default: _ &#125;) =&gt; &#123; var element = document.createElement('div') element.innerHTML = _.join(['hello', 'world'], '-') return element &#125;)&#125;getComponent().then(element =&gt; &#123; document.body.appendChild(element)&#125;) 上面那种异步的写法可能比较绕，现在精简一下，并且 webpack 对异步代码通过注释可以直接修改打包后的名称，以下代码全部以异步的形式引入 123456789101112// 异步代码import(/* webpackChunkName: 'a'*/ \"./a\").then(function(a) &#123; console.log(a);&#125;);import(/* webpackChunkName: 'b'*/ \"./b\").then(function(b) &#123; console.log(b);&#125;);import(/* webpackChunkName: 'use-lodash'*/ \"lodash\").then(function(_) &#123; console.log(_.join([\"1\", \"2\"]));&#125;); 将 minChunks 设置为 2，最小公用 2 次才分割 1234567891011121314151617181920212223242526272829303132333435optimization: &#123; splitChunks: &#123; chunks: 'all', minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; lodash: &#123; name: 'lodash', test: /[\\\\/]node_modules[\\\\/]lodash[\\\\/]/, priority: 10 &#125;, commons: &#123; name: 'commons', minSize: 0, //表示在压缩前的最小模块大小,默认值是 30kb minChunks: 2, // 最小公用次数 priority: 5, // 优先级 reuseExistingChunk: true // 公共模块必开启 &#125;, vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125;&#125; 这里分割出了 lodash 和我们在注释中定义的 use-lodash，前者是第三方库，后者是用第三库写的业务代码，也能被分割出来。 这里之所以会自动引入分割后的依赖，可以查看打包后的 main.bundle.js 文件 常用的配置项在下面的表格中，更多配置详情见官网 参考文章webpack4 系列教程 (三): 多页面解决方案 – 提取公共代码webpack 官网","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（四）用babel编译成 ES6","slug":"webpack4/（四）用babel编译成 ES6","date":"2019-05-24T13:01:59.000Z","updated":"2019-06-01T12:39:26.412Z","comments":true,"path":"2019/05/24/webpack4/（四）用babel编译成 ES6/","link":"","permalink":"http://yoursite.com/2019/05/24/webpack4/（四）用babel编译成 ES6/","excerpt":"","text":"demo4 源码地址 （一）了解 Babel 及生态 现代 javascript 主要是用 ES6 编写的。并非每个浏览器都知道怎么去处理 ES6。我们需要某种转换，这个转换步骤称为 transpiling(转译)。transpiling(转译)是指采用 ES6 的语法，转义为旧的浏览器可以理解的行为。 Webpack不知道如何进行转换但是有loading(加载器)：将他们视为转换器。babel-loader 是一个 webpack 的 loader（加载器），用于将 ES6 及以上的版本编译为 ES5 要开始使用loader，我们需要安装一堆依赖项，建议以 ES7 为主，升级建议 @babel/core webpack 和 babel 之前的一个桥梁 @babel/preset-env: 包含 ES6、7 等版本的语法转化规则 @babel/plugin-transform-runtime:避免 polyfill 污染全局变量，减小打包体积 @babel/polyfill:ES6 内置方法和函数转化垫片 babel-loader: 负责 ES6 的转换 如果是用 babel7 来转义，则需要安装@babel/core,@babel-preset-env 和@babel/plugin-transform-runtime,而不是 babel/core,babel-preset-env 和 babel-transform-runtime，他们是用于 babel6 的。 使用@babel/plugin-transform-runtime 的原因：Babel 使用非常小的功能才完成常见的功能。默认情况下，这将添加到需要他的每个文件中。这种重复有时是不必要的，尤其是当你的应用程序分布在多个文件上的时候。transform-runtime 可以重复使用 Babel 注入的程序代码来节省代码，减小开支。 > 使用@babel/polyfill的原因：Babel默认只转换javascript的句法（syntax），而不转换新的**API,比如Iterator,Generator,Set,Maps,Proxy,Reflect,Symbol,Promise等全局对象,**以及一些定义在全局对象上的方法（比如Object.assgin）都不会转码。必须要使用**@babel/polyfill，**为当前环境提供一个垫片。所谓垫片也就是垫平不同浏览器或者不同环境下的差异。 （二）安装依赖或配置 1.安装依赖 npm i @babel/core babel-loader @babel/preset-env @babel/plugin-transform-runtime –save-devnpm i @babel/polyfill @babel/runtime 2.在项目的根目录中创建名.babelrc 的新文件来配置 Babel; 1234&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; 如果遇到如下错误： 123456WARNING: We noticed you're using the `useBuiltIns` option without declaring a core-js version. Currently, we assume version 2.x when no version is passed. Since this default version will likely change in future versions of Babel, we recommend explicitly setting the core-js version you are using via the `corejs` option.You should also be sure that the version you pass to the `corejs` option matches the version specified in your `package.json`'s `dependencies` section. If it doesn't, you need to run one of the following commands: npm install --save core-js@2 npm install --save core-js@3 yarn add core-js@2 yarn add core-js@3 不仅仅要安装 npm install –save core-js@3 还需要设置 .babelrc 设置 “corejs”: 3 123456789101112&#123; \"preset\": [ [ \"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\", \"corejs\": 3 &#125; ] ], \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; 3.webpack 配置 loader（加载器） 1234567891011module:&#123; rules: [ &#123; test: /\\.js$/, // 使用正则来匹配js文件 exclude: /node_modules/, // 排除依赖包文件 use: &#123; loader: 'babel-loader' //使用babel-loader &#125; &#125; ]&#125; webpack.config.js 配置：4.在 app.js 全局引入@babel/polyfill 并写入 ES6 语法，并执行 npm run build 打包 12345678910111213// 全局引入import '@babel/polyfill'// 测试ES6语法是否通过babel转义const array = [1,2,3]const isES6 = () =&gt; console.log(...array)isES6()const arr = [new Promise(() =&gt; &#123;&#125;),new Promise(() =&gt; &#123;&#125;)]arr.map(item =&gt; &#123; console.log(item)&#125;) 5.打包完之后使用IE 浏览器打开 index.html 文件，看控制台是否有输出，如果是新版的 chrome，是可以使用 es6 语法的，所以要用IE 这个浏览器试试 更改.babelrc，只转译我们使用到的 123456789101112&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\", \"corejs\": 2 &#125; ] ], \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; 同时，将全局引入这段代码注释掉在打包 12// 全局引入js// import '@babel/polyfill' 体积就减小了很多，但是更多的情况是我们并不确切的知道项目中引发兼容性的具体原因，所以还是全局的引入比较好。 （三）了解.browserslistrc 配置文件 browserslistrc 用于在不同前端工具之间共享目标浏览器和 Node.js 版本的配置可以看看 browserslist 兼容浏览器的页面当您将一下内容添加到 package.json 时，所有工具都会自动找到目标浏览器 12345\"browserslist\": [ \"&gt; 1%\", \"last 2 version\", \"not ie &lt;= 8\"] 也可以创建.browserslistrc 文件单独写配置 # 所支持的浏览器版本 1% #全球使用统计选择的浏览器版本样式last 2 version #每个浏览器的最后两个版本not ie &lt;= 8 排除小于 ie8 一下的浏览器 该项目还是使用单独创建配置文件的方式，便于理解，如果觉得配置文件不好，也可以写在 package.json 中 参考文献 webpack4 系列教程 (二): 编译 ES6babel 7 的使用的个人理解babel 7 升级建议browserslist","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（三）覆盖默认entry和output","slug":"webpack4/（三）覆盖默认entry和output","date":"2019-05-23T13:01:59.000Z","updated":"2019-06-01T12:39:16.939Z","comments":true,"path":"2019/05/23/webpack4/（三）覆盖默认entry和output/","link":"","permalink":"http://yoursite.com/2019/05/23/webpack4/（三）覆盖默认entry和output/","excerpt":"","text":"demo3 源码地址 1.检验 webpack 规范支持webpack 支持 ES6，CommonJS，AMD 规范创建 wendor 文件夹，其中 minus.js,multi.js 和 sum.js 分别用 CommonJS，AMD，ES6 规范编写 1234567891011121314151617// CommonJS minus.jsmodule.exports = function(a, b) &#123; return a - b;&#125;;// AMD multi.jsdefine([\"require\", \"dependency\"], function(require, factory) &#123; \"use strict\"; return function(a, b) &#123; return a * b; &#125;;&#125;);// ES6 sum.jsexport default function(a, b) &#123; return a + b;&#125; 在 index.js 中引入以上三个文件 2.编写配置文件覆盖 entry/outputwebpack.config.js 是 webpack 默认配置的文件名，在根目录下创建： 1234567891011let path = require(\"path\");module.exports = &#123; entry: \"./src/index.js\", // 入口文件 output: &#123; path: path.resolve(__dirname, \"dist\"), // __dirname 是指webpack.config.js的绝对路径 dist 是指出口的目录 filename: \"bundle.js\", // 打包输出的文件夹的文件名 publicPath: __dirname + \"/dist/\" // 打包后的文件夹 &#125;, module: &#123;&#125;, plugins: []&#125;; path.resolve() 方法会把一个路径或者是路径片段的序列解析为一个绝对路径__dirname：当前模板的文件夹名称。 可以使用 console.log 输出下就明白了执行 npm run build 打包 js 文件会发现生成了 dist 文件，并且生成了两个打包后的文件 这跟 AMD 的引入方式有关，如果在 app.js 中注释掉 AMD 的写法，则只会打包出一个 bundle.js 文件 在实际写代码的时候，最好使用 ES6 和 CommonJS 的规范来写 当你注释 AMD 后，打包后的 dist 中有多个文件，这是因为打包的时候没有先删除掉 dist 文件，在打包，我们需要使用一个插件来帮助我们实现：github 链接：clear-webpack-plugin1.安装插件npm install clean-webpack-plugin –save-dev2.修改 webpack 配置文件 1234567891011121314let path = require(\"path\");const CleanWebpackPlugin = require(\"clean-webpack-plugin\");module.exports = &#123; entry: \"./src/index.js\", // 入口文件 output: &#123; path: path.resolve(__dirname, \"dist\"), // __dirname 是指webpack.config.js的绝对路径 bundle 是指出口的文件名 filename: \"bundle.js\", // 打包输出的文件夹的文件名 publicPath: __dirname + \"/dist/\" // 打包后的文件夹 &#125;, module: &#123;&#125;, plugins: [ new CleanWebpackPlugin() // 默认情况下，此插件将删除 webpack output.path中所有的文件，以及每次重建后所有未使用的webpack的产品。 ]&#125;; 之后在执行 npm run build 就可以了 打包后的 js 文件会按照我们的配置放在 dist 目录下，创建一个 html 文件，引用打包好的 js 文件，打卡 F12 就能看到效果了。 参考文献 webpack4 系列教程 (一): 打包 JSWebpack4 教程：从零配置到生产模式","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（二）生产和开发模式","slug":"webpack4/（二）生产和开发模式","date":"2019-05-22T13:01:59.000Z","updated":"2019-06-01T12:39:20.459Z","comments":true,"path":"2019/05/22/webpack4/（二）生产和开发模式/","link":"","permalink":"http://yoursite.com/2019/05/22/webpack4/（二）生产和开发模式/","excerpt":"","text":"demo2 源码记录拥有 2 个配置文件在 webpack 中是常见的模式。一个典型的项目可能有： 用于开发的配置文件，配置热更新，跨域配置，端口设置等。 用于生产的配置文件，配置 js 压缩，代码拆分等。 虽然在较大的项目可能任然需要 2 个配置文件，但是在 webpack4.0 中，你可以在没有一行配置的情况下完成。 细心的朋友会发现在 npm run build 打包后会有一段报警提示‘mode’选项尚未设置，webpack 将会退到‘production’。将‘mode’选项设置为‘development’或者‘production’以启用每个环境的默认值。你还可以将其设置为‘none’以禁止任何默认行为。 1.打开 package.json 并填充 script 部分，如下所示： 12\"dev\": \"webpack --mode development\",\"build\": \"webpack --mode production\", 2.运行 npm run dev 打开./build/bundle.js，是一个 bundle（包）文件，并没有压缩！ 3.运行 npm run build可以看到./build/bundle.js 文件已经压缩了 其实在终端里面发现，看构建完的大小，dev 模式下文件大小是 3.81KB,build 模式下文件大小仅为 966 字节 production mode（生成模式）可以开箱即用地进行各种优化。包括压缩，作用域提升，tree-shaking 等。另一方面，development mode(开发模式）针对速度进行了优化，仅仅提供了一种不压缩的 bundle。 在 webpack4.0 中,可以在没有一行配置的情况下完成任务！只需定义-mode 的参数即可获得所有内容！","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]},{"title":"（一）搭建项目并打包JS文件","slug":"webpack4/（一）搭建项目并打包JS文件","date":"2019-05-21T13:01:59.000Z","updated":"2019-06-01T12:39:12.011Z","comments":true,"path":"2019/05/21/webpack4/（一）搭建项目并打包JS文件/","link":"","permalink":"http://yoursite.com/2019/05/21/webpack4/（一）搭建项目并打包JS文件/","excerpt":"","text":"依赖环境：os:win10node:10.5.0npm:6.1.0webpack:4.29.6webpack-cli:3.2.4每个知识点对应一个 demo，clone 源码后运行 npm install 安装依赖 1.搭建项目并且打包 js 文件demo1 源码地址创建空文件夹，通过运行一下命令进行初始化 package.json:npm init npm int 用来初始化生成一个新的 package.json 文件。他会向用户提一系列问题，如果不觉得不需要修改默认配 置，一路回车就可以了。如果使用了-y（代表 yes），则跳过了提问阶段，直接生成一个新的 package.json 文 件。引入 webpacknpm i webpack –save-dev还需要 webpack-cli，作为一个单独的包引入，如果不装 webpack-cli 是无法在命令行里面使用 webpack 的npm i webpack-cli –save-dev该项目 webpack 的版本如下： 12\"webpack\": \"^4.32.0\",\"webpack-cli\": \"^3.3.2\" 现在打开 package.json 并且添加一个 build（构建）脚本： 尝试运行看看会发生什么：npm run build 在 webpack4.0 版本中，必须在名为 webpack.config.js 的配置文件中，通过 entry 属性定义 entry point（入口点），就行这样： 从 webpack4.0 开始，就不必在在定义 entry point（入口点）：它默认为./src/index.js测试这个功能前，首先创建.src/index.js 文件 在次运行 npm run build 试试： 打包成功，并且在当前的根目录中得到打包后的文件夹，也就是 build 文件夹： 讲查找./src/index.js 作为默认入口点。而且，他会在./build/bundle.js 中输出模块包，目前代码量小，可以格式化看看效果：至此，打包 js 结束参考：webpack 官网入门","categories":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/categories/webpack4/"}],"tags":[{"name":"webpack4","slug":"webpack4","permalink":"http://yoursite.com/tags/webpack4/"}]}]}